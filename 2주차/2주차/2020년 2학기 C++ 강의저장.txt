


-------------------------------------------
소스.cpp - 2020-09-23 오전 11:42:34 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             9.23        (4주 1일)
//
// 9. 28 시험
//
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

// [문제] f는 배열의 정보를 넘겨받아 배열의 값을 2배로 만든다
// 함수를 선언 정의 호출하라

void twice( int*, int );

int main()
{
	int a[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

	int size = sizeof(a) / sizeof(int);

		// 함수호출
	twice(a, size);

	for (int num : a)
		cout << num << ' ';
	cout << endl;
	// 2 4 6 8 10

	save("소스.cpp");
}

void twice( int* p, int n )
{
	for (int i = 0; i < n; ++i)
		*p++ *= 2;
}




-------------------------------------------
소스.cpp - 2020-09-23 오전 11:45:04 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             9.23        (4주 1일)
//
// 9. 28 시험
//
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

// [문제] f는 배열의 정보를 넘겨받아 배열의 값을 2배로 만든다
// 함수를 선언 정의 호출하라

void f( int*, int );

int main()
{
	int a[] { 1, 2, 3, 4, 5, 6 };

	int size = sizeof(a) / sizeof(int);

		// 함수호출
	f(a, size);

	for (int num : a)
		cout << num << ' ';
	cout << endl;
	// 2 4 6 8 10

	save("소스.cpp");
}

void f( int* p, int n )
{
	for (int i = 0; i < n; ++i)
		*p++ *= 2;
}




-------------------------------------------
소스.cpp - 2020-09-23 오전 11:50:25 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             9.23        (4주 1일)
//
// 9. 28 시험
//
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

// [문제] f는 배열의 정보를 넘겨받아 배열의 값을 2배로 만든다
// 함수를 선언 정의 호출하라

//void f( int*, int );

int main()
{
	int a[] { 1, 2, 3, 4, 5, 6 };

	int size = sizeof(a) / sizeof(int);

	// 함수호출
	void f( int*, size_t );
	f(a, size);

	for (int num : a)
		cout << num << ' ';
	cout << endl;
	// 2 4 6 8 10

	save("소스.cpp");
}

void f( int* p, size_t num )
{
	for (int i = 0; i < num; ++i)
		*(p + i) *= 2;
}




-------------------------------------------
소스.cpp - 2020-09-23 오전 11:51:02 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             9.23        (4주 1일)
//
// 9. 28 시험
//
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

// [문제] f는 배열의 정보를 넘겨받아 배열의 값을 2배로 만든다
// 함수를 선언 정의 호출하라

//void f( int*, int );

int main()
{
	int a[] { 1, 2, 3, 4, 5, 6 };


	// 함수호출
	void f( int*, size_t );
	f(a, sizeof(a) / sizeof(int));

	for (int num : a)
		cout << num << ' ';
	cout << endl;
	// 2 4 6 8 10

	save("소스.cpp");
}

void f( int* p, size_t num )
{
	for (int i = 0; i < num; ++i)
		*(p + i) *= 2;
}




-------------------------------------------
소스.cpp - 2020-09-23 오전 11:56:00 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             9.23        (4주 1일)
//
// 9. 28 시험
//
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

// [문제] f는 배열의 정보를 넘겨받아 배열의 값을 2배로 만든다
// 함수를 선언 정의 호출하라

//void f( int*, int );

int main()
{
	int a[] { 1, 2, 3, 4, 5, 6 };


	// 함수호출
	void f( int*, size_t );
	f(a, sizeof(a) / sizeof(int));

	for (int num : a)
		cout << num << ' ';
	cout << endl;
	// 2 4 6 8 10

	save("소스.cpp");
}

void f( int* p, size_t num )
{
	for (int i = 0; i < num; ++i)
		p[i] *= 2;

	// *(p+i) 조작을 p[i]로 사용할 수 있는 것은 
	// 꿀 문법때문이다.   -> syntactic sugar
}




-------------------------------------------
소스.cpp - 2020-09-23 오후 12:22:04 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             9.23        (4주 1일)
//
// 9. 28 시험
//
// 값을 정렬해 본다. 버블 정렬
// 처리할 자료의 수를 늘려가며 필요한 내용을 공부해 본다
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

int main()
{
	int a[]{ 3, 9, 1, 5, 7 };
	int num = sizeof(a) / sizeof(int);
	int temp{};
	for ( int i = 0; i < num - 1; ++i )
		if (a[i] > a[i + 1]) {
			temp = a[i];
			a[i] = a[i + 1];
			a[i + 1] = temp;
		}

	for (int n : a)
		cout << n << ' ';
	cout << endl;

	save("소스.cpp");
	}



-------------------------------------------
소스.cpp - 2020-09-23 오후 12:22:29 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             9.23        (4주 1일)
//
// 9. 28 시험
//
// 값을 정렬해 본다. 버블 정렬
// 처리할 자료의 수를 늘려가며 필요한 내용을 공부해 본다
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

int main()
{
	int a[]{ 3, 9, 1, 5, 7 };
	int num = sizeof(a) / sizeof(int);
	int temp{};
	for ( int i = 0; i < num - 1; ++i )
		if (a[i] > a[i + 1]) {
			temp = a[i];
			a[i] = a[i + 1];
			a[i + 1] = temp;
		}

	for (int n : a)
		cout << n << ' ';
	cout << endl;

	save("소스.cpp");
	}




-------------------------------------------
소스.cpp - 2020-09-23 오후 12:50:51 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             9.23        (4주 1일)
//
// 9. 28 시험
//
// 값을 정렬해 본다. 버블 정렬
// 처리할 자료의 수를 늘려가며 필요한 내용을 공부해 본다
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

int main()
{
	int a[]{ 3, 9, 1, 5, 7 };
	int num = sizeof(a) / sizeof(int);

	// bubble sort
	for ( int j = 0; j < num - 1; ++j ) {
		for (int i = 0; i < num - (j + 1); ++i) {
			if (a[i] > a[i + 1]) {
				swap(a[i], a[i + 1]);
			}
		}
	}
	for (int n : a)
		cout << n << ' ';
	cout << endl;
	save("소스.cpp");
}




-------------------------------------------
소스.cpp - 2020-09-23 오후 12:57:52 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             9.23        (4주 1일)
//
// 9. 28 시험
//
// 값을 정렬해 본다. 버블 정렬
// 처리할 자료의 수를 늘려가며 필요한 내용을 공부해 본다
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

int main()
{
	int a[]{ 3, 9, 1, 5, 7 };
	int num = sizeof(a) / sizeof(int);
	
	// bubble sort
	for ( int j = 0; j < num - 1; ++j ) {
		for (int i = 0; i < num - (j + 1); ++i) {
			if (a[i] > a[i + 1]) {
				// 함수 호출이 아니고 코드를 inline 한다
				swap(a[i], a[i + 1]);
			}
		}
	}
	for (int n : a)
		cout << n << ' ';
	cout << endl;
	save("소스.cpp");
}




-------------------------------------------
소스.cpp - 2020-09-23 오후 1:00:37 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             9.23        (4주 1일)
//
// 9. 28 시험
//
// 값을 정렬해 본다. 버블 정렬
// 처리할 자료의 수를 늘려가며 필요한 내용을 공부해 본다
//-----------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include "save.h"
using namespace std;

int main()
{
	int a[]{ 1, 3, 5, 7, 9, 2, 4, 6, 8, 10 };

	sort( begin(a), end(a) );

	for (int n : a)
		cout << n << ' ';
	cout << endl;
	save("소스.cpp");
}




-------------------------------------------
소스.cpp - 2020-09-23 오후 1:04:40 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             9.23        (4주 1일)
//
// 9. 28 시험
//
// 값을 정렬해 본다. 버블 정렬
// 처리할 자료의 수를 늘려가며 필요한 내용을 공부해 본다
//-----------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include "save.h"
using namespace std;

int main()
{
	int a[]{ 1, 3, 5, 7, 9, 2, 4, 6, 8, 10 };

	sort(begin(a), end(a), [](int a, int b) {
		return a > b;
	});

	for (int n : a)
		cout << n << ' ';
	cout << endl;
	save("소스.cpp");
}




-------------------------------------------
소스.cpp - 2020-09-23 오후 1:19:56 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             9.23        (4주 1일)
//
// 9. 28 시험
//
// 값을 정렬해 본다. 버블 정렬
// 처리할 자료의 수를 늘려가며 필요한 내용을 공부해 본다
//-----------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] 문장을 오름차순으로 정렬하여 출력하라.
int main()
{
	char str[] = "The quick brown fox jumps over the lazy dog";
	int num = strlen(str);
	for (int i = 0; i < num - 1; ++i) {
		for (int j = 0; j < num - (i + 1); ++j) {
			if (str[j] > str[j + 1]) {
				char temp{ str[j] };
				str[j] = str[j + 1];
				str[j + 1] = temp;
			}
		}
	}
	
	cout << str << endl;

	save("소스.cpp");
}




-------------------------------------------
소스.cpp - 2020-09-23 오후 1:21:25 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             9.23        (4주 1일)
//
// 9. 28 시험
//
// 값을 정렬해 본다. 버블 정렬
// 처리할 자료의 수를 늘려가며 필요한 내용을 공부해 본다
//-----------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] 문장을 오름차순으로 정렬하여 출력하라.
int main()
{
	char str[] = "The quick brown fox jumps over the lazy dog";

	sort(begin(str), end(str));

	cout << str << endl;



	//int num = strlen(str);
	//for (int i = 0; i < num - 1; ++i) {
	//	for (int j = 0; j < num - (i + 1); ++j) {
	//		if (str[j] > str[j + 1]) {
	//			char temp{ str[j] };
	//			str[j] = str[j + 1];
	//			str[j + 1] = temp;
	//		}
	//	}
	//}

	save("소스.cpp");
}




-------------------------------------------
소스.cpp - 2020-10-05 오후 1:28:06 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             9.23        (4주 1일)
//
// 9. 28 시험
//
// 값을 정렬해 본다. 버블 정렬
// 처리할 자료의 수를 늘려가며 필요한 내용을 공부해 본다
//-----------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] 문장을 오름차순으로 정렬하여 출력하라.
int main()
{
	char str[] = "The quick brown fox jumps over the lazy dog";
	int num = strlen(str);

	sort(str, str+num);

	cout << str << endl;

	save("소스.cpp");
}




-------------------------------------------
소스.cpp - 2020-10-05 오후 2:42:38 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.5        (5주 1일)
//
// 값을 정렬해 본다. 버블 정렬
// 처리할 자료의 수를 늘려가며 필요한 내용을 공부해 본다.
// STACK, DATA, HEAP(Free Store), CODE
//-----------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] 문장을 오름차순으로 정렬하여 출력하라.
int main()
{
	char str[] = "The quick brown fox jumps over the lazy dog";

	sort( begin( str ), end( str ));

	cout << str << endl;

	save("소스.cpp");
}




-------------------------------------------
소스.cpp - 2020-10-05 오후 2:42:54 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.5        (5주 1일)
//
// 값을 정렬해 본다. 버블 정렬
// 처리할 자료의 수를 늘려가며 필요한 내용을 공부해 본다.
// STACK, DATA, HEAP(Free Store), CODE
//-----------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] 문장을 오름차순으로 정렬하여 출력하라.
int main()
{
	char str[] = "The quick brown fox jumps over the lazy dog";

	sort( begin( str ), end( str ));

	cout << str + 1 << endl;

	save("소스.cpp");
}




-------------------------------------------
소스.cpp - 2020-10-05 오후 2:45:13 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.5        (5주 1일)
//
// 값을 정렬해 본다. 버블 정렬
// 처리할 자료의 수를 늘려가며 필요한 내용을 공부해 본다.
// STACK, DATA, HEAP(Free Store), CODE
//-----------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] 문장을 오름차순으로 정렬하여 출력하라.
// (의문) 내림차순으로 정렬할 수는 없을까?

int main()
{
	char str[] = "The quick brown fox jumps over the lazy dog";

	sort( begin( str ), end( str ) - 1);

	cout << str << endl;

	save("소스.cpp");
}




-------------------------------------------
소스.cpp - 2020-10-05 오후 2:55:00 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.5        (5주 1일)
//
// 값을 정렬해 본다. 버블 정렬
// 처리할 자료의 수를 늘려가며 필요한 내용을 공부해 본다.
// STACK, DATA, HEAP(Free Store), CODE
//-----------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] 문장을 오름차순으로 정렬하여 출력하라.
// (의문) 내림차순으로 정렬할 수는 없을까?

bool xxx(char, char);

bool xxx(char a, char b)
{
	return (a > b);
	/*if (a > b)    // return (a > b) 랑 같다
		return true;
	return false;
	*/
}

int main()
{
	char str[] = "The quick brown fox jumps over the lazy dog";

	sort( begin( str ), end( str ) - 1, xxx );

	cout << str << endl;

	save("소스.cpp");
}




-------------------------------------------
소스.cpp - 2020-10-05 오후 3:13:11 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.5        (5주 1일)
//
// 값을 정렬해 본다. 버블 정렬
// 처리할 자료의 수를 늘려가며 필요한 내용을 공부해 본다.
// STACK, DATA, HEAP(Free Store), CODE
//-----------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <random>
#include "save.h"
using namespace std;

// [문제] 소문자 10만개를 저장하고 오름차순으로 정렬후 출력하라.

default_random_engine dre;
uniform_int_distribution<> uid{ 'a', 'z' };

int main()
{
	char alpha[100'000];

	for (int i = 0; i < 100'000; ++i)
		alpha[i] = dre();

	sort(begin(alpha), end(alpha) - 1);

	save("소스.cpp");
}




-------------------------------------------
소스.cpp - 2020-10-05 오후 3:13:26 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.5        (5주 1일)
//
// 값을 정렬해 본다. 버블 정렬
// 처리할 자료의 수를 늘려가며 필요한 내용을 공부해 본다.
// STACK, DATA, HEAP(Free Store), CODE
//-----------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <random>
#include "save.h"
using namespace std;

// [문제] 소문자 10만개를 저장하고 오름차순으로 정렬후 출력하라.

default_random_engine dre;
uniform_int_distribution<> uid{ 'a', 'z' };

int main()
{
	char alpha[100'000];

	for (int i = 0; i < 100'000; ++i)
		alpha[i] = dre();

	sort(begin(alpha), end(alpha) - 1);

	cout << alpha << endl;

	save("소스.cpp");
}




-------------------------------------------
소스.cpp - 2020-10-05 오후 3:14:41 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.5        (5주 1일)
//
// 값을 정렬해 본다. 버블 정렬
// 처리할 자료의 수를 늘려가며 필요한 내용을 공부해 본다.
// STACK, DATA, HEAP(Free Store), CODE
//-----------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <random>
#include "save.h"
using namespace std;

// [문제] 소문자 10만개를 저장하고 오름차순으로 정렬후 출력하라.

default_random_engine dre;
uniform_int_distribution<> uid{ 'a', 'z' };

int main()
{
	char alpha[100'000];

	for (int i = 0; i < 100'000; ++i)
		alpha[i] = uid(dre);

	sort(begin(alpha), end(alpha) - 1);

	cout << alpha << endl;

	save("소스.cpp");
}




-------------------------------------------
소스.cpp - 2020-10-05 오후 3:15:26 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.5        (5주 1일)
//
// 값을 정렬해 본다. 버블 정렬
// 처리할 자료의 수를 늘려가며 필요한 내용을 공부해 본다.
// STACK, DATA, HEAP(Free Store), CODE
//-----------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <random>
#include "save.h"
using namespace std;

// [문제] 소문자 10만개를 저장하고 오름차순으로 정렬후 출력하라.

default_random_engine dre;
uniform_int_distribution<> uid{ 'a', 'z' };

int main()
{
	char alpha[100'000];

	for (char& c : alpha)
		c = uid( dre );

	sort(begin(alpha), end(alpha) - 1);

	cout << alpha << endl;

	save("소스.cpp");
}




-------------------------------------------
소스.cpp - 2020-10-05 오후 3:17:24 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.5        (5주 1일)
//
// 값을 정렬해 본다. 버블 정렬
// 처리할 자료의 수를 늘려가며 필요한 내용을 공부해 본다.
// STACK, DATA, HEAP(Free Store), CODE
//-----------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <random>
#include "save.h"
using namespace std;

// [문제] 소문자 10만개를 저장하고 오름차순으로 정렬후 출력하라.

default_random_engine dre;
uniform_int_distribution<> uid{ 'a', 'z' };

int main()
{
	char alpha[100'000];

	for (char& c : alpha)
		c = uid( dre );

	sort(begin(alpha), end(alpha));

	cout << alpha << endl;

	save("소스.cpp");
}




-------------------------------------------
소스.cpp - 2020-10-05 오후 3:17:39 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.5        (5주 1일)
//
// 값을 정렬해 본다. 버블 정렬
// 처리할 자료의 수를 늘려가며 필요한 내용을 공부해 본다.
// STACK, DATA, HEAP(Free Store), CODE
//-----------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <random>
#include "save.h"
using namespace std;

// [문제] 소문자 10만개를 저장하고 오름차순으로 정렬후 출력하라.

default_random_engine dre;
uniform_int_distribution<> uid{ 'a', 'z' };

int main()
{
	char alpha[100'000]{ };

	for (char& c : alpha)
		c = uid( dre );

	sort(begin(alpha), end(alpha));

	cout << alpha << endl;

	save("소스.cpp");
}




-------------------------------------------
소스.cpp - 2020-10-05 오후 3:18:12 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.5        (5주 1일)
//
// 값을 정렬해 본다. 버블 정렬
// 처리할 자료의 수를 늘려가며 필요한 내용을 공부해 본다.
// STACK, DATA, HEAP(Free Store), CODE
//-----------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <random>
#include "save.h"
using namespace std;

// [문제] 소문자 100만개를 저장하고 오름차순으로 정렬후 출력하라.

default_random_engine dre;
uniform_int_distribution<> uid{ 'a', 'z' };

int main()
{
	char alpha[1'000'000]{ };

	for (char& c : alpha)
		c = uid( dre );

	sort(begin(alpha), end(alpha));

	cout << alpha << endl;

	save("소스.cpp");
}




-------------------------------------------
소스.cpp - 2020-10-07 오후 12:08:59 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.7        (5주 2일)
//
// 값을 정렬해 본다. 버블 정렬
// 처리할 자료의 수를 늘려가며 필요한 내용을 공부해 본다.
// STACK, DATA, HEAP(Free Store), CODE
//-----------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <random>
#include "save.h"
using namespace std;

// [문제] 소문자 200만개를 저장하고 오름차순으로 정렬후 출력하라.

default_random_engine dre;
uniform_int_distribution<> uid{ 'a', 'z' };

int main()
{
	char alpha[1'000'000];

	cout << (void*)(char*)alpha << endl;

	save("소스.cpp");
}




-------------------------------------------
소스.cpp - 2020-10-07 오후 12:13:56 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.7        (5주 2일)
//
// 값을 정렬해 본다. 버블 정렬
// 처리할 자료의 수를 늘려가며 필요한 내용을 공부해 본다.
// STACK, DATA, HEAP(Free Store), CODE
//-----------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include <random>
#include "save.h"
using namespace std;

// [문제] 소문자 200만개를 저장하고 오름차순으로 정렬후 출력하라.

default_random_engine dre;
uniform_int_distribution<> uid{ 'a', 'z' };

int main()
{
	char alpha[1'000'000]; // alpha는 지역변수이고
						   // 지역변수는 STACK에 생성된다
						   // 최대 1MB까지 사용할 수 있다.

	cout << (void*)alpha << endl;

	save("소스.cpp");
}




-------------------------------------------
소스.cpp - 2020-10-07 오후 12:39:44 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.7        (5주 2일)
//
// 값을 정렬해 본다. 버블 정렬
// 처리할 자료의 수를 늘려가며 필요한 내용을 공부해 본다.
// STACK, DATA, HEAP(Free Store), CODE
//-----------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include <random>
#include "save.h"
using namespace std;

// [문제] 소문자 200만개를 저장하고 오름차순으로 정렬후 출력하라.

default_random_engine dre;
uniform_int_distribution<> uid{ 'a', 'z' };

// [문제] 소문자 천만개를 저장하고 내림차순으로 정렬한 후
// 제일 첫글자와 제일 마지막 글자를 화면에 출력하라.

char a[10'000'000];

int main()
{
	
	for (char& b : a)
		b = uid(dre);

	sort(begin(a), end(a), [](char a, char b) {
		return a > b;
		});

	cout << "첫 글자" << a[0] << endl;
	cout << "마지막 글자" << a[10'000'000] << endl;

	save("소스.cpp");
}




-------------------------------------------
소스.cpp - 2020-10-07 오후 12:40:28 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.7        (5주 2일)
//
// 값을 정렬해 본다. 버블 정렬
// 처리할 자료의 수를 늘려가며 필요한 내용을 공부해 본다.
// STACK, DATA, HEAP(Free Store), CODE
//-----------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include <random>
#include "save.h"
using namespace std;

// [문제] 소문자 200만개를 저장하고 오름차순으로 정렬후 출력하라.

default_random_engine dre;
uniform_int_distribution<> uid{ 'a', 'z' };

// [문제] 소문자 천만개를 저장하고 내림차순으로 정렬한 후
// 제일 첫글자와 제일 마지막 글자를 화면에 출력하라.

char a[10'000'000];

int main()
{
	
	for (char& b : a)
		b = uid(dre);

	sort(begin(a), end(a), [](char a, char b) {
		return a > b;
		});

	cout << "첫 글자" << a[0] << endl;
	cout << "마지막 글자" << a[9'999'999] << endl;

	save("소스.cpp");
}




-------------------------------------------
소스.cpp - 2020-10-07 오후 1:00:18 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.7        (5주 2일)
//
// 값을 정렬해 본다. 버블 정렬
// 처리할 자료의 수를 늘려가며 필요한 내용을 공부해 본다.
// STACK, DATA, HEAP(Free Store), CODE
//-----------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include <random>
#include "save.h"
using namespace std;

default_random_engine dre{ random_device()() };
uniform_int_distribution<> uid{ 'a', 'z' };

// [문제] 소문자 가능한 만큼을 저장하고 내림차순으로 정렬한 후
// 제일 첫글자와 제일 마지막 글자를 화면에 출력하라.

char a[1'500'000'000];	// 1G 바이트

int main()
{
	cout << "값을 쓰는 중" << endl;
	for (char& a : a)
		a = uid(dre);

	cout << "정렬하는 중" << endl;
	sort(begin(a), end(a), [](char a, char b) {
		return a > b;
		});

	cout << "전체 글자의 갯수 - " << sizeof(a) << endl;
	cout << "제일 첫 글자" << a[0] << endl;
	cout << "제일 마지막 글자" << a[sizeof(a) - 1] << endl;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-12 오후 1:39:00 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.12       (6주 1일)
//
// 처리할 자료의 수를 늘려가며 필요한 내용을 공부해 본다.
// STACK - 1MB 지역변수, 인자전달
// DATA - 2GB 전역변수, BSS(초기화와 관련), 실행파일의 크기와 고날녀
//
// HEAP(Free Store) - 왜 쓰냐?
// CODE
//
//
//-----------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include <random>
#include "save.h"
using namespace std;

int main()
{
	new int; 
	
	save("소스.cpp");
}




-------------------------------------------
소스.cpp - 2020-10-12 오후 1:44:24 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.12       (6주 1일)
//
// 처리할 자료의 수를 늘려가며 필요한 내용을 공부해 본다.
// STACK - 1MB 지역변수, 인자전달
// DATA - 2GB 전역변수, BSS(초기화와 관련), 실행파일의 크기와 고날녀
//
// HEAP(Free Store) - 왜 쓰냐?
// CODE
//
//
//-----------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include <random>
#include "save.h"
using namespace std;

int n;				// DATA (BSS 초기화하지 않았으므로)

int main()
{
	int n;			// STACK

	new int;		// FreeStore
	malloc(sizeof(int)); // HEAP


	save("소스.cpp");
}




-------------------------------------------
소스.cpp - 2020-10-12 오후 1:59:44 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.12       (6주 1일)
//
// 처리할 자료의 수를 늘려가며 필요한 내용을 공부해 본다.
// STACK - 1MB 지역변수, 인자전달
// DATA - 2GB 전역변수, BSS(초기화와 관련), 실행파일의 크기와 고날녀
//
// HEAP(Free Store) - 왜 쓰냐?
// CODE
//
//
//-----------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include <random>
#include "save.h"
using namespace std;

// [문제] 메모리를 달라고 요청해 본다(500MB)
// 작업관리자로 확인해 보자. (실제 메모리를 줬는지)

int main()
{
	int* p = new int{ 1 };	// sizeof(int) 메모리를 주세요.

	cout << *p << endl;

	save("소스.cpp");
}




-------------------------------------------
소스.cpp - 2020-10-12 오후 2:08:26 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.12       (6주 1일)
//
// 처리할 자료의 수를 늘려가며 필요한 내용을 공부해 본다.
// STACK - 1MB 지역변수, 인자전달
// DATA - 2GB 전역변수, BSS(초기화와 관련), 실행파일의 크기와 고날녀
//
// HEAP(Free Store) - 왜 쓰냐?
// CODE
//
//
//-----------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include <random>
#include "save.h"
using namespace std;

// [문제] 메모리를 달라고 요청해 본다(500MB)
// 작업관리자로 확인해 보자. (실제 메모리를 줬는지)

int main()
{
	new char[500'000'000];

	cout << "키를 누르면 끝납니다 ";
	char ch;
	cin >> ch;

	save("소스.cpp");
}




-------------------------------------------
소스.cpp - 2020-10-12 오후 2:09:41 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.12       (6주 1일)
//
// 처리할 자료의 수를 늘려가며 필요한 내용을 공부해 본다.
// STACK - 1MB 지역변수, 인자전달
// DATA - 2GB 전역변수, BSS(초기화와 관련), 실행파일의 크기와 고날녀
//
// HEAP(Free Store) - 왜 쓰냐?
// CODE
//
//
//-----------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include <random>
#include "save.h"
using namespace std;

// [문제] 메모리를 달라고 요청해 본다(500MB)
// 작업관리자로 확인해 보자. (실제 메모리를 줬는지)

int main()
{
	char ch;
	cout << "키를 누르면 메모리를 요청합니다 ";
	cin >> ch;

	new char[500'000'000];

	cout << "키를 누르면 끝납니다 ";
	cin >> ch;

	save("소스.cpp");
}




-------------------------------------------
소스.cpp - 2020-10-12 오후 2:14:14 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.12       (6주 1일)
//
// 처리할 자료의 수를 늘려가며 필요한 내용을 공부해 본다.
// STACK - 1MB 지역변수, 인자전달
// DATA - 2GB 전역변수, BSS(초기화와 관련), 실행파일의 크기와 고날녀
//
// HEAP(Free Store) - 왜 쓰냐?
// CODE
//
//
//-----------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include <random>
#include "save.h"
using namespace std;

// [문제] 메모리를 달라고 요청해 본다(500MB)
// 작업관리자로 확인해 보자. (실제 메모리를 줬는지)

int main()
{
	char ch;
	cout << "키를 누르면 메모리를 요청합니다 ";
	cin >> ch;

	char* p = new char[500'000'000];

	cout << "키를 누르면 끝납니다 ";
	cin >> ch;

	save("소스.cpp");
}




-------------------------------------------
소스.cpp - 2020-10-12 오후 2:15:19 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.12       (6주 1일)
//
// 처리할 자료의 수를 늘려가며 필요한 내용을 공부해 본다.
// STACK - 1MB 지역변수, 인자전달
// DATA - 2GB 전역변수, BSS(초기화와 관련), 실행파일의 크기와 고날녀
//
// HEAP(Free Store) - 왜 쓰냐?
// CODE
//
//
//-----------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include <random>
#include "save.h"
using namespace std;

// [문제] 메모리를 달라고 요청해 본다(500MB)
// 작업관리자로 확인해 보자. (실제 메모리를 줬는지)

int main()
{
	char ch;
	cout << "키를 누르면 메모리를 요청합니다 ";
	cin >> ch;

	char* p = new char[500'000'000];
	p[0] = 'a';
	p[499'999'999] = 'x';
	cout << p[0] << p[499'999'999] << endl;

	cout << "키를 누르면 끝납니다 ";
	cin >> ch;

	save("소스.cpp");
}




-------------------------------------------
소스.cpp - 2020-10-12 오후 2:16:58 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.12       (6주 1일)
//
// 처리할 자료의 수를 늘려가며 필요한 내용을 공부해 본다.
// STACK - 1MB 지역변수, 인자전달
// DATA - 2GB 전역변수, BSS(초기화와 관련), 실행파일의 크기와 고날녀
//
// HEAP(Free Store) - 왜 쓰냐?
// CODE
//
//
//-----------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include <random>
#include "save.h"
using namespace std;

// [문제] 메모리를 달라고 요청해 본다(500MB)
// 작업관리자로 확인해 보자. (실제 메모리를 줬는지)

int main()
{
	char ch;
	cout << "키를 누르면 메모리를 요청합니다 ";
	cin >> ch;

	char* p = new char[500'000'000];
	for (int i = 0; i < 500'000'000; ++i)
		p[i] = i;

	cout << "키를 누르면 끝납니다 ";
	cin >> ch;

	save("소스.cpp");
}




-------------------------------------------
소스.cpp - 2020-10-12 오후 2:39:18 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.12       (6주 1일)
//
// 처리할 자료의 수를 늘려가며 필요한 내용을 공부해 본다.
// STACK - 1MB 지역변수, 인자전달
// DATA - 2GB 전역변수, BSS(초기화와 관련), 실행파일의 크기와 고날녀
//
// HEAP(Free Store) - 왜 쓰냐?
// CODE
//
//
//-----------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include <random>
#include "save.h"
using namespace std;

// [문제] 메모리를 계속 달라고 요청해 본다.
// 얼마까지 줄 수 있는지 확인한다. (실제 메모리를 줬는지)

int main()
{
	int sum{};
	const int SIZE = 100'000'000;

	while (true) {
		try {	// 예외처리
			new char[SIZE]{ };
		}
		catch ( exception& e ) {
			cout << "메모리 할당 실패" << endl;
			break;
		}
		sum += SIZE;
	}

	cout << "모두 " << sum << "까지 할당 성공" << endl;

	save("소스.cpp");
}




-------------------------------------------
소스.cpp - 2020-10-12 오후 2:39:36 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.12       (6주 1일)
//
// 처리할 자료의 수를 늘려가며 필요한 내용을 공부해 본다.
// STACK - 1MB 지역변수, 인자전달
// DATA - 2GB 전역변수, BSS(초기화와 관련), 실행파일의 크기와 고날녀
//
// HEAP(Free Store) - 왜 쓰냐?
// CODE
//
//
//-----------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include <random>
#include "save.h"
using namespace std;

// [문제] 메모리를 계속 달라고 요청해 본다.
// 얼마까지 줄 수 있는지 확인한다. (실제 메모리를 줬는지)

int main()
{
	int sum{};
	const int SIZE = 100'000;

	while (true) {
		try {	// 예외처리
			new char[SIZE]{ };
		}
		catch ( exception& e ) {
			cout << "메모리 할당 실패" << endl;
			break;
		}
		sum += SIZE;
	}

	cout << "모두 " << sum << "까지 할당 성공" << endl;

	save("소스.cpp");
}




-------------------------------------------
소스.cpp - 2020-10-12 오후 2:52:55 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.12       (6주 1일)
//
// 처리할 자료의 수를 늘려가며 필요한 내용을 공부해 본다.
// STACK - 1MB 지역변수, 인자전달
// DATA - 2GB 전역변수, BSS(초기화와 관련), 실행파일의 크기와 관련
//
// HEAP(Free Store) - 책 223쪽, 2GB 사용가능한데
//			필요한 시점에 필요한 크기만큼 사용할 수 있다.
//
// CODE
//-----------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

// [문제] 메모리를 계속 달라고 요청해 본다.
// 얼마까지 줄 수 있는지 확인한다. (실제 메모리를 줬는지)

int main()
{
	save("소스.cpp");
}




-------------------------------------------
소스.cpp - 2020-10-12 오후 2:58:26 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.12       (6주 1일)
//
//-----------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <random>
#include "save.h"
using namespace std;

// [문제] 파일에 "정수 1억개.txt"가 저장되어 있다.
// 읽어서 오름차순으로 정렬한 후
// "정수 1억개 오름차순정렬.txt"로 저장하라.
void makeData();

int main()
{
	makeData();		// 정수를 파일에 저장한다

	save("소스.cpp");
}

void makeData()
{
	ofstream out("정수 1억개.txt");

	default_random_engine dre;
	uniform_int_distribution<> uid;

	for (int i = 0; i < 100; ++i)
		cout << uid(dre);
}




-------------------------------------------
소스.cpp - 2020-10-12 오후 2:58:37 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.12       (6주 1일)
//
//-----------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <random>
#include "save.h"
using namespace std;

// [문제] 파일에 "정수 1억개.txt"가 저장되어 있다.
// 읽어서 오름차순으로 정렬한 후
// "정수 1억개 오름차순정렬.txt"로 저장하라.
void makeData();

int main()
{
	makeData();		// 정수를 파일에 저장한다

	save("소스.cpp");
}

void makeData()
{
	ofstream out("정수 1억개.txt");

	default_random_engine dre;
	uniform_int_distribution<> uid;

	for (int i = 0; i < 100; ++i)
		cout << uid(dre) << " ";
}




-------------------------------------------
소스.cpp - 2020-10-12 오후 2:59:53 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.12       (6주 1일)
//
//-----------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <random>
#include "save.h"
using namespace std;

// [문제] 파일에 "정수 1억개.txt"가 저장되어 있다.
// 읽어서 오름차순으로 정렬한 후
// "정수 1억개 오름차순정렬.txt"로 저장하라.
void makeData();

int main()
{
	makeData();		// 정수를 파일에 저장한다

	save("소스.cpp");
}

void makeData()
{
	ofstream out("정수 1억개.txt");

	default_random_engine dre;
	uniform_int_distribution<> uid;

	for (int i = 0; i < 100; ++i)
		out << uid(dre) << " ";
}




-------------------------------------------
소스.cpp - 2020-10-12 오후 3:02:56 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.12       (6주 1일)
//
//-----------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <random>
#include "save.h"
using namespace std;

// [문제] 파일에 "정수 1억개.txt"가 저장되어 있다.
// 읽어서 오름차순으로 정렬한 후
// "정수 1억개 오름차순정렬.txt"로 저장하라.
//void makeData();

int main()
{
	//makeData();		// 정수를 파일에 저장한다
	ifstream in("정수 1억개.txt");

	int num;
	while (in >> num) {
		cout << num << endl;
	}


	save("소스.cpp");
}

//void makeData()
//{
//	ofstream out("정수 1억개.txt");
//
//	default_random_engine dre;
//	uniform_int_distribution<> uid;
//
//	for (int i = 0; i < 100; ++i)
//		out << uid(dre) << " ";
//}
//



-------------------------------------------
소스.cpp - 2020-10-12 오후 3:06:31 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.12       (6주 1일)
//
//-----------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <random>
#include "save.h"
using namespace std;

// [문제] 파일에 "정수 1억개.txt"가 저장되어 있다.
// 읽어서 오름차순으로 정렬한 후
// "정수 1억개 오름차순정렬.txt"로 저장하라.
void makeData();

int main()
{
	makeData();		// 정수를 파일에 저장한다

	save("소스.cpp");
}

void makeData()
{
	ofstream out("정수 1억개.txt");

	default_random_engine dre;
	uniform_int_distribution<> uid;

	for (int i = 0; i < 100'000'000; ++i)
		out << uid(dre) << " ";
}




-------------------------------------------
소스.cpp - 2020-10-12 오후 3:08:14 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.12       (6주 1일)
//
//-----------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <random>
#include "save.h"
using namespace std;

// [문제] 파일에 "정수 1억개.txt"가 저장되어 있다.
// 읽어서 오름차순으로 정렬한 후
// "정수 1억개 오름차순정렬.txt"로 저장하라.
void makeData();

int main()
{
	makeData();		// 정수를 파일에 저장한다

	save("소스.cpp");
}

void makeData()
{
	ofstream out("정수 1억개.txt");

	default_random_engine dre;
	uniform_int_distribution<> uid;

	for (int i = 0; i < 100'000'000; ++i)
		out << uid(dre) << " ";
}




-------------------------------------------
소스.cpp - 2020-10-12 오후 3:11:07 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.12       (6주 1일)
//
//-----------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <random>
#include "save.h"
using namespace std;

// [문제] 파일에 "정수 1억개.txt"가 저장되어 있다.
// 읽어서 오름차순으로 정렬한 후
// "정수 1억개 오름차순정렬.txt"로 저장하라.
void makeData();

int main()
{
	makeData();
	//ifstream in("정수 1억개.txt");
	//ofstream out("정수 1억개 오름차순정렬.txt");

	//int num;
	//int* p = new int[1'000];

	//for (int i = 0;)




	save("소스.cpp");
}

void makeData()
{
	ofstream out("정수 1억개.txt");

	default_random_engine dre;
	uniform_int_distribution<> uid;

	for (int i = 0; i < 1'000; ++i)
		out << uid(dre) << " ";
}




-------------------------------------------
소스.cpp - 2020-10-12 오후 3:24:03 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.12       (6주 1일)
//
//-----------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <random>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] 파일에 "정수 1억개.txt"가 저장되어 있다.
// 읽어서 오름차순으로 정렬한 후
// "정수 1억개 오름차순정렬.txt"로 저장하라.
void makeData();

int p[100'000'000];

int main()
{

	ifstream in("정수 1억개.txt");
	ofstream out("정수 1억개 오름차순정렬.txt");

	for (int i = 0; i < 100'000'000; ++i) 
		in >> p[i];

	sort(begin(p), end(p));

	for (int i = 0; i < 100'000'000; ++i)
		out << p[i] << " ";



	save("소스.cpp");
}

void makeData()
{
	ofstream out("정수 1억개.txt");

	default_random_engine dre;
	uniform_int_distribution<> uid;

	for (int i = 0; i < 100'000'000; ++i)
		out << uid(dre) << " ";
}




-------------------------------------------
소스.cpp - 2020-10-14 오전 11:59:14 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.14       (6주 2일)
//
// 사용자 정의 자료형
//-----------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <random>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] 파일에 "정수 1억개.txt"가 저장되어 있다.
// 읽어서 오름차순으로 정렬한 후
// "정수 1억개 오름차순정렬.txt"로 저장하라.

int arr[100'000'000];		// 400MB

int main()
{

	ifstream in("정수 1억개.txt");
	ofstream out("정수 1억개 오름차순정렬.txt");

	int num;
	int cnt{ 0 };

	cout << "읽는 중";
	while (in >> num) {
		arr[cnt++] = num;
		if (!(cnt % 1'000'000))
			cout << ".";
	}
	cout << endl;
	cout << "모두 " << cnt << "개의 정수를 읽었습니다" << endl;

	cout << "정렬하는 중" << endl;

	cnt = 0;
	sort(begin(arr), end(arr), [&cnt](int a, int b) {
		if (!(++cnt % 1'000'000))
			cout << ".";
		return a < b;
		});

	cout << endl;

	// 앞에서 부터 100개만 출력
	for (int i = 0; i < 100; ++i)
		cout << arr[i] << endl;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-14 오후 12:07:21 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.14       (6주 2일)
//
// 사용자 정의 자료형
//-----------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <random>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] 파일에 "정수 1억개.txt"가 저장되어 있다.
// 읽어서 오름차순으로 정렬한 후
// "정수 1억개 오름차순정렬.txt"로 저장하라.

int arr[100'000'000];		// 400MB

int main()
{
	{
		ifstream in("정수 1억개.txt");

		int num;
		int cnt{ 0 };

		cout << "읽는 중";
		while (in >> num) {
			arr[cnt++] = num;
			if (!(cnt % 1'000'000))
				cout << ".";
		}
		cout << endl;
		cout << "모두 " << cnt << "개의 정수를 읽었습니다" << endl;

		cout << "정렬하는 중" << endl;

		cnt = 0;
		sort(begin(arr), end(arr), [&cnt](int a, int b) {
			if (!(++cnt % 1'000'000))
				cout << ".";
			return a < b;
			});

		cout << endl;
	}
	// 전체를 파일에 기록
	ofstream out { "정수 1억개 오름차순정렬.txt"s };

	cout << "기록하는중" << endl;
	for (int n : arr)
		out << n << " ";


	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-14 오후 12:43:00 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.14       (6주 2일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
//-----------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Person {
	int age;
	string name;
};

int main()
{
	Person p;
	
	cout << sizeof(p) << endl;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-14 오후 12:44:21 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.14       (6주 2일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
//-----------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Person {
	int age;
	string name;
};

int main()
{
	Person p;
	
	cout << sizeof(Person) << endl;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-14 오후 12:46:18 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.14       (6주 2일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
//-----------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Person {
	char age;
	string name;
};

int main()
{
	Person p;
	
	cout << sizeof(Person) << endl;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-14 오후 12:46:51 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.14       (6주 2일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
//-----------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Person {
	char age;
	string name;
};

int main()
{
	Person p;
	
	cout << sizeof(Person) << endl;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-14 오후 12:54:15 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.14       (6주 2일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
//-----------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct alignas(32) Person {
	char age;
	string name;
};

int main()
{
	Person p;
	
	cout << sizeof(Person) << endl;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-14 오후 1:03:46 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.14       (6주 2일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
//-----------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// 필드가 100 x 100 크기이다.
// 여기에 공 100개가 임의의 위치에 놓여있다.
// 위치 (50, 50)에 폭탄이 설치되어 있다.
// 키를 누르면 폭탄이 폭발하여 반경 20이내의 공은 터진다.
// 터진 공을 화면에 출력하라.



int main()
{
	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-14 오후 1:16:14 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.14       (6주 2일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
//-----------------------------------------------------------------------------

#include <iostream>
#include <random>
#include "save.h"
using namespace std;

// 필드가 100 x 100 크기이다.
// 여기에 공 100개가 임의의 위치에 놓여있다.
// 위치 (50, 50)에 폭탄이 설치되어 있다.
// 키를 누르면 폭탄이 폭발하여 반경 20이내의 공은 터진다.
// 터진 공을 화면에 출력하라.

default_random_engine dre;
uniform_int_distribution<> uid{ 0, 100 };

struct Ball {
	float x{ 0.0f };
	float y{ 0.0f };
};

int main()
{
	Ball balls[100];

	for ( Ball& ball : balls ) {
		ball.x = uid(dre);
		ball.y = uid(dre);
	}

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-19 오후 1:56:14 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.19       (7주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include <random>
#include "save.h"
using namespace std;

// 필드가 100 x 100 크기이다.
// 여기에 공 100개가 임의의 위치에 놓여있다.
// 위치 (50, 50)에 폭탄이 설치되어 있다.
// 키를 누르면 폭탄이 폭발하여 반경 20이내의 공은 터진다.
// 터진 공을 화면에 출력하라.

default_random_engine dre;

struct Ball {
	float x{ 0.0f };
	float y{ 0.0f };
};

struct Bomb {
	float x{ 50 };
	float y{ 50 };
};

int main()
{
	Ball balls[100];

	uniform_int_distribution<> uid{ 0, 100 };

	for ( Ball& ball : balls ) {
		ball.x = uid(dre);
		ball.y = uid(dre);
	}

	//폭탄을 생성했다
	Bomb bomb;

	int cnt{};
	// 폭탄과의 거리가 20이하인 공을 화면에 출력한다.
	for ( Ball ball : balls ) {
		float dx = ball.x - bomb.x;
		float dy = ball.y - bomb.y;
		if (sqrt(dx * dx + dy * dy) <= 20.0) {
			cout << "거리가 20 이하인 공 " << "(" << ball.x << ", " << ball.y << ")" << endl;
			++cnt;
		}
	}

	cout << "20이하인 공의 갯수 - " << cnt << endl;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-19 오후 1:57:49 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.19       (7주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include <random>
#include "save.h"
using namespace std;

// 필드가 100 x 100 크기이다.
// 여기에 공 100개가 임의의 위치에 놓여있다.
// 위치 (50, 50)에 폭탄이 설치되어 있다.
// 키를 누르면 폭탄이 폭발하여 반경 20이내의 공은 터진다.
// 터진 공을 화면에 출력하라.

default_random_engine dre;

struct Ball {
	float x{ 0.0f };
	float y{ 0.0f };
};

struct Bomb {
	float x{ 50 };
	float y{ 50 };
};

int main()
{
	Ball balls[1000];

	uniform_int_distribution<> uid{ 0, 100 };

	for ( Ball& ball : balls ) {
		ball.x = uid(dre);
		ball.y = uid(dre);
	}

	//폭탄을 생성했다
	Bomb bomb;

	int cnt{};
	// 폭탄과의 거리가 20이하인 공을 화면에 출력한다.
	for ( Ball ball : balls ) {
		float dx = ball.x - bomb.x;
		float dy = ball.y - bomb.y;
		if (sqrt(dx * dx + dy * dy) <= 20.0) {
			cout << "거리가 20 이하인 공 " << "(" << ball.x << ", " << ball.y << ")" << endl;
			++cnt;
		}
	}

	cout << "20이하인 공의 갯수 - " << cnt << endl;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-19 오후 2:01:53 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.19       (7주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include <random>
#include "save.h"
using namespace std;

// 필드가 100 x 100 크기이다.
// 여기에 공 100개가 임의의 위치에 놓여있다.
// 위치 (50, 50)에 폭탄이 설치되어 있다.
// 키를 누르면 폭탄이 폭발하여 반경 20이내의 공은 터진다.
// 터진 공을 화면에 출력하라.

default_random_engine dre;
uniform_int_distribution<> uid{ 0, 100 };

struct Ball {
	float x{ 0.0f };
	float y{ 0.0f };

	Ball() {		// 생성자
		x = uid(dre);
		y = uid(dre);
	}

};

struct Bomb {
	float x{ 50 };
	float y{ 50 };
};

int main()
{
	Ball balls[100];

	//폭탄을 생성했다
	Bomb bomb;

	int cnt{};
	// 폭탄과의 거리가 20이하인 공을 화면에 출력한다.
	for ( Ball ball : balls ) {
		float dx = ball.x - bomb.x;
		float dy = ball.y - bomb.y;
		if (sqrt(dx * dx + dy * dy) <= 20.0) {
			cout << "거리가 20 이하인 공 " << "(" << ball.x << ", " << ball.y << ")" << endl;
			++cnt;
		}
	}

	cout << "20이하인 공의 갯수 - " << cnt << endl;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-19 오후 2:03:00 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.19       (7주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include <random>
#include "save.h"
using namespace std;

// 필드가 100 x 100 크기이다.
// 여기에 공 100개가 임의의 위치에 놓여있다.
// 위치 (50, 50)에 폭탄이 설치되어 있다.
// 키를 누르면 폭탄이 폭발하여 반경 20이내의 공은 터진다.
// 터진 공을 화면에 출력하라.

default_random_engine dre;
uniform_int_distribution<> uid{ 0, 100 };

struct Ball {
	float x{ 0.0f };
	float y{ 0.0f };

	Ball() {		// 생성자
		x = uid(dre);
		y = uid(dre);
	}

};

struct Bomb {
	float x{ 50 };
	float y{ 50 };
};

int main()
{
	Ball balls[100];

	//폭탄을 생성했다
	Bomb bomb;

	for ( Ball ball : balls )
		cout << "거리가 20 이하인 공 " << "(" << ball.x << ", " << ball.y << ")" << endl;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-19 오후 2:03:17 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.19       (7주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include <random>
#include "save.h"
using namespace std;

// 필드가 100 x 100 크기이다.
// 여기에 공 100개가 임의의 위치에 놓여있다.
// 위치 (50, 50)에 폭탄이 설치되어 있다.
// 키를 누르면 폭탄이 폭발하여 반경 20이내의 공은 터진다.
// 터진 공을 화면에 출력하라.

default_random_engine dre;
uniform_int_distribution<> uid{ 0, 100 };

struct Ball {
	float x{ 0.0f };
	float y{ 0.0f };

	Ball() {		// 생성자
		x = uid(dre);
		y = uid(dre);
	}

};

struct Bomb {
	float x{ 50 };
	float y{ 50 };
};

int main()
{
	Ball balls[100];

	//폭탄을 생성했다
	Bomb bomb;

	for ( Ball ball : balls )
		cout << "(" << ball.x << ", " << ball.y << ")" << endl;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-19 오후 2:04:43 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.19       (7주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include <random>
#include "save.h"
using namespace std;

// 필드가 100 x 100 크기이다.
// 여기에 공 100개가 임의의 위치에 놓여있다.
// 위치 (50, 50)에 폭탄이 설치되어 있다.
// 키를 누르면 폭탄이 폭발하여 반경 20이내의 공은 터진다.
// 터진 공을 화면에 출력하라.

default_random_engine dre;
uniform_int_distribution<> uid{ 0, 100 };

struct Ball {
	float x = uid(dre);
	float y = uid(dre);
};

int main()
{
	Ball balls[100];

	for ( Ball ball : balls )
		cout << "(" << ball.x << ", " << ball.y << ")" << endl;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-19 오후 2:12:04 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.19       (7주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include <random>
#include "save.h"
using namespace std;

// 필드가 100 x 100 크기이다.
// 여기에 공 100개가 임의의 위치에 놓여있다.
// 위치 (50, 50)에 폭탄이 설치되어 있다.
// 키를 누르면 폭탄이 폭발하여 반경 20이내의 공은 터진다.
// 터진 공을 화면에 출력하라.

default_random_engine dre;
uniform_int_distribution<> uid{ 0, 100 };

struct Ball {
	float x = uid(dre);
	float y = uid(dre);
};

int main()
{
	Ball balls[100];

	// balls를 x좌표 오름차순으로 정렬하라
	sort(begin(balls), end(balls), [](Ball ball1, Ball ball2) {
		return ball1.x < ball2.x;
		});

	for ( Ball ball : balls )
		cout << "(" << ball.x << ", " << ball.y << ")" << endl;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-19 오후 2:20:12 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.19       (7주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include <random>
#include "save.h"
using namespace std;

// 필드가 100 x 100 크기이다.
// 여기에 공 100개가 임의의 위치에 놓여있다.
// 위치 (50, 50)에 폭탄이 설치되어 있다.
// 키를 누르면 폭탄이 폭발하여 반경 20이내의 공은 터진다.
// 터진 공을 화면에 출력하라.

default_random_engine dre;
uniform_int_distribution<> uid{ 0, 100 };

struct Ball {
	float x = uid(dre);
	float y = uid(dre);
};

int main()
{
	Ball balls[100];

	// balls를 x좌표 오름차순으로 정렬하라
	sort(begin(balls), end(balls), [](const Ball& ball1, const Ball& ball2) {
		return ball1.x < ball2.x;
		});

	for ( Ball ball : balls )
		cout << "(" << ball.x << ", " << ball.y << ")" << endl;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-19 오후 2:35:00 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.19       (7주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include <random>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<> uid{ 0, 100 };

struct Ball {
	float x = uid(dre);
	float y = uid(dre);
};

int main()
{
	Ball* balls = new Ball [100];

	// balls를 x좌표 오름차순으로 정렬하라
	sort( balls, balls + 100, [](const Ball& ball1, const Ball& ball2) {
		return ball1.x < ball2.x;
		});

	for ( int i = 0; i < 100; ++i )
		cout << "(" << balls[i].x << ", " << balls[i].y << ")" << endl;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-19 오후 2:47:28 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.19       (7주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include <random>
#include "save.h"
using namespace std;

struct Dog {
	int age;
	string name;
};

int main()
{
	Dog dog;	// 메모리에 객체를 생성 (instancing)

	// dog의 이름을 "댕댕이", 나이를 1살로 만들어라.
	// dog의 이름과 나이를 출력하라

	dog = { 1, "댕댕이" };
	cout << dog.name << " - " << dog.age << endl;
	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-19 오후 2:48:21 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.19       (7주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include <random>
#include "save.h"
using namespace std;

struct Dog {
	int age;
	string name;
};

int main()
{
	Dog dog;	// 메모리에 객체를 생성 (instancing)

	// dog의 이름을 "댕댕이", 나이를 1살로 만들어라.
	// dog의 이름과 나이를 출력하라

	dog = { 1, "댕댕이" };
	cout << dog.name << " - " << dog.age << endl;
	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-19 오후 2:49:03 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.19       (7주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include <random>
#include "save.h"
using namespace std;

struct Dog {
	int age;
	string name;
};

int main()
{
	Dog dog;	// 메모리에 객체를 생성 (instancing)

	// dog의 이름을 "댕댕이", 나이를 1살로 만들어라.
	// dog의 이름과 나이를 출력하라

	dog.name = "댕댕이";
	dog.age = 1;
	//dog = { 1, "댕댕이" };
	cout << dog.name << " - " << dog.age << endl;
	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-19 오후 2:53:12 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.19       (7주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include <random>
#include <string>
#include "save.h"
using namespace std;

struct Dog {
	int age;
	string name;
};

int main()
{
	Dog dog{ 1, "댕댕이" };	// 메모리에 객체를 생성 (instancing)

	// dog의 이름을 "댕댕이", 나이를 1살로 만들어라.
	// dog의 이름과 나이를 출력하라

	cout << dog.name << " - " << dog.age << endl;
	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-19 오후 3:04:29 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.19       (7주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include <random>
#include <string>
#include "save.h"
using namespace std;

struct Dog {
	int age;
	string name;

	// 객체가 생성될 때 멤버를 초기화할 수 있다.
	// - 객체가 생성되면 반드시 생성자 함수를 호출한다.

	Dog() {
		age = 1;
		name = "댕댕이";
		cout << "생성자가 호출되었네!" << endl;
	}
};

int main()
{
	Dog dog;	// 생성자 - 객체를 생성 후 함수를 호출한다. Dog() 호출
	
	cout << dog.name << " - " << dog.age << endl;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-19 오후 3:08:40 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.19       (7주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include <random>
#include <string>
#include "save.h"
using namespace std;

struct Dog {
	int age;
	string name;

	// 객체가 생성될 때 멤버를 초기화할 수 있다.
	// - 객체가 생성되면 반드시 생성자 함수를 호출한다.

	Dog() {			// 디폴트 생성자
		age = 1;
		name = "댕댕이";
		cout << "생성자가 호출되었네!" << endl;
	}

	Dog(string name, int age) : name{ name }, age{ age } {
		cout << name << "과 " << age << "로 생성" << endl;
	}
};

int main()
{
	Dog dog{ "댕댕이", 1 }; // Dog("댕댕이", 1)


	// 생성자 - 객체를 생성 후 함수를 호출한다. Dog() 호출
	
	cout << dog.name << " - " << dog.age << endl;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-19 오후 3:09:14 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.19       (7주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include <random>
#include <string>
#include "save.h"
using namespace std;

struct Dog {
	int age;
	string name;

	// 객체가 생성될 때 멤버를 초기화할 수 있다.
	// - 객체가 생성되면 반드시 생성자 함수를 호출한다.

	Dog() {			// 디폴트 생성자
		age = 1;
		name = "댕댕이";
		cout << "생성자가 호출되었네!" << endl;
	}

	Dog(string name, int age) : name{ name }, age{ age } {
		cout << name << "과 " << age << "로 생성" << endl;
	}
};

int main()
{
	Dog dog{ "댕댕이", 1 };

	Dog anotherDog;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-19 오후 3:09:31 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.19       (7주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include <random>
#include <string>
#include "save.h"
using namespace std;

struct Dog {
	int age;
	string name;

	// 객체가 생성될 때 멤버를 초기화할 수 있다.
	// - 객체가 생성되면 반드시 생성자 함수를 호출한다.

	Dog() {			// 디폴트 생성자
		age = 1;
		name = "댕댕이";
		cout << "생성자가 호출되었네!" << endl;
	}

	Dog(string name, int age) : name{ name }, age{ age } {
		cout << name << "과 " << age << "로 생성" << endl;
	}
};

int main()
{
	Dog dog{ "댕댕이", 1 };

	Dog anotherDog{ "쵸코", 3 };

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-19 오후 3:10:17 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.19       (7주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include <random>
#include <string>
#include "save.h"
using namespace std;

struct Dog {
	int age;
	string name;

	// 객체가 생성될 때 멤버를 초기화할 수 있다.
	// - 객체가 생성되면 반드시 생성자 함수를 호출한다.

	Dog() {			// 디폴트 생성자
		age = 1;
		name = "댕댕이";
		cout << "생성자가 호출되었네!" << endl;
	}

	Dog(string name, int age) : name{ name }, age{ age } {
		cout << name << "과 " << age << "로 생성" << endl;
	}
};

int main()
{
	Dog dogs[3];
	Dog dog{ "댕댕이", 1 };
	Dog anotherDog;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-19 오후 3:12:31 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.19       (7주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include <random>
#include <string>
#include "save.h"
using namespace std;

struct Dog {
	int age;
	string name;

	// 객체가 생성될 때 멤버를 초기화할 수 있다.
	// - 객체가 생성되면 반드시 생성자 함수를 호출한다.

	Dog() {			// 디폴트 생성자
		age = 1;
		name = "댕댕이";
		cout << "생성자가 호출되었네!" << endl;
	}

	Dog(string name, int age) : name{ name }, age{ age } {
		cout << name << "과 " << age << "로 생성" << endl;
	}
};

int main()
{
	Dog dogs[3]{ { "1호", 1 }, { "2호", 2 } };

	for (Dog dog : dogs)
		cout << dog.name << ", " << dog.age << endl;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-19 오후 3:18:14 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.19       (7주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include <random>
#include <string>
#include "save.h"
using namespace std;

struct Dog {
	int age;
	string name;

	// 객체가 생성될 때 멤버를 초기화할 수 있다.
	// - 객체가 생성되면 반드시 생성자 함수를 호출한다.

	Dog() {			// 디폴트 생성자
		age = 1;
		name = "댕댕이";
		cout << "생성자가 호출되었네!" << endl;
	}

	Dog(string name, int age) : name{ name }, age{ age } {
		cout << name << "과 " << age << "로 생성" << endl;
	}
	void show() {
		cout << name << ", " << age << endl;
	}
};

int main()
{
	Dog dogs[3]{ { "1호", 1 }, { "2호", 2 } };

	for (Dog dog : dogs)
		dog.show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-19 오후 3:19:48 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.19       (7주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include <random>
#include <string>
#include "save.h"
using namespace std;

struct Dog {
	int age;
	string name;

	// 객체가 생성될 때 멤버를 초기화할 수 있다.
	// - 객체가 생성되면 반드시 생성자 함수를 호출한다.

	Dog() {			// 디폴트 생성자
		age = 1;
		name = "댕댕이";
		cout << "생성자가 호출되었네!" << endl;
	}

	Dog(string name, int age) : name{ name }, age{ age } {
		cout << name << "과 " << age << "로 생성" << endl;
	}

	~Dog() {
		cout << "소멸될때 호출됨" << endl;
	}


	void show() {
		cout << name << ", " << age << endl;
	}
};

int main()
{
	Dog dogs[3]{ { "1호", 1 }, { "2호", 2 } };

	for (Dog dog : dogs)
		dog.show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-19 오후 3:20:08 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.19       (7주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include <random>
#include <string>
#include "save.h"
using namespace std;

struct Dog {
	int age;
	string name;

	// 객체가 생성될 때 멤버를 초기화할 수 있다.
	// - 객체가 생성되면 반드시 생성자 함수를 호출한다.

	Dog() {			// 디폴트 생성자
		age = 1;
		name = "댕댕이";
		cout << "생성자가 호출되었네!" << endl;
	}

	Dog(string name, int age) : name{ name }, age{ age } {
		cout << name << "과 " << age << "로 생성" << endl;
	}

	~Dog() {
		cout << "소멸될때 호출됨" << endl;
	}


	void show() {
		cout << name << ", " << age << endl;
	}
};

int main()
{
	Dog dog;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-19 오후 3:20:36 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.19       (7주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include <random>
#include <string>
#include "save.h"
using namespace std;

struct Dog {
	int age;
	string name;

	// 객체가 생성될 때 멤버를 초기화할 수 있다.
	// - 객체가 생성되면 반드시 생성자 함수를 호출한다.

	Dog() {			// 디폴트 생성자
		age = 1;
		name = "댕댕이";
		cout << "생성자가 호출되었네!" << endl;
	}

	Dog(string name, int age) : name{ name }, age{ age } {
		cout << name << "과 " << age << "로 생성" << endl;
	}

	~Dog() {
		cout << "소멸될때 호출됨" << endl;
	}


	void show() {
		cout << name << ", " << age << endl;
	}
};

int main()
{
	{
		Dog dog;
	}
	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-21 오전 11:39:15 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.21       (7주 2일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include <random>
#include <string>
#include "save.h"
using namespace std;

struct Dog {
	int age;
	string name;

	// 객체가 생성될 때 멤버를 초기화할 수 있다.
	// - 객체가 생성되면 반드시 생성자 함수를 호출한다.

	Dog() {			// 디폴트 생성자
		age = 1;
		name = "댕댕이";
		cout << "생성자가 호출되었네!" << endl;
	}

	Dog(string name, int age) : name{ name }, age{ age } {
		cout << name << "과 " << age << "로 생성" << endl;
	}

	~Dog() {
		cout << "소멸될때 호출됨" << endl;
	}


	void show() {
		cout << name << ", " << age << endl;
	}
};

int main()
{
	{
		Dog dog;
	}
	cout << sizeof(Dog);
	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-21 오전 11:43:18 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.21       (7주 2일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include <random>
#include <string>
#include "save.h"
using namespace std;

struct Dog {
	int age;		// 4
	string name;	// 24

	// 객체가 생성될 때 멤버를 초기화할 수 있다.
	// - 객체가 생성되면 반드시 생성자 함수를 호출한다.

	Dog() {			// 디폴트 생성자
		age = 1;
		name = "댕댕이";
		cout << "생성자가 호출되었네!" << endl;
	}

	Dog(string name, int age) : name{ name }, age{ age } {
		cout << name << "과 " << age << "로 생성" << endl;
	}

	~Dog() {
		cout << "소멸될때 호출됨" << endl;
	}


	void show() {
		cout << name << ", " << age << endl;
	}
};

int main()
{
	Dog dog;		// 28
	
	// 메모리를 확보한 후 메모리를 초기화할 기회가 있다.
	// 생성자라고 부르는 함수에서 이런 일을 할 수 있다.

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-21 오전 11:52:15 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.21       (7주 2일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include <string>
#include "save.h"
using namespace std;

struct Dog {
	int age;
	string name;

	Dog(int age, string name) : age{ age }, name{ name } {
		cout << "객체가 생성되었습니다." << endl;
	}
	~Dog() {
		cout << "객체가 소멸되었습니다." << endl;
	}

	void show() {
		cout << "나이 " << age << " - " << "이름 " << name << endl;
	}
};

// [문제] Dog 객체 한 개를 STACK(Free Store)에 생성하라.
// 객체가 생성되고 소멸되는 순간을 화면 출력으로 관찰하라.
// 객체의 나이와 이름을 인자로 받아 생성하도록 하자.
// Dog의 show member 함수를 만들어 정보를 출력해보자.

int main()
{
	Dog dog(1, "댕댕이");
	dog.show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-21 오전 11:52:38 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.21       (7주 2일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include <string>
#include "save.h"
using namespace std;

struct Dog {
	int age;
	string name;

	Dog(int age, string name) : age{ age }, name{ name } {
		cout << "객체가 생성되었습니다." << endl;
	}
	~Dog() {
		cout << "객체가 소멸되었습니다." << endl;
	}

	void show() {
		cout << "나이 - " << age << ", " << "이름 - " << name << endl;
	}
};

// [문제] Dog 객체 한 개를 STACK(Free Store)에 생성하라.
// 객체가 생성되고 소멸되는 순간을 화면 출력으로 관찰하라.
// 객체의 나이와 이름을 인자로 받아 생성하도록 하자.
// Dog의 show member 함수를 만들어 정보를 출력해보자.

int main()
{
	Dog dog(1, "댕댕이");
	dog.show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-21 오후 12:06:13 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.21       (7주 2일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include <string>
#include "save.h"
using namespace std;

struct Dog {
	int age;
	string name;


	Dog(int age, string name) : age{ age }, name{ name } {
		cout << age << ", " << name << " - ctor" << endl;
	}
	~Dog() {
		cout << age << ", " << name << " - dtor" << endl;
	}

	void show() {
		cout << "나이 - " << age << ", " << "이름 - " << name << endl;
	}
};

// [문제] Dog 객체 한 개를 STACK(Free Store)에 생성하라.
// 객체가 생성되고 소멸되는 순간을 화면 출력으로 관찰하라.
// 객체의 나이와 이름을 인자로 받아 생성하도록 하자.
// Dog의 show member 함수를 만들어 정보를 출력해보자.

int main()
{
	Dog* dog = new Dog(2, "쵸코");
	//Dog dog(1, "댕댕이");
	
	dog->show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-21 오후 12:06:53 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.21       (7주 2일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include <string>
#include "save.h"
using namespace std;

struct Dog {
	int age;
	string name;


	Dog(int age, string name) : age{ age }, name{ name } {
		cout << age << ", " << name << " - ctor" << endl;
	}
	~Dog() {
		cout << age << ", " << name << " - dtor" << endl;
	}

	void show() {
		cout << "나이 - " << age << ", " << "이름 - " << name << endl;
	}
};

// [문제] Dog 객체 한 개를 STACK(Free Store)에 생성하라.
// 객체가 생성되고 소멸되는 순간을 화면 출력으로 관찰하라.
// 객체의 나이와 이름을 인자로 받아 생성하도록 하자.
// Dog의 show member 함수를 만들어 정보를 출력해보자.

int main()
{
	Dog* dog = new Dog(2, "쵸코");
	//Dog dog(1, "댕댕이");
	
	dog->show();
	delete dog;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-21 오후 12:52:48 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.21       (7주 2일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Dog {
	int age;
	string name;


	Dog(int age, string name) : age{ age }, name{ name } {
		cout << age << ", " << name << " - ctor" << endl;
	}
	~Dog() {
		cout << age << ", " << name << " - dtor" << endl;
	}

	void show() {
		cout << "나는 갠데 이름은 " << name << "이고 나이는 " << age << "살이야!" << endl;
	}
};

// [문제] Dog 객체 한 개를 STACK(Free Store)에 생성하라.
// 객체가 생성되고 소멸되는 순간을 화면 출력으로 관찰하라.
// 객체의 나이와 이름을 인자로 받아 생성하도록 하자.
// Dog의 show member 함수를 만들어 정보를 출력해보자.

int main()
{
	Dog dog{ 1, "xx" };

	dog.show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-21 오후 12:53:27 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.21       (7주 2일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Dog {
	int age;
	string name;


	Dog(int age, string name) : age{ age }, name{ name } {
		cout << age << ", " << name << " - ctor" << endl;
	}
	~Dog() {
		cout << age << ", " << name << " - dtor" << endl;
	}

	void show() {
		cout << "나는 갠데 이름은 " << name << "이고 나이는 " << age << "살이야!" << endl;
	}
};

// [문제] Dog 객체 한 개를 STACK(Free Store)에 생성하라.
// 객체가 생성되고 소멸되는 순간을 화면 출력으로 관찰하라.
// 객체의 나이와 이름을 인자로 받아 생성하도록 하자.
// Dog의 show member 함수를 만들어 정보를 출력해보자.

int main()
{
	{
		Dog dog{ 1, "xx" };

		dog.show();
	}

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-21 오후 12:58:35 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.21       (7주 2일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Dog {
	int age;
	string name;


	Dog(int age, string name) : age{ age }, name{ name } {
		cout << age << ", " << name << " - ctor" << endl;
	}
	~Dog() {
		cout << age << ", " << name << " - dtor" << endl;
	}

	void show() {
		cout << "나는 갠데 이름은 " << name << "이고 나이는 " << age << "살이야!" << endl;
	}
};

// [문제] Dog 객체 한 개를 Free Store에 생성하라.
// 객체가 생성되고 소멸되는 순간을 화면 출력으로 관찰하라.
// 객체의 나이와 이름을 인자로 받아 생성하도록 하자.
// Dog의 show member 함수를 만들어 정보를 출력해보자.

int main()
{
	new Dog{ 1, "댕댕이" };

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-21 오후 1:01:27 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.21       (7주 2일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Dog {
	int age;
	string name;


	Dog(int age, string name) : age{ age }, name{ name } {
		cout << age << ", " << name << " - ctor" << endl;
	}
	~Dog() {
		cout << age << ", " << name << " - dtor" << endl;
	}

	void show() {
		cout << "나는 갠데 이름은 " << name << "이고 나이는 " << age << "살이야!" << endl;
	}
};

// [문제] Dog 객체 한 개를 Free Store에 생성하라.
// 객체가 생성되고 소멸되는 순간을 화면 출력으로 관찰하라.
// 객체의 나이와 이름을 인자로 받아 생성하도록 하자.
// Dog의 show member 함수를 만들어 정보를 출력해보자.

int main()
{
	Dog* p = new Dog{ 1, "댕댕이" };

	(*p).show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-21 오후 1:02:07 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.21       (7주 2일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Dog {
	int age;
	string name;


	Dog(int age, string name) : age{ age }, name{ name } {
		cout << age << ", " << name << " - ctor" << endl;
	}
	~Dog() {
		cout << age << ", " << name << " - dtor" << endl;
	}

	void show() {
		cout << "나는 갠데 이름은 " << name << "이고 나이는 " << age << "살이야!" << endl;
	}
};

// [문제] Dog 객체 한 개를 Free Store에 생성하라.
// 객체가 생성되고 소멸되는 순간을 화면 출력으로 관찰하라.
// 객체의 나이와 이름을 인자로 받아 생성하도록 하자.
// Dog의 show member 함수를 만들어 정보를 출력해보자.

int main()
{
	Dog* p = new Dog{ 1, "댕댕이" };

	p->show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-21 오후 1:03:51 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.21       (7주 2일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Dog {
	int age;
	string name;


	Dog(int age, string name) : age{ age }, name{ name } {
		cout << age << ", " << name << " - ctor" << endl;
	}
	~Dog() {
		cout << age << ", " << name << " - dtor" << endl;
	}

	void show() {
		cout << "나는 갠데 이름은 " << name << "이고 나이는 " << age << "살이야!" << endl;
	}
};

// [문제] Dog 객체 한 개를 Free Store에 생성하라.
// 객체가 생성되고 소멸되는 순간을 화면 출력으로 관찰하라.
// 객체의 나이와 이름을 인자로 받아 생성하도록 하자.
// Dog의 show member 함수를 만들어 정보를 출력해보자.

int main()
{
	Dog* p = new Dog{ 1, "댕댕이" };

	p->show();

	delete p;
	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-21 오후 1:04:05 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.21       (7주 2일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Dog {
	int age;
	string name;


	Dog(int age, string name) : age{ age }, name{ name } {
		cout << age << ", " << name << " - ctor" << endl;
	}
	~Dog() {
		cout << age << ", " << name << " - dtor" << endl;
	}

	void show() {
		cout << "나는 갠데 이름은 " << name << "이고 나이는 " << age << "살이야!" << endl;
	}
};

// [문제] Dog 객체 한 개를 Free Store에 생성하라.
// 객체가 생성되고 소멸되는 순간을 화면 출력으로 관찰하라.
// 객체의 나이와 이름을 인자로 받아 생성하도록 하자.
// Dog의 show member 함수를 만들어 정보를 출력해보자.

int main()
{
	Dog* p = new Dog{ 1, "댕댕이" };

	p->show();

	save("소스.cpp");
	delete p;
}


-------------------------------------------
소스.cpp - 2020-10-21 오후 1:11:48 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.21       (7주 2일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Dog {
	int age;
	string name;


	Dog(int age, string name) : age{ age }, name{ name } {
		cout << age << ", " << name << " - ctor" << endl;
	}
	~Dog() {
		cout << age << ", " << name << " - dtor" << endl;
	}

	void show() {
		cout << "나는 갠데 이름은 " << name << "이고 나이는 " << age << "살이야!" << endl;
	}
};

// [문제] Dog 객체 2개를 생성하여 생성/소멸 순서를 관찰하자.

int main()
{
	Dog a{ 1, "에이" };
	Dog b{ 2, "비" };

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-21 오후 1:12:09 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.21       (7주 2일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Dog {
	int age;
	string name;


	Dog(int age, string name) : age{ age }, name{ name } {
		cout << age << ", " << name << " - ctor" << endl;
	}
	~Dog() {
		cout << age << ", " << name << " - dtor" << endl;
	}

	void show() {
		cout << "나는 갠데 이름은 " << name << "이고 나이는 " << age << "살이야!" << endl;
	}
};

// [문제] Dog 객체 2개를 생성하여 생성/소멸 순서를 관찰하자.

int main()
{
	Dog a{ 1, "에이" };
	Dog b{ 2, "비" };
	Dog c{ 3, "씨" };

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-21 오후 1:12:23 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.21       (7주 2일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Dog {
	int age;
	string name;


	Dog(int age, string name) : age{ age }, name{ name } {
		cout << age << ", " << name << " - ctor" << endl;
	}
	~Dog() {
		cout << age << ", " << name << " - dtor" << endl;
	}

	void show() {
		cout << "나는 갠데 이름은 " << name << "이고 나이는 " << age << "살이야!" << endl;
	}
};

// [문제] Dog 객체 2개를 생성하여 생성/소멸 순서를 관찰하자.

int main()
{
	Dog a{ 1, "에이" };
	Dog b{ 2, "비" };
	Dog c{ 3, "씨" };
	Dog d{ 4, "디" };

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-21 오후 1:12:55 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.21       (7주 2일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Dog {
	int age;
	string name;


	Dog(int age, string name) : age{ age }, name{ name } {
		cout << age << ", " << name << " - ctor" << endl;
	}
	~Dog() {
		cout << age << ", " << name << " - dtor" << endl;
	}

	void show() {
		cout << "나는 갠데 이름은 " << name << "이고 나이는 " << age << "살이야!" << endl;
	}
};

// [문제] Dog 객체 2개를 생성하여 생성/소멸 순서를 관찰하자.

int main()
{
	Dog a{ 1, "먼저생성" };
	Dog b{ 2, "그다음생성" };

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-21 오후 1:13:57 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.21       (7주 2일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Dog {
	int age;
	string name;


	Dog(int age, string name) : age{ age }, name{ name } {
		cout << age << ", " << name << " - ctor" << endl;
	}
	~Dog() {
		cout << age << ", " << name << " - dtor" << endl;
	}

	void show() {
		cout << "나는 갠데 이름은 " << name << "이고 나이는 " << age << "살이야!" << endl;
	}
};

// [문제] Dog 객체 2개를 생성하여 생성/소멸 순서를 관찰하자.

int main()
{
	/*Dog a{ 1, "먼저생성" };
	Dog b{ 2, "그다음생성" };*/

	Dog a[2]{ { 1, "먼저생성" } , { 2, "그다음생성" } };

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-21 오후 1:14:08 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.21       (7주 2일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Dog {
	int age;
	string name;


	Dog(int age, string name) : age{ age }, name{ name } {
		cout << age << ", " << name << " - ctor" << endl;
	}
	~Dog() {
		cout << age << ", " << name << " - dtor" << endl;
	}

	void show() {
		cout << "나는 갠데 이름은 " << name << "이고 나이는 " << age << "살이야!" << endl;
	}
};

// [문제] Dog 객체 2개를 생성하여 생성/소멸 순서를 관찰하자.

int main()
{
	Dog a{ 1, "먼저생성" };
	Dog b{ 2, "그다음생성" };

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-21 오후 1:14:56 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.21       (7주 2일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Dog {
	int age;
	string name;


	Dog(int age, string name) : age{ age }, name{ name } {
		cout << age << ", " << name << " - ctor" << endl;
	}
	~Dog() {
		cout << age << ", " << name << " - dtor" << endl;
	}

	void show() {
		cout << "나는 갠데 이름은 " << name << "이고 나이는 " << age << "살이야!" << endl;
	}
};

// [문제] Dog 객체 2개를 생성하여 생성/소멸 순서를 관찰하자.

int main()
{
	Dog a{ 1, "먼저생성" };
	Dog b{ 2, "그다음생성" };
	Dog c{ 3, "마지막생성" };

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-21 오후 1:16:22 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.21       (7주 2일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Dog {
	int age;
	string name;


	Dog(int age, string name) : age{ age }, name{ name } {
		cout << age << ", " << name << " - ctor" << endl;
	}
	~Dog() {
		cout << age << ", " << name << " - dtor" << endl;
	}

	void show() {
		cout << "나는 갠데 이름은 " << name << "이고 나이는 " << age << "살이야!" << endl;
	}
};

// [문제] Dog 객체 2개를 생성하여 생성/소멸 순서를 관찰하자.

int main()
{
	Dog a{ 1, "첫 째" };
	Dog b{ 2, "둘 째" };

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-21 오후 1:17:04 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.21       (7주 2일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Dog {
	int age;
	string name;


	Dog(int age, string name) : age{ age }, name{ name } {
		cout << age << ", " << name << " - ctor" << endl;
	}
	~Dog() {
		cout << age << ", " << name << " - dtor" << endl;
	}

	void show() {
		cout << "나는 갠데 이름은 " << name << "이고 나이는 " << age << "살이야!" << endl;
	}
};

// [문제] Dog 객체 2개를 생성하여 생성/소멸 순서를 관찰하자.
Dog a{ 1, "첫 째" };
Dog b{ 2, "둘 째" };

int main()
{


	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-21 오후 1:18:35 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.21       (7주 2일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Dog {
	int age;
	string name;


	Dog(int age, string name) : age{ age }, name{ name } {
		cout << age << ", " << name << " - ctor" << endl;
	}
	~Dog() {
		cout << age << ", " << name << " - dtor" << endl;
	}

	void show() {
		cout << "나는 갠데 이름은 " << name << "이고 나이는 " << age << "살이야!" << endl;
	}
};

// [문제] Dog 객체 2개를 생성하여 생성/소멸 순서를 관찰하자.

int main()
{
	Dog dogs[2]{ { 1, "첫째" }, { 2, "둘째" } };

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-21 오후 1:19:31 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.21       (7주 2일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Dog {
	int age;
	string name;


	Dog(int age, string name) : age{ age }, name{ name } {
		cout << age << ", " << name << " - ctor" << endl;
	}
	~Dog() {
		cout << age << ", " << name << " - dtor" << endl;
	}

	void show() {
		cout << "나는 갠데 이름은 " << name << "이고 나이는 " << age << "살이야!" << endl;
	}
};

// [문제] Dog 객체 2개를 생성하여 생성/소멸 순서를 관찰하자.

int main()
{
	Dog* p = new Dog[2]{ { 1, "첫째" }, { 2, "둘째" } };

	delete[] p;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-26 오후 1:35:06 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.26       (8주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Dog {
	int age;
	string name;


	Dog(int age, string name) : age{ age }, name{ name } {
		cout << age << ", " << name << " - ctor" << endl;
	}
	~Dog() {
		cout << age << ", " << name << " - dtor" << endl;
	}

	void show() {
		cout << "나는 갠데 이름은 " << name << "이고 나이는 " << age << "살이야!" << endl;
	}
};

// [문제] Dog 객체의 생성과 소멸을 관찰

int main()
{
	cout << "------------------- 메인 시작 --------------------" << endl;

	Dog{ 1, "시험" };

	save("소스.cpp");

	cout << "------------------- 메인 끝 ----------------------" << endl;
}


-------------------------------------------
소스.cpp - 2020-10-26 오후 1:36:02 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.26       (8주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Dog {
	int age;
	string name;


	Dog(int age, string name) : age{ age }, name{ name } {
		cout << age << ", " << name << " - ctor" << endl;
	}
	~Dog() {
		cout << age << ", " << name << " - dtor" << endl;
	}

	void show() {
		cout << "나는 갠데 이름은 " << name << "이고 나이는 " << age << "살이야!" << endl;
	}
};

// [문제] Dog 객체의 생성과 소멸을 관찰

int main()
{
	cout << "------------------- 메인 시작 --------------------" << endl;

	Dog dog{ 1, "시험" };

	save("소스.cpp");

	cout << "------------------- 메인 끝 ----------------------" << endl;
}


-------------------------------------------
소스.cpp - 2020-10-26 오후 1:36:35 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.26       (8주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Dog {
	int age;
	string name;


	Dog(int age, string name) : age{ age }, name{ name } {
		cout << age << ", " << name << " - ctor" << endl;
	}
	~Dog() {
		cout << age << ", " << name << " - dtor" << endl;
	}

	void show() {
		cout << "나는 갠데 이름은 " << name << "이고 나이는 " << age << "살이야!" << endl;
	}
};

// [문제] Dog 객체의 생성과 소멸을 관찰

int main()
{
	cout << "------------------- 메인 시작 --------------------" << endl;

	Dog { 1, "시험" };

	save("소스.cpp");

	cout << "------------------- 메인 끝 ----------------------" << endl;
}


-------------------------------------------
소스.cpp - 2020-10-26 오후 1:36:55 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.26       (8주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Dog {
	int age;
	string name;


	Dog(int age, string name) : age{ age }, name{ name } {
		cout << age << ", " << name << " - ctor" << endl;
	}
	~Dog() {
		cout << age << ", " << name << " - dtor" << endl;
	}

	void show() {
		cout << "나는 갠데 이름은 " << name << "이고 나이는 " << age << "살이야!" << endl;
	}
};

// [문제] Dog 객체의 생성과 소멸을 관찰

int main()
{
	cout << "------------------- 메인 시작 --------------------" << endl;

	Dog { 1, "시험" };

	save("소스.cpp");

	Dog{ 2, "시험2" };

	cout << "------------------- 메인 끝 ----------------------" << endl;
}


-------------------------------------------
소스.cpp - 2020-10-26 오후 1:37:08 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.26       (8주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Dog {
	int age;
	string name;


	Dog(int age, string name) : age{ age }, name{ name } {
		cout << age << ", " << name << " - ctor" << endl;
	}
	~Dog() {
		cout << age << ", " << name << " - dtor" << endl;
	}

	void show() {
		cout << "나는 갠데 이름은 " << name << "이고 나이는 " << age << "살이야!" << endl;
	}
};

// [문제] Dog 객체의 생성과 소멸을 관찰

int main()
{
	cout << "------------------- 메인 시작 --------------------" << endl;

	Dog { 1, "시험" };
	Dog{ 2, "시험2" };

	save("소스.cpp");



	cout << "------------------- 메인 끝 ----------------------" << endl;
}


-------------------------------------------
소스.cpp - 2020-10-26 오후 1:37:31 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.26       (8주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Dog {
	int age;
	string name;


	Dog(int age, string name) : age{ age }, name{ name } {
		cout << age << ", " << name << " - ctor" << endl;
	}
	~Dog() {
		cout << age << ", " << name << " - dtor" << endl;
	}

	void show() {
		cout << "나는 갠데 이름은 " << name << "이고 나이는 " << age << "살이야!" << endl;
	}
};

// [문제] Dog 객체의 생성과 소멸을 관찰

int main()
{
	cout << "------------------- 메인 시작 --------------------" << endl;

	Dog { 1, "시험" };
	Dog dog{ 2, "시험2" };

	save("소스.cpp");



	cout << "------------------- 메인 끝 ----------------------" << endl;
}


-------------------------------------------
소스.cpp - 2020-10-26 오후 1:38:06 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.26       (8주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Dog {
	int age;
	string name;


	Dog(int age, string name) : age{ age }, name{ name } {
		cout << age << ", " << name << " - ctor" << endl;
	}
	~Dog() {
		cout << age << ", " << name << " - dtor" << endl;
	}

	void show() {
		cout << "나는 갠데 이름은 " << name << "이고 나이는 " << age << "살이야!" << endl;
	}
};

// [문제] Dog 객체의 생성과 소멸을 관찰

int main()
{
	cout << "------------------- 메인 시작 --------------------" << endl;

	Dog { 1, "시험" };
	Dog dog{ 2, "시험2" };
	Dog{ 3, "시험3" };

	save("소스.cpp");



	cout << "------------------- 메인 끝 ----------------------" << endl;
}


-------------------------------------------
소스.cpp - 2020-10-26 오후 1:38:42 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.26       (8주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Dog {
	int age;
	string name;


	Dog(int age, string name) : age{ age }, name{ name } {
		cout << age << ", " << name << " - ctor" << endl;
	}
	~Dog() {
		cout << age << ", " << name << " - dtor" << endl;
	}

	void show() {
		cout << "나는 갠데 이름은 " << name << "이고 나이는 " << age << "살이야!" << endl;
	}
};

// [문제] Dog 객체의 생성과 소멸을 관찰
Dog dog{ 1, "시험" };

int main()
{
	cout << "------------------- 메인 시작 --------------------" << endl;

	save("소스.cpp");

	cout << "------------------- 메인 끝 ----------------------" << endl;
}


-------------------------------------------
소스.cpp - 2020-10-26 오후 1:39:09 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.26       (8주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Dog {
	int age;
	string name;


	Dog(int age, string name) : age{ age }, name{ name } {
		cout << age << ", " << name << " - ctor" << endl;
	}
	~Dog() {
		cout << age << ", " << name << " - dtor" << endl;
	}

	void show() {
		cout << "나는 갠데 이름은 " << name << "이고 나이는 " << age << "살이야!" << endl;
	}
};

// [문제] Dog 객체의 생성과 소멸을 관찰
Dog dog{ 1, "시험" };

int main()
{
	cout << "------------------- 메인 시작 --------------------" << endl;
	Dog dog{ 2, "시험" };
	save("소스.cpp");

	cout << "------------------- 메인 끝 ----------------------" << endl;
}


-------------------------------------------
소스.cpp - 2020-10-26 오후 1:40:19 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.26       (8주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Dog {
	int age;
	string name;


	Dog(int age, string name) : age{ age }, name{ name } {
		cout << age << ", " << name << " - ctor" << endl;
	}
	~Dog() {
		cout << age << ", " << name << " - dtor" << endl;
	}

	void show() {
		cout << "나는 갠데 이름은 " << name << "이고 나이는 " << age << "살이야!" << endl;
	}
};

// [문제] Dog 객체의 생성과 소멸을 관찰


int main()
{
	cout << "------------------- 메인 시작 --------------------" << endl;

	Dog dog{ 1, "시험" };

	save("소스.cpp");

	cout << "------------------- 메인 끝 ----------------------" << endl;
}


-------------------------------------------
소스.cpp - 2020-10-26 오후 1:40:30 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.26       (8주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Dog {
	int age;
	string name;


	Dog(int age, string name) : age{ age }, name{ name } {
		cout << age << ", " << name << " - ctor" << endl;
	}
	~Dog() {
		cout << age << ", " << name << " - dtor" << endl;
	}

	void show() {
		cout << "나는 갠데 이름은 " << name << "이고 나이는 " << age << "살이야!" << endl;
	}
};

// [문제] Dog 객체의 생성과 소멸을 관찰


int main()
{
	cout << "------------------- 메인 시작 --------------------" << endl;

	static Dog dog{ 1, "시험" };

	save("소스.cpp");

	cout << "------------------- 메인 끝 ----------------------" << endl;
}


-------------------------------------------
소스.cpp - 2020-10-26 오후 1:40:57 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.26       (8주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Dog {
	int age;
	string name;


	Dog(int age, string name) : age{ age }, name{ name } {
		cout << age << ", " << name << " - ctor" << endl;
	}
	~Dog() {
		cout << age << ", " << name << " - dtor" << endl;
	}

	void show() {
		cout << "나는 갠데 이름은 " << name << "이고 나이는 " << age << "살이야!" << endl;
	}
};

// [문제] Dog 객체의 생성과 소멸을 관찰


int main()
{
	cout << "------------------- 메인 시작 --------------------" << endl;

	static Dog dog{ 1, "시험" };

	save("소스.cpp");

	cout << "------------------- 메인 끝 ----------------------" << endl;
}


-------------------------------------------
소스.cpp - 2020-10-26 오후 1:41:34 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.26       (8주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Dog {
	int age;
	string name;


	Dog(int age, string name) : age{ age }, name{ name } {
		cout << age << ", " << name << " - ctor" << endl;
	}
	~Dog() {
		cout << age << ", " << name << " - dtor" << endl;
	}

	void show() {
		cout << "나는 갠데 이름은 " << name << "이고 나이는 " << age << "살이야!" << endl;
	}
};

// [문제] Dog 객체의 생성과 소멸을 관찰


int main()
{
	cout << "------------------- 메인 시작 --------------------" << endl;

	{
		Dog dog{ 1, "시험" };
	}
	save("소스.cpp");

	cout << "------------------- 메인 끝 ----------------------" << endl;
}


-------------------------------------------
소스.cpp - 2020-10-26 오후 1:41:40 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.26       (8주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Dog {
	int age;
	string name;


	Dog(int age, string name) : age{ age }, name{ name } {
		cout << age << ", " << name << " - ctor" << endl;
	}
	~Dog() {
		cout << age << ", " << name << " - dtor" << endl;
	}

	void show() {
		cout << "나는 갠데 이름은 " << name << "이고 나이는 " << age << "살이야!" << endl;
	}
};

// [문제] Dog 객체의 생성과 소멸을 관찰


int main()
{
	cout << "------------------- 메인 시작 --------------------" << endl;

	{
		static Dog dog{ 1, "시험" };
	}
	save("소스.cpp");

	cout << "------------------- 메인 끝 ----------------------" << endl;
}


-------------------------------------------
소스.cpp - 2020-10-26 오후 1:42:21 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.26       (8주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Dog {
	int age;
	string name;


	Dog(int age, string name) : age{ age }, name{ name } {
		cout << age << ", " << name << " - ctor" << endl;
	}
	~Dog() {
		cout << age << ", " << name << " - dtor" << endl;
	}

	void show() {
		cout << "나는 갠데 이름은 " << name << "이고 나이는 " << age << "살이야!" << endl;
	}
};

// [문제] Dog 객체의 생성과 소멸을 관찰


int main()
{
	cout << "------------------- 메인 시작 --------------------" << endl;

	{
		static Dog dog{ 1, "시험" };
		Dog dogs{ 2, "시험2" };
	}
	save("소스.cpp");

	cout << "------------------- 메인 끝 ----------------------" << endl;
}


-------------------------------------------
소스.cpp - 2020-10-26 오후 1:44:31 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.26       (8주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Dog {
	int age;
	string name;

	Dog(int age, string name) : age{ age }, name{ name } {
		cout << age << ", " << name << " - ctor" << endl;
	}

	~Dog() {
		cout << age << ", " << name << " - dtor" << endl;
	}

	void show() {
		cout << "나는 갠데 이름은 " << name << "이고 나이는 " << age << "살이야!" << endl;
	}
};

// [문제] Dog 객체의 생성과 소멸을 관찰


int main()
{
	cout << "------------------- 메인 시작 --------------------" << endl;

	Dog dogs[2]{ {1, "A"}, {2, "B"} };
	
	dogs[0].show();
	dogs[1].show();


	save("소스.cpp");

	cout << "------------------- 메인 끝 ----------------------" << endl;
}


-------------------------------------------
소스.cpp - 2020-10-26 오후 1:46:01 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.26       (8주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Dog {
	int age;
	string name;

	Dog() {

	}

	Dog(int age, string name) : age{ age }, name{ name } {
		cout << age << ", " << name << " - ctor" << endl;
	}

	~Dog() {
		cout << age << ", " << name << " - dtor" << endl;
	}

	void show() {
		cout << "나는 갠데 이름은 " << name << "이고 나이는 " << age << "살이야!" << endl;
	}
};

// [문제] Dog 객체의 생성과 소멸을 관찰


int main()
{
	cout << "------------------- 메인 시작 --------------------" << endl;

	Dog dogs[30]{ {1, "A"}, {2, "B"} };
	
	dogs[0].show();
	dogs[1].show();


	save("소스.cpp");

	cout << "------------------- 메인 끝 ----------------------" << endl;
}


-------------------------------------------
소스.cpp - 2020-10-26 오후 1:52:57 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.26       (8주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

// [문제] 실행되어야 한다
using Dog = int;

int main()
{
	Dog dog;

	save( "소스.cpp" );
}


-------------------------------------------
소스.cpp - 2020-10-26 오후 1:54:12 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.26       (8주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

// [문제] 실행되어야 한다.
// Dog는 사용자 정의 자료형이다.
// main()을 수정하면 안된다.

struct Dog { };

int main()
{
	Dog dog;

	save( "소스.cpp" );
}


-------------------------------------------
소스.cpp - 2020-10-26 오후 1:57:01 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.26       (8주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

// [문제] 실행되어야 한다.
// Dog는 사용자 정의 자료형이다.
// main()을 수정하면 안된다.
// 객체의 생성과 소멸을 관찰하라.

struct Dog { 
	Dog() { cout << "디폴트생성" << endl; }
	~Dog() { cout << "소멸" << endl;  }
};

int main()
{
	Dog dog;	// Dog();

	save( "소스.cpp" );
}


-------------------------------------------
소스.cpp - 2020-10-26 오후 1:58:06 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.26       (8주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

// [문제] 실행되어야 한다.
// Dog는 사용자 정의 자료형이다.
// main()을 수정하면 안된다.
// 객체의 생성과 소멸을 관찰하라.

struct Dog { 
	Dog() { cout << "디폴트생성" << endl; }
	Dog(int a, int b, int c) {}
	~Dog() { cout << "소멸" << endl;  }
};

int main()
{
	Dog dog;	// Dog();
	Dog dogd(1, 2, 3);

	save( "소스.cpp" );
}


-------------------------------------------
소스.cpp - 2020-10-26 오후 1:58:37 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.26       (8주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

// [문제] 실행되어야 한다.
// Dog는 사용자 정의 자료형이다.
// main()을 수정하면 안된다.
// 객체의 생성과 소멸을 관찰하라.

struct Dog { 
	Dog() { cout << "디폴트생성" << endl; }
	Dog(int a, int b, int c) {}
	~Dog() { cout << "소멸" << endl;  }
};

int main()
{
	Dog dog1;	// Dog();
	Dog dog2(1, 2, 3);

	save( "소스.cpp" );
}


-------------------------------------------
소스.cpp - 2020-10-26 오후 1:58:53 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.26       (8주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

// [문제] 실행되어야 한다.
// Dog는 사용자 정의 자료형이다.
// main()을 수정하면 안된다.
// 객체의 생성과 소멸을 관찰하라.

struct Dog { 
	Dog() { cout << "디폴트생성" << endl; }
	Dog(int a, int b, int c) { cout << "생성" << endl; }
	~Dog() { cout << "소멸" << endl;  }
};

int main()
{
	Dog dog1;	// Dog();
	Dog dog2(1, 2, 3);

	save( "소스.cpp" );
}


-------------------------------------------
소스.cpp - 2020-10-26 오후 1:59:52 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.26       (8주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

// [문제] 실행되어야 한다.
// Dog는 사용자 정의 자료형이다.
// main()을 수정하면 안된다.
// 객체의 생성과 소멸을 관찰하라.

struct Dog { 
	Dog() { cout << "디폴트생성" << endl; }

	Dog( int, int, int ) { }



	~Dog() { cout << "소멸" << endl;  }
};

int main()
{
	Dog dog1;	// Dog();
	Dog dog2(1, 2, 3);

	save( "소스.cpp" );
}


-------------------------------------------
소스.cpp - 2020-10-26 오후 2:00:34 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.26       (8주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

// [문제] 실행되어야 한다.
// Dog는 사용자 정의 자료형이다.
// main()을 수정하면 안된다.
// 객체의 생성과 소멸을 관찰하라.

struct Dog { 
	Dog() { cout << "디폴트생성" << endl; }

	Dog(int, int, int) { cout << "생성(int, int, int)" << endl; }



	~Dog() { cout << "소멸" << endl;  }
};

int main()
{
	Dog dog1;	// Dog();
	Dog dog2(1, 2, 3);

	save( "소스.cpp" );
}


-------------------------------------------
소스.cpp - 2020-10-26 오후 2:02:05 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.26       (8주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

// [문제] 실행되어야 한다.
// Dog는 사용자 정의 자료형이다.
// main()을 수정하면 안된다.
// 객체의 생성과 소멸을 관찰하라.

struct Dog { 
	Dog() { cout << "디폴트생성" << endl; }

	~Dog() { cout << "소멸" << endl;  }
};

int main()
{
	Dog dog1;
	Dog dog2{ dog1 };


	save( "소스.cpp" );
}


-------------------------------------------
소스.cpp - 2020-10-26 오후 2:07:36 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.26       (8주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

// [문제] 실행되어야 한다.
// Dog는 사용자 정의 자료형이다.
// main()을 수정하면 안된다.
// 객체의 생성과 소멸을 관찰하라.

struct Dog { 
	Dog() { cout << "디폴트생성" << endl; }

	Dog( Dog& ) { cout << "복사생성" << endl; }

	~Dog() { cout << "소멸" << endl;  }
};

int main()
{
	Dog dog1;		// Dog()

	Dog dog2{ dog1 };	// Dog( Dog ) 


	save( "소스.cpp" );
}


-------------------------------------------
소스.cpp - 2020-10-26 오후 2:14:15 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.26       (8주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

// [문제] 실행되어야 한다.
// Dog는 사용자 정의 자료형이다.
// main()을 수정하면 안된다.
// 객체의 생성과 소멸을 관찰하라.

struct Dog { 
	Dog() { cout << "디폴트생성" << endl; }

	Dog( const Dog& other ) { cout << "복사생성" << endl; }
	
	~Dog() { cout << "소멸" << endl;  }
};

int main()
{
	Dog dog1;		// Dog()

	Dog dog2{ dog1 };	// Dog( const Dog& ) 


	save( "소스.cpp" );
}


-------------------------------------------
소스.cpp - 2020-10-26 오후 2:16:21 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.26       (8주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

// [문제] 실행되어야 한다.
// Dog는 사용자 정의 자료형이다.
// main()을 수정하면 안된다.
// 객체의 생성과 소멸을 관찰하라.

struct Dog { 
	Dog() { cout << "디폴트생성" << endl; }

	Dog( const Dog& other ) { cout << "복사생성" << endl; }
	
	~Dog() { cout << "소멸" << endl;  }
};

int main()
{
	Dog a;
	Dog b = a;

	save( "소스.cpp" );
}


-------------------------------------------
소스.cpp - 2020-10-26 오후 2:16:45 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.26       (8주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

// [문제] 실행되어야 한다.
// Dog는 사용자 정의 자료형이다.
// main()을 수정하면 안된다.
// 객체의 생성과 소멸을 관찰하라.

struct Dog { 
	Dog() { cout << "디폴트생성" << endl; }

	Dog( const Dog& other ) { cout << "복사생성" << endl; }
	
	~Dog() { cout << "소멸" << endl;  }
};

int main()
{
	Dog a;
	Dog b = a;

	save( "소스.cpp" );
}


-------------------------------------------
소스.cpp - 2020-10-26 오후 2:17:22 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.26       (8주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

// [문제] 실행되어야 한다.
// Dog는 사용자 정의 자료형이다.
// main()을 수정하면 안된다.
// 객체의 생성과 소멸을 관찰하라.

struct Dog { 
	Dog() { cout << "디폴트생성" << endl; }

	Dog( const Dog& other ) { cout << "복사생성" << endl; }
	
	~Dog() { cout << "소멸" << endl;  }
};

int main()
{
	Dog a;
	Dog b(a);

	save( "소스.cpp" );
}


-------------------------------------------
소스.cpp - 2020-10-26 오후 2:17:30 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.26       (8주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

// [문제] 실행되어야 한다.
// Dog는 사용자 정의 자료형이다.
// main()을 수정하면 안된다.
// 객체의 생성과 소멸을 관찰하라.

struct Dog { 
	Dog() { cout << "디폴트생성" << endl; }

	Dog( const Dog& other ) { cout << "복사생성" << endl; }
	
	~Dog() { cout << "소멸" << endl;  }
};

int main()
{
	Dog a;
	Dog b{ a };

	save( "소스.cpp" );
}


-------------------------------------------
소스.cpp - 2020-10-26 오후 2:18:22 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.26       (8주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

// [문제] 실행되어야 한다.
// Dog는 사용자 정의 자료형이다.
// main()을 수정하면 안된다.
// 객체의 생성과 소멸을 관찰하라.

struct Dog { 
	Dog() { cout << "디폴트생성" << endl; }

	Dog( const Dog& other ) { cout << "복사생성" << endl; }
	
	~Dog() { cout << "소멸" << endl;  }
};

int main()
{
	Dog a;
	Dog c;

	c = a;		// 이 순간은?

	save( "소스.cpp" );
}


-------------------------------------------
소스.cpp - 2020-10-26 오후 2:20:32 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.26       (8주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

// [문제] 실행되어야 한다.
// Dog는 사용자 정의 자료형이다.
// main()을 수정하면 안된다.
// 객체의 생성과 소멸을 관찰하라.

struct Dog { 
	Dog() { cout << "디폴트생성" << endl; }

	Dog( const Dog& other ) { cout << "복사생성" << endl; }
	
	~Dog() { cout << "소멸" << endl;  }

	Dog& operator=(const Dog& other) {
		cout << "대입연산자" << endl;
		return *this;
	}

};

int main()
{
	Dog a;
	Dog c;

	c = a;		// 이 순간은?

	save( "소스.cpp" );
}


-------------------------------------------
소스.cpp - 2020-10-26 오후 2:44:09 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.26       (8주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

struct Dog {
	int a;

// C++ 언어는 필요에 따라 다음 6개의 함수를 생성한다.
	Dog() = default;	// 디폴트 생성자
	~Dog() = default;	// 소멸자

	Dog(const Dog&) = default;	// 복사생성자
	Dog& operator=(const Dog&) = default; // 복사대입연산자

	Dog(Dog&&) = default;	// 이동생성자
	Dog& operator=(Dog&&) = default; // 이동대입연산자
};

int main()
{
	Dog a{ 1 };
	Dog b = a;
	Dog c;

	c = a;
	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-26 오후 2:46:13 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.26       (8주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

int main()
{
	int a[10]{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

	for (int n : a)
		cout << n << endl;


	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-26 오후 2:49:01 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.26       (8주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

struct Test {
	int num;
	char x[1234];





	void show() {
		cout << "Test - " << num << endl;
	}
};


// [문제] 객체의 생성, 소멸, 복사를 관찰하라.

int main()
{
	Test a[10]{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

	for (Test n : a)
		n.show();


	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-26 오후 2:50:18 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.26       (8주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

struct Test {
	int num;
	char x[1234];

	Test(int n) : num{ n } {
		cout << "Test - " << n << "생성" << endl;
	}



	void show() {
		cout << "Test - " << num << endl;
	}
};


// [문제] 객체의 생성, 소멸, 복사를 관찰하라.

int main()
{
	Test a[10]{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

	for (Test n : a)
		n.show();


	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-26 오후 2:50:57 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.26       (8주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

struct Test {
	int num;
	char x[1234];

	Test(int n) : num{ n } {
		cout << "Test - " << n << "생성" << endl;
	}

	~Test() {
		cout << "Test - " << num << "소멸" << endl;
	}


	void show() {
		cout << "Test - " << num << endl;
	}
};


// [문제] 객체의 생성, 소멸, 복사를 관찰하라.

int main()
{
	Test a[10]{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

	for (Test n : a)
		n.show();


	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-26 오후 2:52:34 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.26       (8주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

struct Test {
	int num;
	char x[1234];

	Test(int n) : num{ n } {
		cout << "Test - " << n << "생성" << endl;
	}
	Test(const Test&) {
		cout << "Test - " << num << "복사" << endl;
	}

	~Test() {
		cout << "Test - " << num << "소멸" << endl;
	}


	void show() {
		cout << "Test - " << num << endl;
	}
};


// [문제] 객체의 생성, 소멸, 복사를 관찰하라.

int main()
{
	Test a[10]{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

	for (Test n : a)
		n.show();


	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-26 오후 2:53:13 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.26       (8주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

struct Test {
	int num;
	char x[1234];

	Test(int n) : num{ n } {
		cout << "Test - " << n << "생성" << endl;
	}
	Test(const Test&) {
		cout << "Test - " << num << "복사" << endl;
	}

	~Test() {
		cout << "Test - " << num << "소멸" << endl;
	}


	void show() {
		cout << "Test - " << num << endl;
	}
};


// [문제] 객체의 생성, 소멸, 복사를 관찰하라.

int main()
{
	Test a[10]{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

	for (Test n : a)
		n.show();


	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-26 오후 2:54:00 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.26       (8주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

struct Test {
	int num;
	char x[1234];

	Test(int n) : num{ n } {
		cout << "Test - " << n << "생성" << endl;
	}
	Test(Test&) {
		cout << "Test - " << num << "복사" << endl;
	}

	~Test() {
		cout << "Test - " << num << "소멸" << endl;
	}


	void show() {
		cout << "Test - " << num << endl;
	}
};


// [문제] 객체의 생성, 소멸, 복사를 관찰하라.

int main()
{
	Test a[10]{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

	for (Test n : a)
		n.show();


	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-26 오후 2:56:23 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.26       (8주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

struct Test {
	int num;
	char x[1234];

	Test(int n) : num{ n } {
		cout << "Test - " << n << "생성" << endl;
	}
	Test(const Test&) {
		cout << "Test - " << num << "복사" << endl;
	}
	Test& operator=(const Test& other) = default;

	~Test() {
		cout << "Test - " << num << "소멸" << endl;
	}


	void show() {
		cout << "Test - " << num << endl;
	}
};


// [문제] 객체의 생성, 소멸, 복사를 관찰하라.

int main()
{
	Test a[10]{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

	for (Test n : a)
		n.show();


	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-26 오후 2:57:31 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.26       (8주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

struct Test {
	int num;
	char x[1234];

	Test(int n) : num{ n } {
		cout << "Test - " << n << "생성" << endl;
	}
	Test(const Test& other) : num{ other.num } {
		cout << "Test - " << num << "복사" << endl;
	}
	

	~Test() {
		cout << "Test - " << num << "소멸" << endl;
	}


	void show() {
		cout << "Test - " << num << endl;
	}
};


// [문제] 객체의 생성, 소멸, 복사를 관찰하라.

int main()
{
	Test a[10]{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

	for (Test n : a)
		n.show();


	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-26 오후 3:00:43 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.26       (8주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

struct Test {
	int num;
	char x[1234];

	Test(int n) : num{ n } {
		cout << "Test - " << n << "생성" << endl;
	}
	Test(const Test& other) : num{ other.num } {
		cout << "Test - " << num << "복사" << endl;
	}
	

	~Test() {
		cout << "Test - " << num << "소멸" << endl;
	}


	void show() {
		cout << "Test - " << num << endl;
	}
};


// [문제] 객체의 생성, 소멸, 복사를 관찰하라.

int main()
{
	Test a[10]{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

	for (Test n : a)
		n.show();


	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-26 오후 3:03:35 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.26       (8주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

struct Test {
	int num;
	char x[1234];

	Test(int n) : num{ n } {
		cout << "생성 - " << num << endl;
	}
	/*Test(const Test& other) : num{ other.num } {
		cout << "Test - " << num << "복사" << endl;
	}*/
	

	~Test() {
		cout << "소멸 - " << num << endl;
	}


	void show() {
		cout << "Test - " << num << endl;
	}
};


// [문제] 객체의 생성, 소멸, 복사를 관찰하라.

int main()
{
	Test a[10]{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

	for (Test n : a)
		n.show();


	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-26 오후 3:04:43 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.26       (8주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

struct Test {
	int num;
	char x[1234];

	Test(int n) : num{ n } {
		cout << "생성 - " << num << endl;
	}
	/*Test(const Test& other) : num{ other.num } {
		cout << "Test - " << num << "복사" << endl;
	}*/
	

	~Test() {
		cout << "소멸 - " << num << endl;
	}


	void show() {
		cout << "Test - " << num << endl;
	}
};


// [문제] 객체의 생성, 소멸, 복사를 관찰하라.

int main()
{
	Test a[10]{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

	cout << "-------------------------" << endl;
	for (Test n : a)
		n.show();
	cout << "-------------------------" << endl;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-26 오후 3:06:36 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.26       (8주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

struct Test {
	int num;
	char x[1234];

	Test(int n) : num{ n } {
		cout << "생성 - " << num << endl;
	}
	/*Test(const Test& other) : num{ other.num } {
		cout << "Test - " << num << "복사" << endl;
	}*/
	

	~Test() {
		cout << "소멸 - " << num << endl;
	}


	void show() {
		cout << "Test - " << num << endl;
	}
};


// [문제] 객체의 생성, 소멸, 복사를 관찰하라.

int main()
{
	Test a[10]{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
	cout << sizeof(Test) << endl;
	cout << "-------------------------" << endl;
	for (Test n : a)
		n.show();
	cout << "-------------------------" << endl;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-26 오후 3:07:23 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.26       (8주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

struct Test {
	int num;
	char x[1236];

	Test(int n) : num{ n } {
		cout << "생성 - " << num << endl;
	}
	/*Test(const Test& other) : num{ other.num } {
		cout << "Test - " << num << "복사" << endl;
	}*/
	

	~Test() {
		cout << "소멸 - " << num << endl;
	}


	void show() {
		cout << "Test - " << num << endl;
	}
};


// [문제] 객체의 생성, 소멸, 복사를 관찰하라.

int main()
{
	Test a[10]{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
	cout << sizeof(Test) << endl;
	cout << "-------------------------" << endl;
	for (Test n : a)
		n.show();
	cout << "-------------------------" << endl;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-26 오후 3:10:46 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.26       (8주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

struct Test {
	int num;
	char x[1236];

	Test(int n) : num{ n } {
		cout << "생성 - " << num << endl;
	}
	Test(const Test& other) : num{ other.num } {
		cout << "복사생성 - " << num << endl;
	}
	

	~Test() {
		cout << "소멸 - " << num << endl;
	}


	void show() {
		cout << "Test - " << num << endl;
	}
};


// [문제] 객체의 생성, 소멸, 복사를 관찰하라.

int main()
{
	Test a[10]{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

	cout << "-------------------------" << endl;
	for (Test n : a)
		n.show();
	cout << "-------------------------" << endl;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-26 오후 3:12:49 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.26       (8주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

struct Test {
	int num;
	char x[1236];

	Test(int n) : num{ n } {
		cout << "생성 - " << num << endl;
	}
	Test(const Test& other) : num{ other.num } {
		cout << "복사생성 - " << num << endl;
	}
	

	~Test() {
		cout << "소멸 - " << num << endl;
	}


	void show() {
		cout << "Test - " << num << endl;
	}
};


// [문제] 객체의 생성, 소멸, 복사를 관찰하라.

int main()
{
	Test a[10]{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

	cout << "-------------------------" << endl;
	for (Test& n : a)
		n.show();
	cout << "-------------------------" << endl;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-26 오후 3:19:10 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.26       (8주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

struct Test {
	int num;
	char x[1236];

	Test(int n) : num{ n } {
		cout << "생성 - " << num << endl;
	}
	Test(const Test& other) : num{ other.num } {
		cout << "복사생성 - " << num << endl;
	}
	

	~Test() {
		cout << "소멸 - " << num << endl;
	}


	void show() {
		cout << "Test - " << ++++++num << endl;
	}
};


// [문제] 객체의 생성, 소멸, 복사를 관찰하라.

int main()
{
	Test a[10]{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

	cout << "-------------------------" << endl;
	for (Test& n : a)
		n.show();
	cout << "-------------------------" << endl;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-26 오후 3:19:42 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.26       (8주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

struct Test {
	int num;
	char x[1236];

	Test(int n) : num{ n } {
		cout << "생성 - " << num << endl;
	}
	Test(const Test& other) : num{ other.num } {
		cout << "복사생성 - " << num << endl;
	}
	

	~Test() {
		cout << "소멸 - " << num << endl;
	}


	void show() const {
		cout << "Test - " << num << endl;
	}
};


// [문제] 객체의 생성, 소멸, 복사를 관찰하라.

int main()
{
	Test a[10]{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

	cout << "-------------------------" << endl;
	for (const Test& n : a)
		n.show();
	cout << "-------------------------" << endl;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-28 오전 11:18:44 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.26       (8주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

struct Test {
	int num;
	char x[1236];

	Test(int n) : num{ n } {
		cout << "생성 - " << num << endl;
	}
	Test(const Test& other) : num{ other.num } {
		cout << "복사생성 - " << num << endl;
	}
	

	~Test() {
		cout << "소멸 - " << num << endl;
	}


	void show() const {
		cout << "Test - " << num << endl;
	}
};


// [문제] 객체의 생성, 소멸, 복사를 관찰하라.

int main()
{
	Test a[10]{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

	cout << "-------------------------" << endl;
	for (const Test& n : a)
		n.show();
	cout << "-------------------------" << endl;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-28 오전 11:35:53 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.28       (8주 2일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

int main()
{
	string s1{ "어떤 문자열이라도 저장하는 클래스 string" };

	cout << "모두 몇 글자? - " << s1.size() << endl;
	cout << s1 << endl;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-28 오전 11:58:02 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.28       (8주 2일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] main이 수정없이 실행되도록 class 코딩
struct String {
	size_t num;
	char* p;
	String(const char* str) {
		// str이 모두 몇 글자니?
		num = strlen(str);
		// Free Store에 글자수만큼 메모리를 요청
		p = new char[num];
		// 할당받은 메모리에 str의 내용을 복사한다.
		memcpy(p, str, num);
	}

	size_t size() {
		return num;
	}

	void show() {
		cout << *p << endl;
	}

};


int main()
{
	String s1{ "어떤 문자열이라도 저장하는 클래스 String" };

	cout << "모두 몇 글자? - " << s1.size() << endl;
	s1.show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-28 오후 12:00:23 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.28       (8주 2일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] main이 수정없이 실행되도록 class 코딩
struct String {
	size_t num;
	char* p;
	String(const char* str) {
		// str이 모두 몇 글자니?
		num = strlen(str);
		// Free Store에 글자수만큼 메모리를 요청
		p = new char[num];
		// 할당받은 메모리에 str의 내용을 복사한다.
		memcpy(p, str, num);
	}

	size_t size() {
		return num;
	}

	void show() {
		for (int i = 0; i < num; ++i)
			cout << p[i];
	}

};


int main()
{
	String s1{ "어떤 문자열이라도 저장하는 클래스 String" };

	cout << "모두 몇 글자? - " << s1.size() << endl;
	s1.show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-28 오후 12:00:44 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.28       (8주 2일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] main이 수정없이 실행되도록 class 코딩
struct String {
	size_t num;
	char* p;
	String(const char* str) {
		// str이 모두 몇 글자니?
		num = strlen(str);
		// Free Store에 글자수만큼 메모리를 요청
		p = new char[num];
		// 할당받은 메모리에 str의 내용을 복사한다.
		memcpy(p, str, num);
	}

	size_t size() const {
		return num;
	}

	void show() const {
		for (int i = 0; i < num; ++i)
			cout << p[i];
		cout << endl;
	}

};


int main()
{
	String s1{ "어떤 문자열이라도 저장하는 클래스 String" };

	cout << "모두 몇 글자? - " << s1.size() << endl;
	s1.show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-28 오후 12:01:58 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.28       (8주 2일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] main이 수정없이 실행되도록 class 코딩
struct String {
	size_t num;
	char* p;
	String(const char* str) {
		// str이 모두 몇 글자니?
		num = strlen(str);
		// Free Store에 글자수만큼 메모리를 요청
		p = new char[num];
		// 할당받은 메모리에 str의 내용을 복사한다.
		memcpy(p, str, num);
	}

	size_t size() const {
		return num;
	}

	void show() const {
		for (int i = 0; i < num; ++i)
			cout << p[i];
		cout << endl;
	}
	~String() {
		delete[] p;
	}

};


int main()
{
	String s1{ "어떤 문자열이라도 저장하는 클래스 String" };

	cout << "모두 몇 글자? - " << s1.size() << endl;
	s1.show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-28 오후 12:02:45 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.28       (8주 2일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] main이 수정없이 실행되도록 class 코딩
struct String {
	size_t num;
	char* p;
	String(const char* str) {
		// str이 모두 몇 글자니?
		num = strlen(str);
		// Free Store에 글자수만큼 메모리를 요청
		p = new char[num];
		// 할당받은 메모리에 str의 내용을 복사한다.
		memcpy(p, str, num);
	}

	size_t size() const {
		return num;
	}

	void show() const {
		for (int i = 0; i < num; ++i)
			cout << p[i];
		cout << endl;
	}
	~String() {
		delete[] p;
	}

};


int main()
{
	String s1{ "동해물과 백두산이 마르고 닳도록" };

	cout << "모두 몇 글자? - " << s1.size() << endl;
	s1.show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-28 오후 12:03:09 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.28       (8주 2일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] main이 수정없이 실행되도록 class 코딩
struct String {
	size_t num;
	char* p;
	String(const char* str) {
		// str이 모두 몇 글자니?
		num = strlen(str);
		// Free Store에 글자수만큼 메모리를 요청
		p = new char[num];
		// 할당받은 메모리에 str의 내용을 복사한다.
		memcpy(p, str, num);
	}

	size_t size() const {
		return num;
	}

	void show() const {
		for (int i = 0; i < num; ++i)
			cout << p[i];
		cout << endl;
	}
	~String() {
		delete[] p;
	}

};


int main()
{
	String s1{ "abcdefghijklmnopqrstuvwxyz" };

	cout << "모두 몇 글자? - " << s1.size() << endl;
	s1.show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-28 오후 12:03:19 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.28       (8주 2일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] main이 수정없이 실행되도록 class 코딩
struct String {
	size_t num;
	char* p;
	String(const char* str) {
		// str이 모두 몇 글자니?
		num = strlen(str);
		// Free Store에 글자수만큼 메모리를 요청
		p = new char[num];
		// 할당받은 메모리에 str의 내용을 복사한다.
		memcpy(p, str, num);
	}

	size_t size() const {
		return num;
	}

	void show() const {
		for (int i = 0; i < num; ++i)
			cout << p[i];
		cout << endl;
	}
	~String() {
		delete[] p;
	}

};


int main()
{
	String s1{ "abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz" };

	cout << "모두 몇 글자? - " << s1.size() << endl;
	s1.show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-28 오후 12:09:08 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.28       (8주 2일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] main이 수정없이 실행되도록 class 코딩
struct String {
	size_t num;
	char* p;
	String(const char* str) {
		// str이 모두 몇 글자니?
		num = strlen(str);
		// Free Store에 글자수만큼 메모리를 요청
		p = new char[num];
		// 할당받은 메모리에 str의 내용을 복사한다.
		memcpy(p, str, num);
	}

	size_t size() const {
		return num;
	}

	void show() const {
		for (int i = 0; i < num; ++i)
			cout << p[i];
		cout << endl;
	}

	~String() {
		delete[] p;
	}

};


int main()
{
	String s1{ "" };

	cout << "모두 몇 글자? - " << s1.size() << endl;
	s1.show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-28 오후 12:10:49 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.28       (8주 2일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] main이 수정없이 실행되도록 class 코딩
struct String {
	size_t num;
	char* p;
	String(const char* str) {
		// str이 모두 몇 글자니?
		num = strlen(str);
		// Free Store에 글자수만큼 메모리를 요청
		p = new char[num];
		// 할당받은 메모리에 str의 내용을 복사한다.
		memcpy(p, str, num);
	}

	size_t size() const {
		return num;
	}

	void show() const {
		//for (int i = 0; i < num; ++i)
		//	cout << p[i];
		//cout << endl;
		cout << p << endl;
	}

	~String() {
		delete[] p;
	}

};


int main()
{
	String s1{ "어떤 문자열이라도 저장하는 클래스 String" };

	cout << "모두 몇 글자? - " << s1.size() << endl;
	s1.show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-28 오후 12:13:13 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.28       (8주 2일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] main이 수정없이 실행되도록 class 코딩
struct String {
	size_t num;
	char* p;
	String(const char* str) {
		// str이 모두 몇 글자니?
		num = strlen(str);
		// Free Store에 글자수만큼 메모리를 요청
		p = new char[num];
		// 할당받은 메모리에 str의 내용을 복사한다.
		memcpy(p, str, num);
	}

	size_t size() const {
		return num;
	}

	void show() const {
		for (int i = 0; i < num; ++i)
			cout << p[i];
		cout << endl;
	}

	~String() {
		delete[] p;
	}

};


int main()
{
	String s1{ "어떤 문자열이라도 저장하는 클래스 String" };

	cout << "모두 몇 글자? - " << s1.size() << endl;
	s1.show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-28 오후 12:17:07 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.28       (8주 2일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] main이 수정없이 실행되도록 class 코딩

struct String {
	size_t num;
	char* p;
	String(const char* str) {
		// str이 모두 몇 글자니?
		num = strlen(str);
		// Free Store에 글자수만큼 메모리를 요청
		p = new char[num];
		// 할당받은 메모리에 str의 내용을 복사한다.
		memcpy(p, str, num);
	}

	~String() {
		delete[] p;
	}

	size_t size() const {
		return num;
	}

	void show() const {
		for (int i = 0; i < num; ++i)
			cout << p[i];
		cout << endl;
	}
};


int main()
{
	String s1{ "어떤 문자열이라도 저장하는 클래스 String호노롤로ㅗㄹㅇㄻㄶㅇㅁㄶㅇㄴggakljafklnfdklngfkldhnladfkjgklqjkdnbvnbvm,.bnlsk;jklgjqerklntkasjdklfajgklajgklnqrlkjoidjklfjkal;jhafkldjgklajkl" };

	cout << "모두 몇 글자? - " << s1.size() << endl;
	s1.show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-28 오후 12:19:17 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.28       (8주 2일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] main이 수정없이 실행되도록 class 코딩

struct String {
	size_t num;
	char* p;

	String(const char* str) {
		// str이 모두 몇 글자니?
		num = strlen(str);
		// Free Store에 글자수만큼 메모리를 요청
		p = new char[num];
		// 할당받은 메모리에 str의 내용을 복사한다.
		memcpy(p, str, num);
	}

	~String() {
		delete[] p;
	}

	size_t size() const {
		return num;
	}

	void show() const {
		for (int i = 0; i < num; ++i)
			cout << p[i];
		cout << endl;
	}
};


int main()
{
	String s1{ "어떤 문자열이라도 저장하는 클래스 String" };
	String s2 = s1;

	s1.show();
	s2.show();
	

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-28 오후 12:22:28 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.28       (8주 2일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] main이 수정없이 실행되도록 class 코딩

struct String {
	size_t num;
	char* p;

	String(const char* str) {
		// str이 모두 몇 글자니?
		num = strlen(str);
		// Free Store에 글자수만큼 메모리를 요청
		p = new char[num];
		// 할당받은 메모리에 str의 내용을 복사한다.
		memcpy(p, str, num);
	}

	String* operator=(const char* str);

	~String() {
		delete[] p;
	}

	size_t size() const {
		return num;
	}

	void show() const {
		for (int i = 0; i < num; ++i)
			cout << p[i];
		cout << endl;
	}
};


int main()
{
	String s1{ "어떤 문자열이라도 저장하는 클래스 String" };
	String s2 = s1;

	s1.show();
	s2.show();
	

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-28 오후 12:22:44 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.28       (8주 2일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] main이 수정없이 실행되도록 class 코딩

struct String {
	size_t num;
	char* p;

	String(const char* str) {
		// str이 모두 몇 글자니?
		num = strlen(str);
		// Free Store에 글자수만큼 메모리를 요청
		p = new char[num];
		// 할당받은 메모리에 str의 내용을 복사한다.
		memcpy(p, str, num);
	}

	String* operator=(const char* str) {
		// str이 모두 몇 글자니?
		num = strlen(str);
		// Free Store에 글자수만큼 메모리를 요청
		p = new char[num];
		// 할당받은 메모리에 str의 내용을 복사한다.
		memcpy(p, str, num);
	}

	~String() {
		delete[] p;
	}

	size_t size() const {
		return num;
	}

	void show() const {
		for (int i = 0; i < num; ++i)
			cout << p[i];
		cout << endl;
	}
};


int main()
{
	String s1{ "어떤 문자열이라도 저장하는 클래스 String" };
	String s2 = s1;

	s1.show();
	s2.show();
	

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-28 오후 12:23:06 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.28       (8주 2일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] main이 수정없이 실행되도록 class 코딩

struct String {
	size_t num;
	char* p;

	String(const char* str) {
		// str이 모두 몇 글자니?
		num = strlen(str);
		// Free Store에 글자수만큼 메모리를 요청
		p = new char[num];
		// 할당받은 메모리에 str의 내용을 복사한다.
		memcpy(p, str, num);
	}

	String* operator=(const char*& str) {
	}

	~String() {
		delete[] p;
	}

	size_t size() const {
		return num;
	}

	void show() const {
		for (int i = 0; i < num; ++i)
			cout << p[i];
		cout << endl;
	}
};


int main()
{
	String s1{ "어떤 문자열이라도 저장하는 클래스 String" };
	String s2 = s1;

	s1.show();
	s2.show();
	

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-28 오후 12:23:56 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.28       (8주 2일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] main이 수정없이 실행되도록 class 코딩

struct String {
	size_t num;
	char* p;

	String(const char* str) {
		// str이 모두 몇 글자니?
		num = strlen(str);
		// Free Store에 글자수만큼 메모리를 요청
		p = new char[num];
		// 할당받은 메모리에 str의 내용을 복사한다.
		memcpy(p, str, num);
	}

	String(const char*& str) {}

	~String() {
		delete[] p;
	}

	size_t size() const {
		return num;
	}

	void show() const {
		for (int i = 0; i < num; ++i)
			cout << p[i];
		cout << endl;
	}
};


int main()
{
	String s1{ "어떤 문자열이라도 저장하는 클래스 String" };
	String s2 = s1;

	s1.show();
	s2.show();
	

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-28 오후 12:27:38 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.28       (8주 2일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] main이 수정없이 실행되도록 class 코딩

struct String {
	size_t num;
	char* p;

	String(const char* str) {
		// str이 모두 몇 글자니?
		num = strlen(str);
		// Free Store에 글자수만큼 메모리를 요청
		p = new char[num];
		// 할당받은 메모리에 str의 내용을 복사한다.
		memcpy(p, str, num);
	}

	String(const String& str) : num{ str.num }, p{str.p} {}

	~String() {
		delete[] p;
	}

	size_t size() const {
		return num;
	}

	void show() const {
		for (int i = 0; i < num; ++i)
			cout << p[i];
		cout << endl;
	}
};


int main()
{
	String s1{ "어떤 문자열이라도 저장하는 클래스 String" };
	String s2 = s1;

	s1.show();
	s2.show();
	

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-28 오후 12:28:19 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.28       (8주 2일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] main이 수정없이 실행되도록 class 코딩

struct String {
	size_t num;
	char* p;

	String(const char* str) {
		// str이 모두 몇 글자니?
		num = strlen(str);
		// Free Store에 글자수만큼 메모리를 요청
		p = new char[num];
		// 할당받은 메모리에 str의 내용을 복사한다.
		memcpy(p, str, num);
	}

	String(const String& str) : num{ str.num }, p{str.p} {}

	~String() {
		delete[] p;
	}

	size_t size() const {
		return num;
	}

	void show() const {
		for (int i = 0; i < num; ++i)
			cout << p[i];
		cout << endl;
	}
};


int main()
{
	String s1{ "어떤 문자열이라도 저장하는 클래스 String" };
	String s2 = s1;

	s1.show();
	s2.show();
	
	cout << s2.size() << endl;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-28 오후 12:28:43 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.28       (8주 2일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] main이 수정없이 실행되도록 class 코딩

struct String {
	size_t num;
	char* p;

	String(const char* str) {
		// str이 모두 몇 글자니?
		num = strlen(str);
		// Free Store에 글자수만큼 메모리를 요청
		p = new char[num];
		// 할당받은 메모리에 str의 내용을 복사한다.
		memcpy(p, str, num);
	}

	String(const String& str) : num{ str.num }, p{str.p} {}

	~String() {
		delete[] p;
		cout << "소멸~" << endl;
	}

	size_t size() const {
		return num;
	}

	void show() const {
		for (int i = 0; i < num; ++i)
			cout << p[i];
		cout << endl;
	}
};


int main()
{
	String s1{ "어떤 문자열이라도 저장하는 클래스 String" };
	String s2 = s1;

	s1.show();
	s2.show();
	
	cout << s2.size() << endl;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-28 오후 12:42:43 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.28       (8주 2일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] main이 수정없이 실행되도록 class 코딩

struct String {
	size_t num;
	char* p;

	String(const char* str) {
		// str이 모두 몇 글자니?
		num = strlen(str);
		// Free Store에 글자수만큼 메모리를 요청
		p = new char[num];
		// 할당받은 메모리에 str의 내용을 복사한다.
		memcpy(p, str, num);
	}

	String(const String& str) : num{ str.num }, p{str.p} {
		cout << "잇힝" << endl;
	}

	~String() {
		delete[] p;
	}

	size_t size() const {
		return num;
	}

	void show() const {
		for (int i = 0; i < num; ++i)
			cout << p[i];
		cout << endl;
	}
};


int main()
{
	String s1{ "어떤 문자열이라도 저장하는 클래스 String" };
	String s2 = s1;

	s1.show();
	s2.show();
	
	cout << s2.size() << endl;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-28 오후 12:44:39 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.28       (8주 2일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] main이 수정없이 실행되도록 class 코딩

struct String {
	size_t num;
	char* p;

	String(const char* str) {
		// str이 모두 몇 글자니?
		num = strlen(str);
		// Free Store에 글자수만큼 메모리를 요청
		p = new char[num];
		// 할당받은 메모리에 str의 내용을 복사한다.
		memcpy(p, str, num);
	}

	String(const String& str) : num{ str.num }{}

	~String() {
		delete[] p;
	}

	size_t size() const {
		return num;
	}

	void show() const {
		for (int i = 0; i < num; ++i)
			cout << p[i];
		cout << endl;
	}
};


int main()
{
	String s1{ "어떤 문자열이라도 저장하는 클래스 String" };
	String s2 = s1;

	s1.show();
	s2.show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-28 오후 12:44:55 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.28       (8주 2일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] main이 수정없이 실행되도록 class 코딩

struct String {
	size_t num;
	char* p;

	String(const char* str) {
		// str이 모두 몇 글자니?
		num = strlen(str);
		// Free Store에 글자수만큼 메모리를 요청
		p = new char[num];
		// 할당받은 메모리에 str의 내용을 복사한다.
		memcpy(p, str, num);
	}

	String(const String& str) : num{ str.num }, p { str.p } {}

	~String() {
		delete[] p;
	}

	size_t size() const {
		return num;
	}

	void show() const {
		for (int i = 0; i < num; ++i)
			cout << p[i];
		cout << endl;
	}
};


int main()
{
	String s1{ "어떤 문자열이라도 저장하는 클래스 String" };
	String s2 = s1;

	s1.show();
	s2.show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-28 오후 12:45:24 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.28       (8주 2일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] main이 수정없이 실행되도록 class 코딩

struct String {
	size_t num;
	char* p;

	String(const char* str) {
		// str이 모두 몇 글자니?
		num = strlen(str);
		// Free Store에 글자수만큼 메모리를 요청
		p = new char[num];
		// 할당받은 메모리에 str의 내용을 복사한다.
		memcpy(p, str, num);
	}

	String(const String& str) : num{ str.num }, p { str.p } {}

	~String() {
		delete[] p;
	}

	size_t size() const {
		return num;
	}

	void show() const {
		for (int i = 0; i < num; ++i)
			cout << p[i];
		cout << endl;
	}
};


int main()
{
	String s1{ "어떤 문자열이라도 저장하는 클래스 String" };
	String s2 = s1;

	s1.show();
	s2.show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-28 오후 12:47:21 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.28       (8주 2일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] main이 수정없이 실행되도록 class 코딩

struct String {
	size_t num;
	char* p;

	String() {}

	String(const char* str) {
		// str이 모두 몇 글자니?
		num = strlen(str);
		// Free Store에 글자수만큼 메모리를 요청
		p = new char[num];
		// 할당받은 메모리에 str의 내용을 복사한다.
		memcpy(p, str, num);
	}

	String(const String& str) : num{ str.num }, p { str.p } {}

	~String() {
		delete[] p;
	}

	size_t size() const {
		return num;
	}

	void show() const {
		for (int i = 0; i < num; ++i)
			cout << p[i];
		cout << endl;
	}
};


int main()
{
	String s1{ "어떤 문자열이라도 저장하는 클래스 String" };
	String s2;
	s2 = s1;

	s1.show();
	s2.show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-28 오후 12:50:51 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.28       (8주 2일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] main이 수정없이 실행되도록 class 코딩

struct String {
	size_t num;
	char* p;

	String(const char* str) {
		// str이 모두 몇 글자니?
		num = strlen(str);
		// Free Store에 글자수만큼 메모리를 요청
		p = new char[num];
		// 할당받은 메모리에 str의 내용을 복사한다.
		memcpy(p, str, num);
	}

	String(const String& str) = default;

	~String() {
		delete[] p;
	}

	size_t size() const {
		return num;
	}

	void show() const {
		for (int i = 0; i < num; ++i)
			cout << p[i];
		cout << endl;
	}
};


int main()
{
	String s1{ "어떤 문자열이라도 저장하는 클래스 String" };
	String s2 = s1;

	s1.show();
	s2.show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-28 오후 12:51:41 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.28       (8주 2일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] main이 수정없이 실행되도록 class 코딩

struct String {
	size_t num;
	char* p;

	String(const char* str) {
		// str이 모두 몇 글자니?
		num = strlen(str);
		// Free Store에 글자수만큼 메모리를 요청
		p = new char[num];
		// 할당받은 메모리에 str의 내용을 복사한다.
		memcpy(p, str, num);
	}

	String(const String&) = default;

	~String() {
		delete[] p;
	}

	size_t size() const {
		return num;
	}

	void show() const {
		for (int i = 0; i < num; ++i)
			cout << p[i];
		cout << endl;
	}
};


int main()
{
	String s1{ "어떤 문자열이라도 저장하는 클래스 String" };
	String s2 = s1;

	s1.show();
	s2.show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-28 오후 12:54:41 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.28       (8주 2일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] main이 수정없이 실행되도록 class 코딩

struct String {
	size_t num;
	char* p;

	String(const char* str) {
		// str이 모두 몇 글자니?
		num = strlen(str);
		// Free Store에 글자수만큼 메모리를 요청
		p = new char[num];
		// 할당받은 메모리에 str의 내용을 복사한다.
		memcpy(p, str, num);
	}

	String(const String& str ) {
		num = str.num;
		p = new char[num];
		memcpy(p, str.p, num);
	}

	~String() {
		delete[] p;
	}

	size_t size() const {
		return num;
	}

	void show() const {
		for (int i = 0; i < num; ++i)
			cout << p[i];
		cout << endl;
	}
};


int main()
{
	String s1{ "어떤 문자열이라도 저장하는 클래스 String" };
	String s2{ s1 };	// 복사생성하는 순간 -> String( const String& )

	s1.show();
	s2.show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-28 오후 12:56:30 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.28       (8주 2일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] main이 수정없이 실행되도록 class 코딩

struct String {
	size_t num;
	char* p;

	String(const char* str) {
		num = strlen(str);
		p = new char[num];
		memcpy(p, str, num);
	}

	String(const String& other) : num{ other.num } {
		p = new char[num];
		memcpy(p, other.p, num);
	}

	~String() {
		delete[] p;
	}

	size_t size() const {
		return num;
	}

	void show() const {
		for (int i = 0; i < num; ++i)
			cout << p[i];
		cout << endl;
	}
};


int main()
{
	String s1{ "어떤 문자열이라도 저장하는 클래스 String" };
	String s2{ s1 };	// 복사생성하는 순간 -> String( const String& )

	s1.show();
	s2.show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-28 오후 12:57:22 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.28       (8주 2일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] main이 수정없이 실행되도록 class 코딩

struct String {
	size_t num;
	char* p;

	String() {}

	String(const char* str) {
		num = strlen(str);
		p = new char[num];
		memcpy(p, str, num);
	}

	String(const String& other) : num{ other.num } {
		p = new char[num];
		memcpy(p, other.p, num);
	}

	~String() {
		delete[] p;
	}

	size_t size() const {
		return num;
	}

	void show() const {
		for (int i = 0; i < num; ++i)
			cout << p[i];
		cout << endl;
	}
};


int main()
{
	String s1{ "어떤 문자열이라도 저장하는 클래스 String" };
	String s2;

	s2 = s1;

	s1.show();
	s2.show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-28 오후 12:58:47 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.28       (8주 2일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] main이 수정없이 실행되도록 class 코딩

struct String {
	size_t num;
	char* p;

	String() {}

	String(const char* str) {
		num = strlen(str);
		p = new char[num];
		memcpy(p, str, num);
	}

	String(const String& other) : num{ other.num } {
		p = new char[num];
		memcpy(p, other.p, num);
	}

	~String() {
		delete[] p;
	}

	size_t size() const {
		return num;
	}

	void show() const {
		for (int i = 0; i < num; ++i)
			cout << p[i];
		cout << endl;
	}
};


int main()
{
	String s1{ "어떤 문자열이라도 저장하는 클래스 String" };
	String s2;

	s2 = s1;

	s1.show();
	s2.show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-28 오후 12:59:17 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.28       (8주 2일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] main이 수정없이 실행되도록 class 코딩

struct String {
	size_t num;
	char* p;

	String() : num{}, p{} {}

	String(const char* str) {
		num = strlen(str);
		p = new char[num];
		memcpy(p, str, num);
	}

	String(const String& other) : num{ other.num } {
		p = new char[num];
		memcpy(p, other.p, num);
	}

	~String() {
		delete[] p;
	}

	size_t size() const {
		return num;
	}

	void show() const {
		for (int i = 0; i < num; ++i)
			cout << p[i];
		cout << endl;
	}
};


int main()
{
	String s1{ "어떤 문자열이라도 저장하는 클래스 String" };
	String s2;

	s2 = s1;

	s1.show();
	s2.show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-28 오후 1:01:26 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.28       (8주 2일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] main이 수정없이 실행되도록 class 코딩

struct String {
	size_t num;
	char* p;

	String() : num{}, p{} {}

	String(const char* str) {
		num = strlen(str);
		p = new char[num];
		memcpy(p, str, num);
	}

	String(const String& other) : num{ other.num } {
		p = new char[num];
		memcpy(p, other.p, num);
		cout << " 호놀룰루" << endl;
	}

	~String() {
		delete[] p;
	}

	size_t size() const {
		return num;
	}

	void show() const {
		for (int i = 0; i < num; ++i)
			cout << p[i];
		cout << endl;
	}
};


int main()
{
	String s1{ "어떤 문자열이라도 저장하는 클래스 String" };
	String s2;

	s2 = s1;

	s1.show();
	s2.show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-28 오후 1:04:18 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.28       (8주 2일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] main이 수정없이 실행되도록 class 코딩

struct String {
	size_t num;
	char* p;

	String() : num{}, p{} {cout << "I'm doing?" << endl; }

	String(const char* str) {
		num = strlen(str);
		p = new char[num];
		memcpy(p, str, num);
	}

	String(const String& other) : num{ other.num } {
		p = new char[num];
		memcpy(p, other.p, num);
	}

	String* operator=(const String& other) {
		num = other.num;
		p = new char[num];
		memcpy(p, other.p, num);
		cout << "복사대입" << endl;
		return this;
	}

	~String() {
		delete[] p;
	}

	size_t size() const {
		return num;
	}

	void show() const {
		for (int i = 0; i < num; ++i)
			cout << p[i];
		cout << endl;
	}
};


int main()
{
	String s1{ "어떤 문자열이라도 저장하는 클래스 String" };
	String s2;

	s2 = s1;

	s1.show();
	s2.show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-28 오후 1:05:31 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.28       (8주 2일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] main이 수정없이 실행되도록 class 코딩

struct String {
	size_t num;
	char* p;

	String() : num{}, p{} {cout << "I'm doing?" << endl; }

	String(const char* str) {
		num = strlen(str);
		p = new char[num];
		memcpy(p, str, num);
	}

	String(const String& other) : num{ other.num } {
		p = new char[num];
		memcpy(p, other.p, num);
	}

	String& operator=(const String& other) {
		num = other.num;
		p = new char[num];
		memcpy(p, other.p, num);
		cout << "복사대입" << endl;
		return *this;
	}

	~String() {
		delete[] p;
	}

	size_t size() const {
		return num;
	}

	void show() const {
		for (int i = 0; i < num; ++i)
			cout << p[i];
		cout << endl;
	}
};


int main()
{
	String s1{ "어떤 문자열이라도 저장하는 클래스 String" };
	String s2;

	s2 = s1;

	s1.show();
	s2.show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-28 오후 1:06:16 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.28       (8주 2일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] main이 수정없이 실행되도록 class 코딩

struct String {
	size_t num;
	char* p;

	String() : num{}, p{} {cout << "I'm doing?" << endl; }

	String(const char* str) {
		num = strlen(str);
		p = new char[num];
		memcpy(p, str, num);
	}

	String(const String& other) : num{ other.num } {
		p = new char[num];
		memcpy(p, other.p, num);
	}

	String& operator=(const String& other) {
		num = other.num;
		p = new char[num];
		memcpy(p, other.p, num);
		cout << "복사대입" << endl;
		return *this;
	}

	~String() {
		delete[] p;
	}

	size_t size() const {
		return num;
	}

	void show() const {
		for (int i = 0; i < num; ++i)
			cout << p[i];
		cout << endl;
	}
};


int main()
{
	String s1{ "어떤 문자열이라도 저장하는 클래스 String" };
	String s2;

	s2 = s1;

	s1.show();
	s2.show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-28 오후 1:07:21 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.28       (8주 2일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] main이 수정없이 실행되도록 class 코딩

struct String {
	size_t num;
	char* p;

	String() : num{}, p{} {cout << "I'm doing?" << endl; }

	String(const char* str) {
		num = strlen(str);
		p = new char[num];
		memcpy(p, str, num);
	}

	String(const String& other) : num{ other.num } {
		p = new char[num];
		memcpy(p, other.p, num);
	}

	String& operator=(const String& other) {
		num = other.num;
		p = new char[num];
		memcpy(p, other.p, num);
		cout << "복사대입" << endl;
		return *this;
	}

	~String() {
		delete[] p;
	}

	size_t size() const {
		return num;
	}

	void show() const {
		for (int i = 0; i < num; ++i)
			cout << p[i];
		cout << endl;
	}
};


int main()
{
	String s1{ "어떤 문자열이라도 저장하는 클래스 String" };
	String s2;

	s2 = s1;

	s1.show();
	s2.show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-28 오후 1:07:41 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.28       (8주 2일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] main이 수정없이 실행되도록 class 코딩

struct String {
	size_t num;
	char* p;

	String() = default;

	String(const char* str) {
		num = strlen(str);
		p = new char[num];
		memcpy(p, str, num);
	}

	String(const String& other) : num{ other.num } {
		p = new char[num];
		memcpy(p, other.p, num);
	}

	String& operator=(const String& other) {
		num = other.num;
		p = new char[num];
		memcpy(p, other.p, num);
		cout << "복사대입" << endl;
		return *this;
	}

	~String() {
		delete[] p;
	}

	size_t size() const {
		return num;
	}

	void show() const {
		for (int i = 0; i < num; ++i)
			cout << p[i];
		cout << endl;
	}
};


int main()
{
	String s1{ "어떤 문자열이라도 저장하는 클래스 String" };
	String s2;

	s2 = s1;

	s1.show();
	s2.show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-28 오후 1:08:25 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.28       (8주 2일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] main이 수정없이 실행되도록 class 코딩

struct String {
	size_t num;
	char* p;

	String() = default;

	String(const char* str) {
		num = strlen(str);
		p = new char[num];
		memcpy(p, str, num);
	}

	String(const String& other) : num{ other.num } {
		p = new char[num];
		memcpy(p, other.p, num);
	}

	String& operator=(const String& other) {
		num = other.num;
		p = new char[num];
		memcpy(p, other.p, num);
		return *this;
	}

	~String() {
		delete[] p;
	}

	size_t size() const {
		return num;
	}

	void show() const {
		for (int i = 0; i < num; ++i)
			cout << p[i];
		cout << endl;
	}
};


int main()
{
	String s1{ "어떤 문자열이라도 저장하는 클래스 String" };
	String s2{ " dgadgda " };

	s2.show();
	s2 = s1;

	s1.show();
	s2.show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-28 오후 1:10:38 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.28       (8주 2일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] main이 수정없이 실행되도록 class 코딩

struct String {
	size_t num;
	char* p;

	String() = default;

	String(const char* str) {
		num = strlen(str);
		p = new char[num];
		memcpy(p, str, num);
	}

	String(const String& other) : num{ other.num } {
		p = new char[num];
		memcpy(p, other.p, num);
	}

	String& operator=(const String& other) {
		delete[] p;
		num = other.num;
		p = new char[num];
		memcpy(p, other.p, num);
		return *this;
	}

	~String() {
		delete[] p;
	}

	size_t size() const {
		return num;
	}

	void show() const {
		for (int i = 0; i < num; ++i)
			cout << p[i];
		cout << endl;
	}
};


int main()
{
	String s1{ "어떤 문자열이라도 저장하는 클래스 String" };
	String s2{ " dgadgda " };

	s2 = s1;

	s1.show();
	s2.show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-28 오후 1:24:00 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.28       (8주 2일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] main이 수정없이 실행되도록 class 코딩

struct String {
	size_t num;
	char* p;

	String() = default;

	String(const char* str) {
		num = strlen(str);
		p = new char[num];
		memcpy(p, str, num);
		cout << "dd" << endl;
	}

	String(const String& other) : num{ other.num } {
		p = new char[num];
		memcpy(p, other.p, num);
	}

	String& operator=(const String& other) {
		this->~String();		// 이전의 나를 지운다.
		num = other.num;		// 
		p = new char[num];		// 메모리 할당
		memcpy(p, other.p, num); // 값을 복사
		return *this;			// 새로 탄생한 나를 리턴
	}

	~String() {
		delete[] p;
	}

	size_t size() const {
		return num;
	}

	void show() const {
		for (int i = 0; i < num; ++i)
			cout << p[i];
		cout << endl;
	}
};


int main()
{
	String s1{ "어떤 문자열이라도 저장하는 클래스 String" };
	//String s2;
	//String s3;

	//s3 = (s2 = s1);	// s3.operator=(s2.operator=( s1 ));
	//s3.operator=(s2.operator=(s1));
	
	s1.show();
	//s2.show();
	//s3.show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-28 오후 1:28:30 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.28       (8주 2일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] main이 수정없이 실행되도록 class 코딩

struct String {
	size_t num;
	char* p;

	String() { cout << "i'm doing?" << endl; }

	String(const char* str) {
		num = strlen(str);
		p = new char[num];
		memcpy(p, str, num);
	}

	String(const String& other) : num{ other.num } {
		p = new char[num];
		memcpy(p, other.p, num);
	}

	String& operator=(const String& other) {
		this->~String();		// 이전의 나를 지운다.
		num = other.num;		// 
		p = new char[num];		// 메모리 할당
		memcpy(p, other.p, num); // 값을 복사
		return *this;			// 새로 탄생한 나를 리턴
	}

	~String() {
		delete[] p;
		cout << " delete? " << endl;
	}

	size_t size() const {
		return num;
	}

	void show() const {
		for (int i = 0; i < num; ++i)
			cout << p[i];
		cout << endl;
	}
};


int main()
{
	String s1{ "어떤 문자열이라도 저장하는 클래스 String" };
	String s2 = s1;
	//String s3;

	//s3 = (s2 = s1);	// s3.operator=(s2.operator=( s1 ));
	//s3.operator=(s2.operator=(s1));
	
	s1.show();
	s2.show();
	//s3.show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-28 오후 1:29:03 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.28       (8주 2일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] main이 수정없이 실행되도록 class 코딩

struct String {
	size_t num;
	char* p;

	String() { cout << "i'm doing?" << endl; }

	String(const char* str) {
		num = strlen(str);
		p = new char[num];
		memcpy(p, str, num);
	}

	String(const String& other) : num{ other.num } {
		p = new char[num];
		memcpy(p, other.p, num);
		cout << " copy " << endl;
	}

	String& operator=(const String& other) {
		this->~String();		// 이전의 나를 지운다.
		num = other.num;		// 
		p = new char[num];		// 메모리 할당
		memcpy(p, other.p, num); // 값을 복사
		cout << "assignment" << endl;
		return *this;			// 새로 탄생한 나를 리턴
	}

	~String() {
		delete[] p;
		cout << " delete? " << endl;
	}

	size_t size() const {
		return num;
	}

	void show() const {
		for (int i = 0; i < num; ++i)
			cout << p[i];
		cout << endl;
	}
};


int main()
{
	String s1{ "어떤 문자열이라도 저장하는 클래스 String" };
	String s2 = s1;
	//String s3;

	//s3 = (s2 = s1);	// s3.operator=(s2.operator=( s1 ));
	//s3.operator=(s2.operator=(s1));
	
	s1.show();
	s2.show();
	//s3.show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-28 오후 1:31:07 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.28       (8주 2일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] main이 수정없이 실행되도록 class 코딩

struct String {
	size_t num;
	char* p;

	String() { cout << "i'm doing?" << endl; }

	String(const char* str) {
		num = strlen(str);
		p = new char[num];
		memcpy(p, str, num);
	}

	String(const String& other) : num{ other.num } {
		p = new char[num];
		memcpy(p, other.p, num);
		cout << " copy " << endl;
	}

	String& operator=(const String& other) {
		//delete[] p;		// 이전의 나를 지운다.
		num = other.num;		// 
		p = new char[num];		// 메모리 할당
		memcpy(p, other.p, num); // 값을 복사
		cout << "assignment" << endl;
		return *this;			// 새로 탄생한 나를 리턴
	}

	~String() {
		delete[] p;
		cout << " delete? " << endl;
	}

	size_t size() const {
		return num;
	}

	void show() const {
		for (int i = 0; i < num; ++i)
			cout << p[i];
		cout << endl;
	}
};


int main()
{
	String s1{ "어떤 문자열이라도 저장하는 클래스 String" };
	String s2;
	//String s3;

	s2 = s1;

	//s3 = (s2 = s1);	// s3.operator=(s2.operator=( s1 ));
	//s3.operator=(s2.operator=(s1));
	
	s1.show();
	s2.show();
	//s3.show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-28 오후 1:31:33 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.28       (8주 2일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] main이 수정없이 실행되도록 class 코딩

struct String {
	size_t num;
	char* p;

	String() = default;

	String(const char* str) {
		num = strlen(str);
		p = new char[num];
		memcpy(p, str, num);
	}

	String(const String& other) : num{ other.num } {
		p = new char[num];
		memcpy(p, other.p, num);
		cout << " copy " << endl;
	}

	String& operator=(const String& other) {
		//delete[] p;		// 이전의 나를 지운다.
		num = other.num;		// 
		p = new char[num];		// 메모리 할당
		memcpy(p, other.p, num); // 값을 복사
		cout << "assignment" << endl;
		return *this;			// 새로 탄생한 나를 리턴
	}

	~String() {
		delete[] p;
		cout << " delete? " << endl;
	}

	size_t size() const {
		return num;
	}

	void show() const {
		for (int i = 0; i < num; ++i)
			cout << p[i];
		cout << endl;
	}
};


int main()
{
	String s1{ "어떤 문자열이라도 저장하는 클래스 String" };
	String s2;
	//String s3;

	s2 = s1;

	//s3 = (s2 = s1);	// s3.operator=(s2.operator=( s1 ));
	//s3.operator=(s2.operator=(s1));
	
	s1.show();
	s2.show();
	//s3.show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-10-28 오후 1:34:13 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.28       (8주 2일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] main이 수정없이 실행되도록 class 코딩

struct String {
	size_t num;
	char* p;

	String() : num{}, p{} {}

	String(const char* str) {
		num = strlen(str);
		p = new char[num];
		memcpy(p, str, num);
	}

	String(const String& other) : num{ other.num } {
		p = new char[num];
		memcpy(p, other.p, num);
		cout << " copy " << endl;
	}

	String& operator=(const String& other) {
		this->~String();		// 이전의 나를 지운다.
		num = other.num;		// 
		p = new char[num];		// 메모리 할당
		memcpy(p, other.p, num); // 값을 복사
		cout << "assignment" << endl;
		return *this;			// 새로 탄생한 나를 리턴
	}

	~String() {
		delete[] p;
		cout << " delete? " << endl;
	}

	size_t size() const {
		return num;
	}

	void show() const {
		for (int i = 0; i < num; ++i)
			cout << p[i];
		cout << endl;
	}
};


int main()
{
	String s1{ "어떤 문자열이라도 저장하는 클래스 String" };
	String s2;
	//String s3;

	s2 = s1;

	//s3 = (s2 = s1);	// s3.operator=(s2.operator=( s1 ));
	//s3.operator=(s2.operator=(s1));
	
	s1.show();
	s2.show();
	//s3.show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-01 오후 8:39:20 - (일요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.28       (8주 2일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] main이 수정없이 실행되도록 class 코딩

struct String {
	size_t num{};
	char* p{};

	String() {}

	String(const char* str) {
		num = strlen(str);
		p = new char[num];
		memcpy(p, str, num);
	}

	String(const String& other) : num{ other.num } {
		p = new char[num];
		memcpy(p, other.p, num);
		cout << " copy " << endl;
	}

	String& operator=(const String& other) {
		this->~String();		// 이전의 나를 지운다.
		num = other.num;		// 
		p = new char[num];		// 메모리 할당
		memcpy(p, other.p, num); // 값을 복사
		cout << "assignment" << endl;
		return *this;			// 새로 탄생한 나를 리턴
	}

	~String() {
		delete[] p;
		cout << " delete? " << endl;
	}

	size_t size() const {
		return num;
	}

	void show() const {
		for (int i = 0; i < num; ++i)
			cout << p[i];
		cout << endl;
	}
};


int main()
{
	String s1{ "어떤 문자열이라도 저장하는 클래스 String" };
	String s2;
	//String s3;

	s2 = s1;

	//s3 = (s2 = s1);	// s3.operator=(s2.operator=( s1 ));
	//s3.operator=(s2.operator=(s1));
	
	s1.show();
	s2.show();
	//s3.show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-01 오후 8:39:38 - (일요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.28       (8주 2일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] main이 수정없이 실행되도록 class 코딩

struct String {
	size_t num{};
	char* p{};

	String() = default;

	String(const char* str) {
		num = strlen(str);
		p = new char[num];
		memcpy(p, str, num);
	}

	String(const String& other) : num{ other.num } {
		p = new char[num];
		memcpy(p, other.p, num);
		cout << " copy " << endl;
	}

	String& operator=(const String& other) {
		this->~String();		// 이전의 나를 지운다.
		num = other.num;		// 
		p = new char[num];		// 메모리 할당
		memcpy(p, other.p, num); // 값을 복사
		cout << "assignment" << endl;
		return *this;			// 새로 탄생한 나를 리턴
	}

	~String() {
		delete[] p;
		cout << " delete? " << endl;
	}

	size_t size() const {
		return num;
	}

	void show() const {
		for (int i = 0; i < num; ++i)
			cout << p[i];
		cout << endl;
	}
};


int main()
{
	String s1{ "어떤 문자열이라도 저장하는 클래스 String" };
	String s2;
	//String s3;

	s2 = s1;

	//s3 = (s2 = s1);	// s3.operator=(s2.operator=( s1 ));
	//s3.operator=(s2.operator=(s1));
	
	s1.show();
	s2.show();
	//s3.show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-02 오후 1:24:35 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             10.28       (8주 2일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] main이 수정없이 실행되도록 class 코딩

struct String {
	size_t num{};
	char* p{};

	String() = default;

	String(const char* str) {
		num = strlen(str);
		p = new char[num];
		memcpy(p, str, num);
	}

	String(const String& other) : num{ other.num } {
		p = new char[num];
		memcpy(p, other.p, num);
		cout << " copy " << endl;
	}

	String& operator=(const String& other) {
		this->~String();		// 이전의 나를 지운다.
		num = other.num;		// 
		p = new char[num];		// 메모리 할당
		memcpy(p, other.p, num); // 값을 복사
		cout << "assignment" << endl;
		return *this;			// 새로 탄생한 나를 리턴
	}

	~String() {
		delete[] p;
		cout << " delete? " << endl;
	}

	size_t size() const {
		return num;
	}

	void show() const {
		for (int i = 0; i < num; ++i)
			cout << p[i];
		cout << endl;
	}
};


int main()
{
	String s1{ "어떤 문자열이라도 저장하는 클래스 String" };
	String s2;
	String s3;

	s2 = s1;

	s3 = (s2 = s1);	// s3.operator=(s2.operator=( s1 ));
	//s3.operator=(s2.operator=(s1));
	
	s1.show();
	s2.show();
	s3.show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-02 오후 1:25:48 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.2        (9주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] main이 수정없이 실행되도록 class 코딩

struct String {
	size_t num{};
	char* p{};

	String() = default;

	String(const char* str) {
		num = strlen(str);
		p = new char[num];
		memcpy(p, str, num);
	}

	String(const String& other) : num{ other.num } {
		p = new char[num];
		memcpy(p, other.p, num);
	}

	String& operator=(const String& other) {
		this->~String();		// 이전의 나를 지운다.
		num = other.num;		// 
		p = new char[num];		// 메모리 할당
		memcpy(p, other.p, num); // 값을 복사
		return *this;			// 새로 탄생한 나를 리턴
	}

	~String() {
		delete[] p;
	}

	size_t size() const {
		return num;
	}

	void show() const {
		for (int i = 0; i < num; ++i)
			cout << p[i];
		cout << endl;
	}
};


int main()
{
	String s1{ "어떤 문자열이라도 저장하는 클래스 String" };
	String s2;
	String s3;

	s2 = s1;

	s3 = (s2 = s1);	// s3.operator=(s2.operator=( s1 ));
	//s3.operator=(s2.operator=(s1));
	
	s1.show();
	s2.show();
	s3.show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-02 오후 1:35:51 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.2        (9주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] main이 수정없이 실행되도록 class 코딩

struct String {
	size_t num{};
	char* p{};

	String() = default;

	String(const char* str) {
		num = strlen(str);
		p = new char[num];
		memcpy(p, str, num);
	}

	~String() {
		delete[] p;
	}

	String(const String& other) : num{ other.num } {
		p = new char[num];
		memcpy(p, other.p, num);
	}

	String& operator=(const String& other) {
		this->~String();		// 이전의 나를 지운다.
		num = other.num;		// 
		p = new char[num];		// 메모리 할당
		memcpy(p, other.p, num); // 값을 복사

		return *this;			// 새로 탄생한 나를 리턴
	}

	size_t size() const {
		return num;
	}

	void show() const {
		for (int i = 0; i < num; ++i)
			cout << p[i];
		cout << endl;
	}
};


int main()
{
	String s1{ "어떤 문자열이라도 저장하는 클래스 String" };
	String s2;
	String s3{};

	s2 = s1;

	//s3 = (s2 = s1);	// s3.operator=(s2.operator=( s1 ));
	s3.operator=(s2.operator=(s1));
	
	s1.show();
	s2.show();
	s3.show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-02 오후 1:36:56 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.2        (9주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] main이 수정없이 실행되도록 class 코딩

struct String {
	size_t num{};
	char* p{};

	String() = default;

	String(const char* str) {
		num = strlen(str);
		p = new char[num];
		memcpy(p, str, num);
	}

	~String() {
		delete[] p;
	}

	String(const String& other) : num{ other.num } {
		p = new char[num];
		memcpy(p, other.p, num);
	}

	String& operator=(const String& other) {
		this->~String();		// 이전의 나를 지운다.
		num = other.num;		// 
		p = new char[num];		// 메모리 할당
		memcpy(p, other.p, num); // 값을 복사

		return *this;			// 새로 탄생한 나를 리턴
	}

	size_t size() const {
		return num;
	}

	void show() const {
		for (int i = 0; i < num; ++i)
			cout << p[i];
		cout << endl;
	}
};


int main()
{
	String s1{ "시험해 봅니다" };
	s1.show();

	s1 = s1;
	s1.show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-02 오후 1:37:41 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.2        (9주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] main이 수정없이 실행되도록 class 코딩

struct String {
	size_t num{};
	char* p{};

	String() = default;

	String(const char* str) {
		num = strlen(str);
		p = new char[num];
		memcpy(p, str, num);
	}

	~String() {
		delete[] p;
		cout << "del" << endl;
	}

	String(const String& other) : num{ other.num } {
		p = new char[num];
		memcpy(p, other.p, num);
	}

	String& operator=(const String& other) {
		this->~String();		// 이전의 나를 지운다.
		num = other.num;		// 
		p = new char[num];		// 메모리 할당
		memcpy(p, other.p, num); // 값을 복사

		return *this;			// 새로 탄생한 나를 리턴
	}

	size_t size() const {
		return num;
	}

	void show() const {
		for (int i = 0; i < num; ++i)
			cout << p[i];
		cout << endl;
	}
};


int main()
{
	String s1{ "시험해 봅니다" };
	s1.show();

	s1 = s1;
	s1.show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-02 오후 1:38:12 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.2        (9주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] main이 수정없이 실행되도록 class 코딩

struct String {
	size_t num{};
	char* p{};

	String() = default;

	String(const char* str) {
		num = strlen(str);
		p = new char[num];
		memcpy(p, str, num);
	}

	~String() {
		delete[] p;
		cout << "del" << endl;
	}

	String(const String& other) : num{ other.num } {
		p = new char[num];
		memcpy(p, other.p, num);
	}

	String& operator=(const String& other) {
		this->~String();		// 이전의 나를 지운다.
		cout << "낄낄낄" << endl;
		num = other.num;		// 
		p = new char[num];		// 메모리 할당
		memcpy(p, other.p, num); // 값을 복사

		return *this;			// 새로 탄생한 나를 리턴
	}

	size_t size() const {
		return num;
	}

	void show() const {
		for (int i = 0; i < num; ++i)
			cout << p[i];
		cout << endl;
	}
};


int main()
{
	String s1{ "시험해 봅니다" };
	s1.show();

	s1 = s1;
	s1.show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-02 오후 1:38:30 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.2        (9주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] main이 수정없이 실행되도록 class 코딩

struct String {
	size_t num{};
	char* p{};

	String() = default;

	String(const char* str) {
		num = strlen(str);
		p = new char[num];
		memcpy(p, str, num);
	}

	~String() {
		delete[] p;
		cout << "del" << endl;
	}

	String(const String& other) : num{ other.num } {
		p = new char[num];
		memcpy(p, other.p, num);
	}

	String& operator=(const String& other) {
		this->~String();		// 이전의 나를 지운다.
		cout << "낄낄낄" << endl;
		num = other.num;		//
		cout << num << endl;
		p = new char[num];		// 메모리 할당
		memcpy(p, other.p, num); // 값을 복사

		return *this;			// 새로 탄생한 나를 리턴
	}

	size_t size() const {
		return num;
	}

	void show() const {
		for (int i = 0; i < num; ++i)
			cout << p[i];
		cout << endl;
	}
};


int main()
{
	String s1{ "시험해 봅니다" };
	s1.show();

	s1 = s1;
	s1.show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-02 오후 1:49:52 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.2        (9주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] main이 수정없이 실행되도록 class 코딩

struct String {
	size_t num{};
	char* p{};

	String() = default;

	String(const char* str) {
		num = strlen(str);
		p = new char[num];
		memcpy(p, str, num);
	}

	~String() {
		delete[] p;
	}

	String(const String& other) : num{ other.num } {
		p = new char[num];
		memcpy(p, other.p, num);
	}

	String& operator=(const String& other) {
		// 나를 나에게 대입하려는 시도를 방지한다
		if (this == &other)
			return *this;
		
		this->~String();		// 이전의 나를 지운다.
		num = other.num;		//
		p = new char[num];		// 메모리 할당
		memcpy(p, other.p, num); // 값을 복사

		return *this;			// 새로 탄생한 나를 리턴
	}

	size_t size() const {
		return num;
	}

	void show() const {
		for (int i = 0; i < num; ++i)
			cout << p[i];
		cout << endl;
	}
};

int main()
{
	String s1{ "시험해 봅니다" };
	s1.show();

	s1 = s1;		// s1.operator=( const String& other )

	s1.show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-02 오후 1:57:02 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.2        (9주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] main이 수정없이 실행되도록 class 코딩

struct String {
	size_t num{};
	char* p{};

	String() = default;

	String(const char* str) {
		num = strlen(str);
		p = new char[num];
		memcpy(p, str, num);
	}

	~String() {
		delete[] p;
	}

	String(const String& other) : num{ other.num } {
		p = new char[num];
		memcpy(p, other.p, num);
	}

	String& operator=(const String& other) {
		// 나를 나에게 대입하려는 시도를 방지한다
		if (this == &other)
			return *this;
		
		this->~String();		// 이전의 나를 지운다.
		num = other.num;		//
		p = new char[num];		// 메모리 할당
		memcpy(p, other.p, num); // 값을 복사

		return *this;			// 새로 탄생한 나를 리턴
	}

	size_t size() const {
		return num;
	}

	void show() const {
		cout << (void*)p << " --> ";
		for (int i = 0; i < num; ++i)
			cout << p[i];
		cout << endl;
	}
};

int main()
{
	String str{ "0123456789" };
	str.show();

	str.num = 5;
	str.show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-02 오후 1:57:22 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.2        (9주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] main이 수정없이 실행되도록 class 코딩

struct String {
	size_t num{};
	char* p{};

	String() = default;

	String(const char* str) {
		num = strlen(str);
		p = new char[num];
		memcpy(p, str, num);
	}

	~String() {
		delete[] p;
	}

	String(const String& other) : num{ other.num } {
		p = new char[num];
		memcpy(p, other.p, num);
	}

	String& operator=(const String& other) {
		// 나를 나에게 대입하려는 시도를 방지한다
		if (this == &other)
			return *this;
		
		this->~String();		// 이전의 나를 지운다.
		num = other.num;		//
		p = new char[num];		// 메모리 할당
		memcpy(p, other.p, num); // 값을 복사

		return *this;			// 새로 탄생한 나를 리턴
	}

	size_t size() const {
		return num;
	}

	void show() const {
		cout << (void*)p << " --> ";
		for (int i = 0; i < num; ++i)
			cout << p[i];
		cout << endl;
	}
};

int main()
{
	String str{ "0123456789" };
	str.show();

	str.num = 500;
	str.show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-02 오후 1:57:52 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.2        (9주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] main이 수정없이 실행되도록 class 코딩

struct String {
	size_t num{};
	char* p{};

	String() = default;

	String(const char* str) {
		num = strlen(str);
		p = new char[num];
		memcpy(p, str, num);
	}

	~String() {
		delete[] p;
	}

	String(const String& other) : num{ other.num } {
		p = new char[num];
		memcpy(p, other.p, num);
	}

	String& operator=(const String& other) {
		// 나를 나에게 대입하려는 시도를 방지한다
		if (this == &other)
			return *this;
		
		this->~String();		// 이전의 나를 지운다.
		num = other.num;		//
		p = new char[num];		// 메모리 할당
		memcpy(p, other.p, num); // 값을 복사

		return *this;			// 새로 탄생한 나를 리턴
	}

	size_t size() const {
		return num;
	}

	void show() const {
		cout << (void*)p << " --> ";
		for (int i = 0; i < num; ++i)
			cout << p[i];
		cout << endl;
	}
};

int main()
{
	String str{ "0123456789" };
	str.show();

	str.p += 3;
	str.show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-02 오후 1:58:44 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.2        (9주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] main이 수정없이 실행되도록 class 코딩

struct String {
	size_t num{};
	char* p{};

	String() = default;

	String(const char* str) {
		num = strlen(str);
		p = new char[num];
		memcpy(p, str, num);
	}

	~String() {
		cout << (void*)p << " 소멸" << endl;
		delete[] p;
	}

	String(const String& other) : num{ other.num } {
		p = new char[num];
		memcpy(p, other.p, num);
	}

	String& operator=(const String& other) {
		// 나를 나에게 대입하려는 시도를 방지한다
		if (this == &other)
			return *this;
		
		this->~String();		// 이전의 나를 지운다.
		num = other.num;		//
		p = new char[num];		// 메모리 할당
		memcpy(p, other.p, num); // 값을 복사

		return *this;			// 새로 탄생한 나를 리턴
	}

	size_t size() const {
		return num;
	}

	void show() const {
		cout << (void*)p << " --> ";
		for (int i = 0; i < num; ++i)
			cout << p[i];
		cout << endl;
	}
};

int main()
{
	String str{ "0123456789" };
	str.show();

	str.p += 3;
	str.show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-02 오후 2:01:16 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.2        (9주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] main이 수정없이 실행되도록 class 코딩

class String {
private:
	size_t num{};
	char* p{};

public:
	String() = default;

	String(const char* str) {
		num = strlen(str);
		p = new char[num];
		memcpy(p, str, num);
	}

	~String() {
		cout << (void*)p << " 소멸" << endl;
		delete[] p;
	}

	String(const String& other) : num{ other.num } {
		p = new char[num];
		memcpy(p, other.p, num);
	}

	String& operator=(const String& other) {
		// 나를 나에게 대입하려는 시도를 방지한다
		if (this == &other)
			return *this;
		
		this->~String();		// 이전의 나를 지운다.
		num = other.num;		//
		p = new char[num];		// 메모리 할당
		memcpy(p, other.p, num); // 값을 복사

		return *this;			// 새로 탄생한 나를 리턴
	}

	size_t size() const {
		return num;
	}

	void show() const {
		cout << (void*)p << " --> ";
		for (int i = 0; i < num; ++i)
			cout << p[i];
		cout << endl;
	}
};

int main()
{
	String str{ "0123456789" };
	str.show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-02 오후 2:02:17 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.2        (9주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] main이 수정없이 실행되도록 class 코딩

struct String {
private:
	size_t num{};
	char* p{};

public:
	String() = default;

	String(const char* str) {
		num = strlen(str);
		p = new char[num];
		memcpy(p, str, num);
	}

	~String() {
		cout << (void*)p << " 소멸" << endl;
		delete[] p;
	}

	String(const String& other) : num{ other.num } {
		p = new char[num];
		memcpy(p, other.p, num);
	}

	String& operator=(const String& other) {
		// 나를 나에게 대입하려는 시도를 방지한다
		if (this == &other)
			return *this;
		
		this->~String();		// 이전의 나를 지운다.
		num = other.num;		//
		p = new char[num];		// 메모리 할당
		memcpy(p, other.p, num); // 값을 복사

		return *this;			// 새로 탄생한 나를 리턴
	}

	size_t size() const {
		return num;
	}

	void show() const {
		cout << (void*)p << " --> ";
		for (int i = 0; i < num; ++i)
			cout << p[i];
		cout << endl;
	}
};

int main()
{
	String str{ "0123456789" };
	str.show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-02 오후 2:14:15 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.2        (9주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <random>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] main이 수정없이 실행되도록 class 코딩

default_random_engine dre;
uniform_int_distribution<> uid{ 1, 50 };
//uniform_int_distribution<char> ucd{ 'a', 'z' };

class String {
	size_t num{};
	char* p{};

public:
	String() {
		num = uid(dre);
		p = new char[num];
		//for (int i = 0; i < num; ++i)
			//p[i] = ucd(dre);
	}

	String(const char* str) {
		num = strlen(str);
		p = new char[num];
		memcpy(p, str, num);
	}

	~String() {
		cout << (void*)p << " 소멸" << endl;
		delete[] p;
	}

	String(const String& other) : num{ other.num } {
		p = new char[num];
		memcpy(p, other.p, num);
	}

	String& operator=(const String& other) {
		// 나를 나에게 대입하려는 시도를 방지한다
		if (this == &other)
			return *this;
		
		this->~String();		// 이전의 나를 지운다.
		num = other.num;		//
		p = new char[num];		// 메모리 할당
		memcpy(p, other.p, num); // 값을 복사

		return *this;			// 새로 탄생한 나를 리턴
	}

	size_t size() const {
		return num;
	}

	void show() const {
		cout << (void*)p << " --> ";
		for (int i = 0; i < num; ++i)
			cout << p[i];
		cout << endl;
	}
};

// [문제] String을 정렬하려 한다.
// String 객체 30개를 임의의 글자수[1~50]와 임의의 문자[a~z]로 만들어라.
// sort로 num기준 오름차순 정렬하자


int main()
{
	String str[30];

	for (String s : str)
		s.show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-02 오후 2:15:06 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.2        (9주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <random>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] main이 수정없이 실행되도록 class 코딩

default_random_engine dre;
uniform_int_distribution<> uid{ 1, 50 };
uniform_int_distribution<> ucd{ 96, 121 };

class String {
	size_t num{};
	char* p{};

public:
	String() {
		num = uid(dre);
		p = new char[num];
		for (int i = 0; i < num; ++i)
			p[i] = ucd(dre);
	}

	String(const char* str) {
		num = strlen(str);
		p = new char[num];
		memcpy(p, str, num);
	}

	~String() {
		cout << (void*)p << " 소멸" << endl;
		delete[] p;
	}

	String(const String& other) : num{ other.num } {
		p = new char[num];
		memcpy(p, other.p, num);
	}

	String& operator=(const String& other) {
		// 나를 나에게 대입하려는 시도를 방지한다
		if (this == &other)
			return *this;
		
		this->~String();		// 이전의 나를 지운다.
		num = other.num;		//
		p = new char[num];		// 메모리 할당
		memcpy(p, other.p, num); // 값을 복사

		return *this;			// 새로 탄생한 나를 리턴
	}

	size_t size() const {
		return num;
	}

	void show() const {
		cout << (void*)p << " --> ";
		for (int i = 0; i < num; ++i)
			cout << p[i];
		cout << endl;
	}
};

// [문제] String을 정렬하려 한다.
// String 객체 30개를 임의의 글자수[1~50]와 임의의 문자[a~z]로 만들어라.
// sort로 num기준 오름차순 정렬하자


int main()
{
	String str[30];

	for (String s : str)
		s.show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-02 오후 2:17:20 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.2        (9주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <random>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] main이 수정없이 실행되도록 class 코딩

default_random_engine dre;
uniform_int_distribution<> uid{ 1, 50 };
uniform_int_distribution<> ucd{ 96, 121 };

class String {
	size_t num{};
	char* p{};

public:
	String() {
		num = uid(dre);
		p = new char[num];
		for (int i = 0; i < num; ++i)
			p[i] = ucd(dre);
	}

	String(const char* str) {
		num = strlen(str);
		p = new char[num];
		memcpy(p, str, num);
	}

	~String() {
		cout << (void*)p << " 소멸" << endl;
		delete[] p;
	}

	String(const String& other) : num{ other.num } {
		p = new char[num];
		memcpy(p, other.p, num);
	}

	String& operator=(const String& other) {
		// 나를 나에게 대입하려는 시도를 방지한다
		if (this == &other)
			return *this;
		
		this->~String();		// 이전의 나를 지운다.
		num = other.num;		//
		p = new char[num];		// 메모리 할당
		memcpy(p, other.p, num); // 값을 복사

		return *this;			// 새로 탄생한 나를 리턴
	}

	size_t size() const {
		return num;
	}

	void show() const {
		for (int i = 0; i < num; ++i)
			cout << p[i];
		cout << endl;
	}
};

// [문제] String을 정렬하려 한다.
// String 객체 30개를 임의의 글자수[1~50]와 임의의 문자[a~z]로 만들어라.
// sort로 num기준 오름차순 정렬하자


int main()
{
	String str[30];

	sort(begin(str), end(str), [](String str1, String str2) {
		return str1.size() < str2.size();
		});
	
	for (String s : str)
		s.show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-02 오후 2:17:59 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.2        (9주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <random>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] main이 수정없이 실행되도록 class 코딩

default_random_engine dre;
uniform_int_distribution<> uid{ 1, 50 };
uniform_int_distribution<> ucd{ 96, 121 };

class String {
	size_t num{};
	char* p{};

public:
	String() {
		num = uid(dre);
		p = new char[num];
		for (int i = 0; i < num; ++i)
			p[i] = ucd(dre);
	}

	String(const char* str) {
		num = strlen(str);
		p = new char[num];
		memcpy(p, str, num);
	}

	~String() {
		cout << (void*)p << " 소멸" << endl;
		delete[] p;
	}

	String(const String& other) : num{ other.num } {
		p = new char[num];
		memcpy(p, other.p, num);
	}

	String& operator=(const String& other) {
		// 나를 나에게 대입하려는 시도를 방지한다
		if (this == &other)
			return *this;
		
		this->~String();		// 이전의 나를 지운다.
		num = other.num;		//
		p = new char[num];		// 메모리 할당
		memcpy(p, other.p, num); // 값을 복사

		return *this;			// 새로 탄생한 나를 리턴
	}

	size_t size() const {
		return num;
	}

	void show() const {
		for (int i = 0; i < num; ++i)
			cout << p[i];
		cout << endl;
	}
};

// [문제] String을 정렬하려 한다.
// String 객체 30개를 임의의 글자수[1~50]와 임의의 문자[a~z]로 만들어라.
// sort로 num기준 오름차순 정렬하자


int main()
{
	String str[30];

	sort(begin(str), end(str), [](const String& str1, const String& str2) {
		return str1.size() < str2.size();
		});
	
	for (const String& s : str)
		s.show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-02 오후 2:19:15 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.2        (9주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <random>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] main이 수정없이 실행되도록 class 코딩

default_random_engine dre;
uniform_int_distribution<> uid{ 1, 50 };
uniform_int_distribution<> ucd{ 96, 120 };

class String {
	size_t num{};
	char* p{};

public:
	String() {
		num = uid(dre);
		p = new char[num];
		for (int i = 0; i < num; ++i)
			p[i] = ucd(dre);
	}

	String(const char* str) {
		num = strlen(str);
		p = new char[num];
		memcpy(p, str, num);
	}

	~String() {
		cout << (void*)p << " 소멸" << endl;
		delete[] p;
	}

	String(const String& other) : num{ other.num } {
		p = new char[num];
		memcpy(p, other.p, num);
	}

	String& operator=(const String& other) {
		// 나를 나에게 대입하려는 시도를 방지한다
		if (this == &other)
			return *this;
		
		this->~String();		// 이전의 나를 지운다.
		num = other.num;		//
		p = new char[num];		// 메모리 할당
		memcpy(p, other.p, num); // 값을 복사

		return *this;			// 새로 탄생한 나를 리턴
	}

	size_t size() const {
		return num;
	}

	void show() const {
		for (int i = 0; i < num; ++i)
			cout << p[i];
		cout << endl;
	}
};

// [문제] String을 정렬하려 한다.
// String 객체 30개를 임의의 글자수[1~50]와 임의의 문자[a~z]로 만들어라.
// sort로 num기준 오름차순 정렬하자


int main()
{
	String str[30];

	sort(begin(str), end(str), [](const String& str1, const String& str2) {
		return str1.size() < str2.size();
		cout << " done " << endl;
		});
	
	for (const String& s : str)
		s.show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-02 오후 2:20:10 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.2        (9주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <random>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] main이 수정없이 실행되도록 class 코딩

default_random_engine dre;
uniform_int_distribution<> uid{ 1, 50 };
uniform_int_distribution<> ucd{ 97, 122 };

class String {
	size_t num{};
	char* p{};

public:
	String() {
		num = uid(dre);
		p = new char[num];
		for (int i = 0; i < num; ++i)
			p[i] = ucd(dre);
	}

	String(const char* str) {
		num = strlen(str);
		p = new char[num];
		memcpy(p, str, num);
	}

	~String() {
		cout << (void*)p << " 소멸" << endl;
		delete[] p;
	}

	String(const String& other) : num{ other.num } {
		p = new char[num];
		memcpy(p, other.p, num);
	}

	String& operator=(const String& other) {
		// 나를 나에게 대입하려는 시도를 방지한다
		if (this == &other)
			return *this;
		
		this->~String();		// 이전의 나를 지운다.
		num = other.num;		//
		p = new char[num];		// 메모리 할당
		memcpy(p, other.p, num); // 값을 복사

		return *this;			// 새로 탄생한 나를 리턴
	}

	size_t size() const {
		return num;
	}

	void show() const {
		for (int i = 0; i < num; ++i)
			cout << p[i];
		cout << endl;
	}
};

// [문제] String을 정렬하려 한다.
// String 객체 30개를 임의의 글자수[1~50]와 임의의 문자[a~z]로 만들어라.
// sort로 num기준 오름차순 정렬하자


int main()
{
	String str[30];

	sort(begin(str), end(str), [](const String& str1, const String& str2) {
		return str1.size() < str2.size();
		cout << " done " << endl;
		});
	
	for (const String& s : str)
		s.show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-02 오후 2:22:55 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.2        (9주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <random>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] main이 수정없이 실행되도록 class 코딩

default_random_engine dre;
uniform_int_distribution<> uid{ 1, 50 };
uniform_int_distribution<> ucd{ 97, 122 };

class String {
	size_t num{};
	char* p{};

public:
	String() {
		num = uid(dre);
		p = new char[num];
		for (int i = 0; i < num; ++i)
			p[i] = ucd(dre);
	}

	String(const char* str) {
		num = strlen(str);
		p = new char[num];
		memcpy(p, str, num);
	}

	~String() {
		cout << (void*)p << " 소멸" << endl;
		delete[] p;
	}

	String(const String& other) : num{ other.num } {
		p = new char[num];
		memcpy(p, other.p, num);
	}

	String& operator=(const String& other) {
		// 나를 나에게 대입하려는 시도를 방지한다
		if (this == &other)
			return *this;
		
		this->~String();		// 이전의 나를 지운다.
		num = other.num;		//
		p = new char[num];		// 메모리 할당
		memcpy(p, other.p, num); // 값을 복사

		return *this;			// 새로 탄생한 나를 리턴
	}

	size_t size() const {
		return num;
	}

	void show() const {
		for (int i = 0; i < num; ++i)
			cout << p[i];
		cout << endl;
	}
};

// [문제] String을 정렬하려 한다.
// String 객체 30개를 임의의 글자수[1~50]와 임의의 문자[a~z]로 만들어라.
// sort로 num기준 오름차순 정렬하자


int main()
{
	String str[30];

	sort(begin(str), end(str), [](String str1, String str2) {
		return str1.size() > str2.size();
		});
	
	for (const String& s : str)
		s.show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-02 오후 2:23:28 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.2        (9주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <random>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] main이 수정없이 실행되도록 class 코딩

default_random_engine dre;
uniform_int_distribution<> uid{ 1, 50 };
uniform_int_distribution<> ucd{ 97, 122 };

class String {
	size_t num{};
	char* p{};

public:
	String() {
		num = uid(dre);
		p = new char[num];
		for (int i = 0; i < num; ++i)
			p[i] = ucd(dre);
	}

	String(const char* str) {
		num = strlen(str);
		p = new char[num];
		memcpy(p, str, num);
	}

	~String() {
		cout << (void*)p << " 소멸" << endl;
		delete[] p;
	}

	String(const String& other) : num{ other.num } {
		p = new char[num];
		memcpy(p, other.p, num);
	}

	String& operator=(const String& other) {
		// 나를 나에게 대입하려는 시도를 방지한다
		if (this == &other)
			return *this;
		
		this->~String();		// 이전의 나를 지운다.
		num = other.num;		//
		p = new char[num];		// 메모리 할당
		memcpy(p, other.p, num); // 값을 복사

		return *this;			// 새로 탄생한 나를 리턴
	}

	size_t size() const {
		return num;
	}

	void show() const {
		for (int i = 0; i < num; ++i)
			cout << p[i];
		cout << endl;
	}
};

// [문제] String을 정렬하려 한다.
// String 객체 30개를 임의의 글자수[1~50]와 임의의 문자[a~z]로 만들어라.
// sort로 num기준 오름차순 정렬하자


int main()
{
	String str[30];

	sort(begin(str), end(str), [](String& str1, String& str2) {
		return str1.size() > str2.size();
		});
	
	for (const String& s : str)
		s.show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-02 오후 2:23:41 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.2        (9주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <random>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] main이 수정없이 실행되도록 class 코딩

default_random_engine dre;
uniform_int_distribution<> uid{ 1, 50 };
uniform_int_distribution<> ucd{ 97, 122 };

class String {
	size_t num{};
	char* p{};

public:
	String() {
		num = uid(dre);
		p = new char[num];
		for (int i = 0; i < num; ++i)
			p[i] = ucd(dre);
	}

	String(const char* str) {
		num = strlen(str);
		p = new char[num];
		memcpy(p, str, num);
	}

	~String() {
		cout << (void*)p << " 소멸" << endl;
		delete[] p;
	}

	String(const String& other) : num{ other.num } {
		p = new char[num];
		memcpy(p, other.p, num);
	}

	String& operator=(const String& other) {
		// 나를 나에게 대입하려는 시도를 방지한다
		if (this == &other)
			return *this;
		
		this->~String();		// 이전의 나를 지운다.
		num = other.num;		//
		p = new char[num];		// 메모리 할당
		memcpy(p, other.p, num); // 값을 복사

		return *this;			// 새로 탄생한 나를 리턴
	}

	size_t size() const {
		return num;
	}

	void show() const {
		for (int i = 0; i < num; ++i)
			cout << p[i];
		cout << endl;
	}
};

// [문제] String을 정렬하려 한다.
// String 객체 30개를 임의의 글자수[1~50]와 임의의 문자[a~z]로 만들어라.
// sort로 num기준 오름차순 정렬하자


int main()
{
	String str[30];

	sort(begin(str), end(str), [](const String& str1, const String& str2) {
		return str1.size() > str2.size();
		});
	
	for (const String& s : str)
		s.show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-02 오후 2:23:55 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.2        (9주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <random>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] main이 수정없이 실행되도록 class 코딩

default_random_engine dre;
uniform_int_distribution<> uid{ 1, 50 };
uniform_int_distribution<> ucd{ 97, 122 };

class String {
	size_t num{};
	char* p{};

public:
	String() {
		num = uid(dre);
		p = new char[num];
		for (int i = 0; i < num; ++i)
			p[i] = ucd(dre);
	}

	String(const char* str) {
		num = strlen(str);
		p = new char[num];
		memcpy(p, str, num);
	}

	~String() {
		//cout << (void*)p << " 소멸" << endl;
		delete[] p;
	}

	String(const String& other) : num{ other.num } {
		p = new char[num];
		memcpy(p, other.p, num);
	}

	String& operator=(const String& other) {
		// 나를 나에게 대입하려는 시도를 방지한다
		if (this == &other)
			return *this;
		
		this->~String();		// 이전의 나를 지운다.
		num = other.num;		//
		p = new char[num];		// 메모리 할당
		memcpy(p, other.p, num); // 값을 복사

		return *this;			// 새로 탄생한 나를 리턴
	}

	size_t size() const {
		return num;
	}

	void show() const {
		for (int i = 0; i < num; ++i)
			cout << p[i];
		cout << endl;
	}
};

// [문제] String을 정렬하려 한다.
// String 객체 30개를 임의의 글자수[1~50]와 임의의 문자[a~z]로 만들어라.
// sort로 num기준 오름차순 정렬하자


int main()
{
	String str[30];

	sort(begin(str), end(str), [](const String& str1, const String& str2) {
		return str1.size() > str2.size();
		});
	
	for (const String& s : str)
		s.show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-02 오후 2:25:15 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.2        (9주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <random>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] main이 수정없이 실행되도록 class 코딩

default_random_engine dre;
uniform_int_distribution<> uid{ 1, 50 };
uniform_int_distribution<> ucd{ 97, 122 };

class String {
	size_t num{};
	char* p{};

public:
	String() {
		num = uid(dre);
		p = new char[num];
		for (int i = 0; i < num; ++i)
			p[i] = ucd(dre);
	}

	String(const char* str) {
		num = strlen(str);
		p = new char[num];
		memcpy(p, str, num);
	}

	~String() {
		//cout << (void*)p << " 소멸" << endl;
		delete[] p;
	}

	String(const String& other) : num{ other.num } {
		p = new char[num];
		memcpy(p, other.p, num);
	}

	String& operator=(const String& other) {
		// 나를 나에게 대입하려는 시도를 방지한다
		if (this == &other)
			return *this;
		
		this->~String();		// 이전의 나를 지운다.
		num = other.num;		//
		p = new char[num];		// 메모리 할당
		memcpy(p, other.p, num); // 값을 복사

		return *this;			// 새로 탄생한 나를 리턴
	}

	size_t size() const {
		return num;
	}

	void show() const {
		for (int i = 0; i < num; ++i)
			cout << p[i];
		cout << endl;
	}
};

// [문제] String을 정렬하려 한다.
// String 객체 30개를 임의의 글자수[1~50]와 임의의 문자[a~z]로 만들어라.
// sort로 num기준 오름차순 정렬하자


int main()
{
	String str[30];

	sort(begin(str), end(str), [](const String& str1, const String& str2) {
		return str1.size() < str2.size();
		});
	
	for (const String& s : str)
		s.show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-02 오후 2:26:45 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.2        (9주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <random>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] main이 수정없이 실행되도록 class 코딩

default_random_engine dre;
uniform_int_distribution<> uid{ 1, 50 };
uniform_int_distribution<> ucd{ 97, 122 };

class String {
	size_t num{};
	char* p{};

public:
	String() {
		num = uid(dre);
		p = new char[num];
		for (int i = 0; i < num; ++i)
			p[i] = ucd(dre);
	}

	String(const char* str) {
		num = strlen(str);
		p = new char[num];
		memcpy(p, str, num);
	}

	~String() {
		cout << (void*)p << " 소멸" << endl;
		delete[] p;
	}

	String(const String& other) : num{ other.num } {
		p = new char[num];
		memcpy(p, other.p, num);
	}

	String& operator=(const String& other) {
		// 나를 나에게 대입하려는 시도를 방지한다
		if (this == &other)
			return *this;
		
		this->~String();		// 이전의 나를 지운다.
		num = other.num;		//
		p = new char[num];		// 메모리 할당
		memcpy(p, other.p, num); // 값을 복사

		return *this;			// 새로 탄생한 나를 리턴
	}

	size_t size() const {
		return num;
	}

	void show() const {
		for (int i = 0; i < num; ++i)
			cout << p[i];
		cout << endl;
	}
};

// [문제] String을 정렬하려 한다.
// String 객체 30개를 임의의 글자수[1~50]와 임의의 문자[a~z]로 만들어라.
// sort로 num기준 오름차순 정렬하자


int main()
{
	String str[30];

	sort(begin(str), end(str), []( String str1, String str2) {
		return str1.size() < str2.size();
		});
	
	for (const String& s : str)
		s.show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-02 오후 2:27:21 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.2        (9주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <random>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] main이 수정없이 실행되도록 class 코딩

default_random_engine dre;
uniform_int_distribution<> uid{ 1, 50 };
uniform_int_distribution<> ucd{ 97, 122 };

class String {
	size_t num{};
	char* p{};

public:
	String() {
		num = uid(dre);
		p = new char[num];
		for (int i = 0; i < num; ++i)
			p[i] = ucd(dre);
	}

	String(const char* str) {
		num = strlen(str);
		p = new char[num];
		memcpy(p, str, num);
	}

	~String() {
		cout << (void*)p << " 소멸" << endl;
		delete[] p;
	}

	String(const String& other) : num{ other.num } {
		p = new char[num];
		memcpy(p, other.p, num);
	}

	String& operator=(const String& other) {
		// 나를 나에게 대입하려는 시도를 방지한다
		if (this == &other)
			return *this;
		
		this->~String();		// 이전의 나를 지운다.
		num = other.num;		//
		p = new char[num];		// 메모리 할당
		memcpy(p, other.p, num); // 값을 복사

		return *this;			// 새로 탄생한 나를 리턴
	}

	size_t size() const {
		return num;
	}

	void show() const {
		for (int i = 0; i < num; ++i)
			cout << p[i];
		cout << endl;
	}
};

// [문제] String을 정렬하려 한다.
// String 객체 30개를 임의의 글자수[1~50]와 임의의 문자[a~z]로 만들어라.
// sort로 num기준 오름차순 정렬하자


int main()
{
	String str[30];

	sort(begin(str), end(str), []( const String& str1, const String& str2) {
		return str1.size() < str2.size();
		});
	
	for (const String& s : str)
		s.show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-02 오후 2:28:30 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.2        (9주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <random>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] main이 수정없이 실행되도록 class 코딩

default_random_engine dre;
uniform_int_distribution<> uid{ 1, 50 };
uniform_int_distribution<> ucd{ 97, 122 };

struct String {
	size_t num{};
	char* p{};

public:
	String() {
		num = uid(dre);
		p = new char[num];
		for (int i = 0; i < num; ++i)
			p[i] = ucd(dre);
	}

	String(const char* str) {
		num = strlen(str);
		p = new char[num];
		memcpy(p, str, num);
	}

	~String() {
		cout << (void*)p << " 소멸" << endl;
		delete[] p;
	}

	String(const String& other) : num{ other.num } {
		p = new char[num];
		memcpy(p, other.p, num);
	}

	String& operator=(const String& other) {
		// 나를 나에게 대입하려는 시도를 방지한다
		if (this == &other)
			return *this;
		
		this->~String();		// 이전의 나를 지운다.
		num = other.num;		//
		p = new char[num];		// 메모리 할당
		memcpy(p, other.p, num); // 값을 복사

		return *this;			// 새로 탄생한 나를 리턴
	}

	size_t size() const {
		return num;
	}

	void show() const {
		for (int i = 0; i < num; ++i)
			cout << p[i];
		cout << endl;
	}
};

// [문제] String을 정렬하려 한다.
// String 객체 30개를 임의의 글자수[1~50]와 임의의 문자[a~z]로 만들어라.
// sort로 num기준 오름차순 정렬하자


int main()
{
	String str[30];

	sort(begin(str), end(str), []( const String& str1, const String& str2) {
		return str1.num < str2.num;
		});
	
	for (const String& s : str)
		s.show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-02 오후 2:36:50 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.2        (9주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <random>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] main이 수정없이 실행되도록 class 코딩

default_random_engine dre;
uniform_int_distribution<> uid{ 1, 50 };
uniform_int_distribution<> ucd{ 97, 122 };

class String {
	size_t num{};
	char* p{};

public:
	String() {
		num = uid(dre);
		p = new char[num];
		for (int i = 0; i < num; ++i)
			p[i] = ucd(dre);
	}

	String(const char* str) {
		num = strlen(str);
		p = new char[num];
		memcpy(p, str, num);
	}

	~String() {
		cout << (void*)p << " 소멸" << endl;
		delete[] p;
	}

	String(const String& other) : num{ other.num } {
		p = new char[num];
		memcpy(p, other.p, num);
	}

	String& operator=(const String& other) {
		// 나를 나에게 대입하려는 시도를 방지한다
		if (this == &other)
			return *this;
		
		this->~String();		// 이전의 나를 지운다.
		num = other.num;		//
		p = new char[num];		// 메모리 할당
		memcpy(p, other.p, num); // 값을 복사

		return *this;			// 새로 탄생한 나를 리턴
	}

	size_t size() const {
		return num;
	}

	void show() const {
		for (int i = 0; i < num; ++i)
			cout << p[i];
		cout << endl;
	}
};

// [문제] String을 정렬하려 한다.
// String 객체 30개를 임의의 글자수[1~50]와 임의의 문자[a~z]로 만들어라.
// sort로 num기준 오름차순 정렬하자


int main()
{
	String str[300];

	sort(begin(str), end(str), []( const String& str1, const String& str2) {
		return str1.size() < str2.size();
		});
	
	for (const String& s : str)
		s.show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-02 오후 2:44:23 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.2        (9주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Dog {
	string name;
	int age;

	void show() const {
		cout << name << " - " << age << "살" << endl;
	}
};

int main()
{
	Dog a{ "댕댕이", 3 };	// [댕댕이, 6][3]
	Dog b{ "쵸코", 4 };		// [쵸코  , 4][4]

	a.show();
	b.show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-02 오후 2:46:19 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.2        (9주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Dog {
	string name;
	int age;

	Dog(string s, int n) : name{ s }, age{ n } {}

	void show() const {
		cout << name << " - " << age << "살" << endl;
	}
};

int main()
{
	Dog a{ "댕댕이", 3 };	// [댕댕이, 6][3]
	Dog b{ "쵸코", 4 };		// [쵸코  , 4][4]

	a.show();
	b.show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-02 오후 2:46:32 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.2        (9주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Dog {
	string name;
	int age;

	Dog(string s, int n) : name{ s }, age{ n } {cout << "관찰" << endl; }

	void show() const {
		cout << name << " - " << age << "살" << endl;
	}
};

int main()
{
	Dog a{ "댕댕이", 3 };	// [댕댕이, 6][3]
	Dog b{ "쵸코", 4 };		// [쵸코  , 4][4]

	a.show();
	b.show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-02 오후 2:46:45 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.2        (9주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Dog {
	string name;
	int age;

	Dog(string s, int n) : name{ s }, age{ n + 1 } {cout << "관찰" << endl; }

	void show() const {
		cout << name << " - " << age << "살" << endl;
	}
};

int main()
{
	Dog a{ "댕댕이", 3 };	// [댕댕이, 6][3]
	Dog b{ "쵸코", 4 };		// [쵸코  , 4][4]

	a.show();
	b.show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-02 오후 2:56:53 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.2        (9주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Dog {
	string name;
	int age;

	void show() const {
		cout << name << " - " << age << "살" << endl;
	}
};

// [문제] 두 Dog의 이름이 누가 긴지 알고싶다.
// 어떻게 알 수 있을까?

bool long_name(const Dog&, const Dog&);


int main()
{
	Dog a{ "댕댕이", 3 };	// [댕댕이, 6][3]
	Dog b{ "쵸코", 4 };		// [쵸코  , 4][4]

	if (long_name(a, b))
		cout << "a의 이름이 길다" << endl;
	else
		cout << "b의 이름이 길다" << endl;

	save("소스.cpp");
}

bool long_name(const Dog& a, const Dog& b) {
	if (a.name.length() > b.name.length())
		return true;
	else
		return false;
}


-------------------------------------------
소스.cpp - 2020-11-02 오후 2:59:46 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.2        (9주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Dog {
	string name;
	int age;

	void show() const {
		cout << name << " - " << age << "살" << endl;
	}
};

// [문제] 두 Dog의 이름이 누가 긴지 알고싶다.
// 어떻게 알 수 있을까?

bool long_name(const Dog&, const Dog&);


int main()
{
	Dog a{ "댕댕이", 3 };	// [댕댕이, 6][3]
	Dog b{ "쵸코", 4 };		// [쵸코  , 4][4]

	if (long_name(a, b))
		cout << "a의 이름이 길다" << endl;
	else
		cout << "b의 이름이 길다" << endl;

	save("소스.cpp");
}

bool long_name(const Dog& a, const Dog& b)
{
	return a.name.size() < b.name.size();
}


-------------------------------------------
소스.cpp - 2020-11-02 오후 2:59:59 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.2        (9주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Dog {
	string name;
	int age;

	void show() const {
		cout << name << " - " << age << "살" << endl;
	}
};

// [문제] 두 Dog의 이름이 누가 긴지 알고싶다.
// 어떻게 알 수 있을까?

bool long_name(const Dog&, const Dog&);


int main()
{
	Dog a{ "댕댕이", 3 };	// [댕댕이, 6][3]
	Dog b{ "쵸코", 4 };		// [쵸코  , 4][4]

	if (long_name(a, b))
		cout << "a의 이름이 길다" << endl;
	else
		cout << "b의 이름이 길다" << endl;

	save("소스.cpp");
}

bool long_name(const Dog& a, const Dog& b)
{
	return a.name.size() > b.name.size();
}


-------------------------------------------
소스.cpp - 2020-11-02 오후 3:00:38 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.2        (9주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Dog {
	string name;
	int age;

	void show() const {
		cout << name << " - " << age << "살" << endl;
	}
};

// [문제] 두 Dog의 이름이 누가 긴지 알고싶다.
// 어떻게 알 수 있을까?

bool long_name(const Dog&, const Dog&);


int main()
{
	Dog a{ "댕댕이", 3 };	// [댕댕이, 6][3]
	Dog b{ "쵸코쵸코", 4 };		// [쵸코  , 4][4]

	if (long_name(a, b))
		cout << "a의 이름이 길다" << endl;
	else
		cout << "b의 이름이 길다" << endl;

	save("소스.cpp");
}

bool long_name(const Dog& a, const Dog& b)
{
	return a.name.size() > b.name.size();
}


-------------------------------------------
소스.cpp - 2020-11-02 오후 3:09:28 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.2        (9주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

class Dog {
	string name;
	int age;

public:
	Dog(string n, int a) : name{ n }, age{ a } {}

	void show() const {
		cout << name << " - " << age << "살" << endl;
	}

	// 멤버에 access할 필요가 있다면 getter와 setter를 Dog가 제공한다
	string getName() const {
		return name;
	}
};

// [문제] 두 Dog의 이름이 누가 긴지 알고싶다.
// 어떻게 알 수 있을까?

bool long_name(const Dog&, const Dog&);


int main()
{
	Dog a{ "댕댕이", 3 };	// [댕댕이, 6][3]
	Dog b{ "쵸코", 4 };		// [쵸코  , 4][4]

	if (long_name(a, b))
		cout << "a의 이름이 길다" << endl;
	else
		cout << "b의 이름이 길다" << endl;

	save("소스.cpp");
}

bool long_name(const Dog& a, const Dog& b)
{
	return a.getName().size() > b.getName().size();
}


-------------------------------------------
소스.cpp - 2020-11-02 오후 3:18:40 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.2        (9주 1일)
//
// 사용자 정의 자료형 - 
// struct - 모든 메모리를 읽고 써도 되는 경우
// class - 메모리의 access하려면 interface를 사용해야 하는 경우
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

class Dog {
	string name;
	int age;

public:
	Dog(string n, int a) : name{ n }, age{ a } {}

	void show() const {
		cout << name << " - " << age << "살" << endl;
	}

	// 멤버에 access할 필요가 있다면 getter와 setter를 Dog가 제공한다
	string getName() const {
		return name;
	}
};


// [문제] 두 Dog의 이름이 누가 긴지 알고싶다.
// 어떻게 알 수 있을까?

bool long_name(const Dog&, const Dog&);

bool operator<(const Dog&, const Dog&);

bool operator<(const Dog& a, const Dog& b)
{
	return a.getName().size() < b.getName().size();
}

int main()
{
	Dog a{ "댕댕이", 3 };	// [댕댕이, 6][3]
	Dog b{ "쵸코", 4 };		// [쵸코  , 4][4]

	if (a < b)
		cout << "b의 이름이 길다" << endl;
	else
		cout << "a의 이름이 길다" << endl;

	save("소스.cpp");
}

bool long_name(const Dog& a, const Dog& b)
{
	return a.getName().size() > b.getName().size();
}


-------------------------------------------
소스.cpp - 2020-11-04 오전 11:48:07 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.4 수     (9주 2일)
//
// 연산자 오버로딩
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"

#include <Windows.h>
#include <mmsystem.h>
#pragma comment(lib, "winmm.lib")

using namespace std;

class Dog {
	string name;
	int age;

public:
	Dog() {
		PlaySound(L"개짖는소리.wav", 0, SND_FILENAME | SND_SYNC);
	}

	Dog(string s, int n) {
		PlaySound(L"개짖는소리.wav", 0, SND_FILENAME | SND_SYNC);
	}
};

int main()
{
	Dog a{ "댕댕이", 3 };


	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-04 오전 11:48:54 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.4 수     (9주 2일)
//
// 연산자 오버로딩
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"

#include <Windows.h>
#include <mmsystem.h>


using namespace std;

#pragma comment(lib, "winmm.lib")

class Dog {
	string name;
	int age;

public:
	Dog() {
		PlaySound(L"개짖는소리.wav", 0, SND_FILENAME | SND_SYNC);
	}

	Dog(string s, int n) {
		PlaySound(L"개짖는소리.wav", 0, SND_FILENAME | SND_SYNC);
	}
};

int main()
{
	Dog a{ "댕댕이", 3 };


	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-04 오전 11:55:03 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.4 수     (9주 2일)
//
// 연산자 오버로딩
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] class INT를 만들어가며 연산자 오버로딩을 이해한다
// class INT는 int가 하는 동작을 그대로 할 수 있다.

class INT {
	int num;
public:
	INT(int n) : num{ n } {}

	INT operator+(const INT& n) {
		return *this + n;
	}

	void show() const {
		cout << num << endl;
	}
};



int main()
{
	INT a{ 1 };
	INT b{ 2 };
	INT c = a + b;	// INT a.operator+( const INT& );

	c.show();		// 3 이 출력되어야 한다.

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-04 오전 11:55:37 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.4 수     (9주 2일)
//
// 연산자 오버로딩
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] class INT를 만들어가며 연산자 오버로딩을 이해한다
// class INT는 int가 하는 동작을 그대로 할 수 있다.

class INT {
	int num;
public:
	INT(int n) : num{ n } {}

	INT operator+(const INT& n) {
		return this->num + n.num;
	}

	void show() const {
		cout << num << endl;
	}
};



int main()
{
	INT a{ 1 };
	INT b{ 2 };
	INT c = a + b;	// INT a.operator+( const INT& );

	c.show();		// 3 이 출력되어야 한다.

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-04 오전 11:57:26 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.4 수     (9주 2일)
//
// 연산자 오버로딩
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] class INT를 만들어가며 연산자 오버로딩을 이해한다
// class INT는 int가 하는 동작을 그대로 할 수 있다.

class INT {
	int num;
public:
	INT(int n) : num{ n } {}

	INT operator+(const INT& n) {
		return num + n.num;
	}

	void show() const {
		cout << num << endl;
	}
};



int main()
{
	INT a{ 1 };
	INT b{ 2 };
	INT c = a + b;	// INT a.operator+( const INT& );

	c.show();		// 3 이 출력되어야 한다.

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-04 오후 12:03:27 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.4 수     (9주 2일)
//
// 연산자 오버로딩
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] class INT를 만들어가며 연산자 오버로딩을 이해한다
// class INT는 int가 하는 동작을 그대로 할 수 있다.

class INT {
	int num;
public:
	INT(int n) : num{ n } {}

	/*INT operator+(const INT& n) {
		return num + n.num;
	}*/

	void show() const {
		cout << num << endl;
	}

	int getNum() const {
		return num;
	}
};

INT operator+(const INT& lhs, const INT& rhs);

INT operator+(const INT& lhs, const INT& rhs)
{
	return INT(lhs.getNum() + rhs.getNum());
}

int main()
{
	INT a{ 1 };		// [ 1 ]
	INT b{ 2 };		// [ 2 ]

	INT c = a + b;	// [ 3 ]
					
	// INT a.operator+( const INT& );

	c.show();		// 3 이 출력되어야 한다.

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-04 오후 12:03:57 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.4 수     (9주 2일)
//
// 연산자 오버로딩
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] class INT를 만들어가며 연산자 오버로딩을 이해한다
// class INT는 int가 하는 동작을 그대로 할 수 있다.

class INT {
	int num;
public:
	INT(int n) : num{ n } {}

	/*INT operator+(const INT& n) {
		return num + n.num;
	}*/

	void show() const {
		cout << num << endl;
	}

	int getNum() const {
		return num;
	}
};

INT operator+(const INT& lhs, const INT& rhs);

INT operator+(const INT& lhs, const INT& rhs)
{
	return INT(lhs.getNum() + rhs.getNum());
}

int main()
{
	INT a{ 1 };		// [ 1 ]
	INT b{ 2 };		// [ 2 ]

	INT c = a + b + a + b + a;	// [ 3 ]
					
	// INT a.operator+( const INT& );

	c.show();		// 3 이 출력되어야 한다.

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-04 오후 12:10:24 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.4 수     (9주 2일)
//
// 연산자 오버로딩
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] class INT를 만들어가며 연산자 오버로딩을 이해한다
// class INT는 int가 하는 동작을 그대로 할 수 있다.

class INT {
	int num;

public:
	explicit INT(int n) : num{ n } {}

	INT operator+(const INT& rhs) const {
		return INT( num + rhs.num );
	}

	void show() const {
		cout << num << endl;
	}
};



int main()
{
	INT a{ 1 };		// [ 1 ]
	INT b{ 2 };		// [ 2 ]

	INT c = a + b;	// [ 3 ]
					
	// INT a.operator+( const INT& );

	c.show();		// 3 이 출력되어야 한다.

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-04 오후 12:11:49 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.4 수     (9주 2일)
//
// 연산자 오버로딩
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] class INT를 만들어가며 연산자 오버로딩을 이해한다
// class INT는 int가 하는 동작을 그대로 할 수 있다.

class INT {
	int num;

public:
	explicit INT(int n) : num{ n } {}

	INT operator+(const INT& rhs) const {
		return INT( num + rhs.num );
	}

	void show() const {
		cout << num << endl;
	}
};



int main()
{
	int i = 1;

	cout << ++i << endl;


	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-04 오후 12:28:51 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.4 수     (9주 2일)
//
// 연산자 오버로딩
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] class INT를 만들어가며 연산자 오버로딩을 이해한다
// class INT는 int가 하는 동작을 그대로 할 수 있다.

class INT {
	int num;

public:
	explicit INT(int n) : num{ n } {}

	INT operator+(const INT& rhs) const {
		return INT( num + rhs.num );
	}

	void show() const {
		cout << num << endl;
	}

	INT& operator++() {
		this->num += 1;
		return *this;
	}

};



int main()
{
	INT i{ 1 };

	++i;		// 어떻게? -- operator++


	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-04 오후 12:29:24 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.4 수     (9주 2일)
//
// 연산자 오버로딩
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] class INT를 만들어가며 연산자 오버로딩을 이해한다
// class INT는 int가 하는 동작을 그대로 할 수 있다.

class INT {
	int num;

public:
	explicit INT(int n) : num{ n } {}

	INT operator+(const INT& rhs) const {
		return INT( num + rhs.num );
	}

	void show() const {
		cout << num << endl;
	}

	INT& operator++() {
		num += 1;
		return *this;
	}

};



int main()
{
	INT i{ 1 };

	++i;		// 어떻게? -- operator++

	i.show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-04 오후 12:34:22 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.4 수     (9주 2일)
//
// 연산자 오버로딩
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] class INT를 만들어가며 연산자 오버로딩을 이해한다
// class INT는 int가 하는 동작을 그대로 할 수 있다.

class INT {
	int num;

public:
	explicit INT(int n) : num{ n } {}

	INT operator+(const INT& rhs) const {
		return INT( num + rhs.num );
	}

	void show() const {
		cout << num << endl;
	}

	INT& operator++() {		// pre-increment operator
		++num;
		return *this;
	}

};



int main()
{
	INT a{ 1 };

	(++a).show();		// 어떻게? -- operator++

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-04 오후 12:34:29 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.4 수     (9주 2일)
//
// 연산자 오버로딩
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] class INT를 만들어가며 연산자 오버로딩을 이해한다
// class INT는 int가 하는 동작을 그대로 할 수 있다.

class INT {
	int num;

public:
	explicit INT(int n) : num{ n } {}

	INT operator+(const INT& rhs) const {
		return INT( num + rhs.num );
	}

	void show() const {
		cout << num << endl;
	}

	INT& operator++() {		// pre-increment operator
		++num;
		return *this;
	}

};



int main()
{
	INT a{ 1 };

	(++++++a).show();		// 어떻게? -- operator++

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-04 오후 12:34:39 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.4 수     (9주 2일)
//
// 연산자 오버로딩
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] class INT를 만들어가며 연산자 오버로딩을 이해한다
// class INT는 int가 하는 동작을 그대로 할 수 있다.

class INT {
	int num;

public:
	explicit INT(int n) : num{ n } {}

	INT operator+(const INT& rhs) const {
		return INT( num + rhs.num );
	}

	void show() const {
		cout << num << endl;
	}

	INT& operator++() {		// pre-increment operator
		++num;
		return *this;
	}

};



int main()
{
	INT a{ 1 };

	(++++++++++a).show();		// 어떻게? -- operator++

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-04 오후 12:43:46 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.4 수     (9주 2일)
//
// 연산자 오버로딩
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] class INT를 만들어가며 연산자 오버로딩을 이해한다
// class INT는 int가 하는 동작을 그대로 할 수 있다.

class INT {
	int num;

public:
	explicit INT(int n) : num{ n } {}

	INT operator+(const INT& rhs) const {
		return INT( num + rhs.num );
	}

	void show() const {
		cout << num << endl;
	}

	INT& operator++() {		// pre-increment operator
		++num;
		return *this;
	}

	INT operator++( int	) {		// post-increment operator
		// 이전의 나를 저장한다
		INT temp{ *this };
		// 이후에 나의 값을 1증가 시킨다
		++(*this);
		// 저장한 예전의 나를 리턴한다
		return temp;
	}

};



int main()
{
	INT a{ 1 };

	(a++).show();		// 어떻게? -- operator++

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-04 오후 12:45:06 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.4 수     (9주 2일)
//
// 연산자 오버로딩
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] class INT를 만들어가며 연산자 오버로딩을 이해한다
// class INT는 int가 하는 동작을 그대로 할 수 있다.

class INT {
	int num;

public:
	explicit INT(int n) : num{ n } {}

	INT operator+(const INT& rhs) const {
		return INT( num + rhs.num );
	}

	void show() const {
		cout << num << endl;
	}

	INT& operator++() {		// pre-increment operator
		++num;
		return *this;
	}

	INT operator++( int	) {		// post-increment operator
		// 이전의 나를 저장한다
		INT temp{ *this };
		// 이후에 나의 값을 1증가 시킨다
		++(*this);
		// 저장한 예전의 나를 리턴한다
		return temp;
	}

};



int main()
{
	INT a{ 1 };

	(a++).show();		// 어떻게? -- operator++
	a.show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-04 오후 12:46:08 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.4 수     (9주 2일)
//
// 연산자 오버로딩
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] class INT를 만들어가며 연산자 오버로딩을 이해한다
// class INT는 int가 하는 동작을 그대로 할 수 있다.

class INT {
	int num;

public:
	explicit INT(int n) : num{ n } {}

	INT operator+(const INT& rhs) const {
		return INT( num + rhs.num );
	}

	void show() const {
		cout << num << endl;
	}

	INT& operator++() {		// pre-increment operator
		++num;
		return *this;
	}

	INT operator++( int	) {		// post-increment operator
		// 이전의 나를 저장한다
		INT temp{ *this };
		// 이후에 나의 값을 1증가 시킨다
		++(*this);
		// 저장한 예전의 나를 리턴한다
		return temp;
	}

};



int main()
{
	INT a{ 1 };

	(a++ ++).show();		// 어떻게? -- operator++
	a.show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-04 오후 12:47:03 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.4 수     (9주 2일)
//
// 연산자 오버로딩
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] class INT를 만들어가며 연산자 오버로딩을 이해한다
// class INT는 int가 하는 동작을 그대로 할 수 있다.

class INT {
	int num;

public:
	explicit INT(int n) : num{ n } {}

	INT operator+(const INT& rhs) const {
		return INT( num + rhs.num );
	}

	void show() const {
		cout << num << endl;
	}

	INT& operator++() {		// pre-increment operator
		++num;
		return *this;
	}

	const INT operator++( int	) {		// post-increment operator
		// 이전의 나를 저장한다
		INT temp{ *this };
		// 이후에 나의 값을 1증가 시킨다
		++(*this);
		// 저장한 예전의 나를 리턴한다
		return temp;
	}

};



int main()
{
	INT a{ 1 };

	(a++).show();		// 어떻게? -- operator++
	a.show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-04 오후 1:01:50 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.4 수     (9주 2일)
//
// 연산자 오버로딩
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] class INT를 만들어가며 연산자 오버로딩을 이해한다
// class INT는 int가 하는 동작을 그대로 할 수 있다.

class INT {
	int num;

public:
	explicit INT(int n) : num{ n } {}

	INT operator+(const INT& rhs) const {
		return INT( num + rhs.num );
	}

	void show() const {
		cout << num << endl;
	}

	INT& operator++() {		// pre-increment operator
		++num;
		return *this;
	}

	const INT operator++( int	) {		// post-increment operator
		// 이전의 나를 저장한다
		INT temp{ *this };
		// 이후에 나의 값을 1증가 시킨다
		++(*this);
		// 저장한 예전의 나를 리턴한다
		return temp;
	}

	friend ostream& operator<<(ostream&, const INT&);
};



ostream& operator<<(ostream& os, const INT& x)
{
	os << x.num;
	return os;
}


int main()
{
	INT a{ 1 };
	INT b = a + a;

	cout << b;		// [1] operator<<( ostream, INT )
					// [2] cout.operator<<( INT ) >> nope

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-04 오후 1:02:17 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.4 수     (9주 2일)
//
// 연산자 오버로딩
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] class INT를 만들어가며 연산자 오버로딩을 이해한다
// class INT는 int가 하는 동작을 그대로 할 수 있다.

class INT {
	int num;

public:
	explicit INT(int n) : num{ n } {}

	INT operator+(const INT& rhs) const {
		return INT( num + rhs.num );
	}

	void show() const {
		cout << num << endl;
	}

	INT& operator++() {		// pre-increment operator
		++num;
		return *this;
	}

	const INT operator++( int	) {		// post-increment operator
		// 이전의 나를 저장한다
		INT temp{ *this };
		// 이후에 나의 값을 1증가 시킨다
		++(*this);
		// 저장한 예전의 나를 리턴한다
		return temp;
	}

	friend ostream& operator<<(ostream&, const INT&);
};



ostream& operator<<(ostream& os, const INT& x)
{
	os << x.num;
	return os;
}


int main()
{
	INT a{ 1 };
	INT b = a + a;

	cout << b << endl;
	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-04 오후 1:05:47 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.4 수     (9주 2일)
//
// 연산자 오버로딩
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <random>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<> uid{ 1, 1'000'000 };
class INT {
	int num{ uid(dre) };

public:
	INT() = default;

	INT(int n) : num{ n } {}

	INT operator+(const INT& rhs) const {
		return INT( num + rhs.num );
	}

	void show() const {
		cout << num << endl;
	}

	INT& operator++() {		// pre-increment operator
		++num;
		return *this;
	}

	const INT operator++( int	) {		// post-increment operator
		// 이전의 나를 저장한다
		INT temp{ *this };
		// 이후에 나의 값을 1증가 시킨다
		++(*this);
		// 저장한 예전의 나를 리턴한다
		return temp;
	}

	friend ostream& operator<<(ostream&, const INT&);
};



ostream& operator<<(ostream& os, const INT& x)
{
	os << x.num;
	return os;
}

// [연습] INT 객체를 100만개 만들자. 임의의 값으로.
// 100만개의 INT 파일에 기록해라.
// 파일에서 읽어와서 화면 출력해라.

int main()
{
	INT a;

	cout << a << endl;



	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-04 오후 1:06:30 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.4 수     (9주 2일)
//
// 연산자 오버로딩
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <random>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<> uid{ 1, 1'000'000 };
class INT {
	int num{ uid(dre) };

public:
	INT() = default;

	INT(int n) : num{ n } {}

	INT operator+(const INT& rhs) const {
		return INT( num + rhs.num );
	}

	void show() const {
		cout << num << endl;
	}

	INT& operator++() {		// pre-increment operator
		++num;
		return *this;
	}

	const INT operator++( int	) {		// post-increment operator
		// 이전의 나를 저장한다
		INT temp{ *this };
		// 이후에 나의 값을 1증가 시킨다
		++(*this);
		// 저장한 예전의 나를 리턴한다
		return temp;
	}

	friend ostream& operator<<(ostream&, const INT&);
};



ostream& operator<<(ostream& os, const INT& x)
{
	os << x.num;
	return os;
}

// [연습] INT 객체를 100만개 만들자. 임의의 값으로.
// 100만개의 INT 파일에 기록해라.
// 파일에서 읽어와서 화면 출력해라.

int main()
{
	INT a[10];

	for (INT a : a)
		cout << a << endl;



	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-04 오후 1:06:41 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.4 수     (9주 2일)
//
// 연산자 오버로딩
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <random>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<> uid{ 1, 1'000'000 };
class INT {
	int num{ uid(dre) };

public:
	INT() = default;

	INT(int n) : num{ n } {}

	INT operator+(const INT& rhs) const {
		return INT( num + rhs.num );
	}

	void show() const {
		cout << num << endl;
	}

	INT& operator++() {		// pre-increment operator
		++num;
		return *this;
	}

	const INT operator++( int	) {		// post-increment operator
		// 이전의 나를 저장한다
		INT temp{ *this };
		// 이후에 나의 값을 1증가 시킨다
		++(*this);
		// 저장한 예전의 나를 리턴한다
		return temp;
	}

	friend ostream& operator<<(ostream&, const INT&);
};



ostream& operator<<(ostream& os, const INT& x)
{
	os << x.num;
	return os;
}

// [연습] INT 객체를 100만개 만들자. 임의의 값으로.
// 100만개의 INT 파일에 기록해라.
// 파일에서 읽어와서 화면 출력해라.

int main()
{
	INT a[1000];

	for (INT a : a)
		cout << a << endl;



	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-04 오후 1:09:02 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.4 수     (9주 2일)
//
// 연산자 오버로딩
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <random>
#include <fstream>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<> uid{ 1, 1'000'000 };
class INT {
	int num{ uid(dre) };

public:
	INT() = default;

	INT(int n) : num{ n } {}

	INT operator+(const INT& rhs) const {
		return INT( num + rhs.num );
	}

	void show() const {
		cout << num << endl;
	}

	INT& operator++() {		// pre-increment operator
		++num;
		return *this;
	}

	const INT operator++( int	) {		// post-increment operator
		// 이전의 나를 저장한다
		INT temp{ *this };
		// 이후에 나의 값을 1증가 시킨다
		++(*this);
		// 저장한 예전의 나를 리턴한다
		return temp;
	}

	friend ostream& operator<<(ostream&, const INT&);
};



ostream& operator<<(ostream& os, const INT& x)
{
	os << x.num;
	return os;
}

// [연습] INT 객체를 100만개 만들자. 임의의 값으로.
// 100만개의 INT 파일에 기록해라.
// 파일에서 읽어와서 화면 출력해라.

int main()
{
	INT* p = new INT[1'000'000];

	cout << p[0] << " -- " << p[1] << endl;

	ofstream out("시험");

	for ( int i = 0; i < 1'000'000; ++i )
		out << p[i] << " ";



	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-04 오후 1:16:53 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.4 수     (9주 2일)
//
// 연산자 오버로딩
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <random>
#include <fstream>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<> uid{ 1, 1'000'000 };
class INT {
	int num{ uid(dre) };

public:
	INT() = default;

	INT(int n) : num{ n } {}

	INT operator+(const INT& rhs) const {
		return INT( num + rhs.num );
	}

	void show() const {
		cout << num << endl;
	}

	INT& operator++() {		// pre-increment operator
		++num;
		return *this;
	}

	const INT operator++( int	) {		// post-increment operator
		// 이전의 나를 저장한다
		INT temp{ *this };
		// 이후에 나의 값을 1증가 시킨다
		++(*this);
		// 저장한 예전의 나를 리턴한다
		return temp;
	}

	friend ostream& operator<<(ostream&, const INT&);
	friend istream& operator>>(istream&, INT&);
};



ostream& operator<<(ostream& os, const INT& x)
{
	os << x.num;
	return os;
}

istream& operator>>(istream& is, INT& x)
{
	is >> x.num;
	return is;
}

// [연습] INT 객체를 100만개 만들자. 임의의 값으로.
// 100만개의 INT 파일에 기록해라.
// 파일에서 읽어와서 화면 출력해라.

int main()
{
	//211613 -- 869303

	ifstream in("시험");

	INT x;
	in >> x;
	cout << x << endl;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-04 오후 1:17:03 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.4 수     (9주 2일)
//
// 연산자 오버로딩
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <random>
#include <fstream>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<> uid{ 1, 1'000'000 };
class INT {
	int num{ uid(dre) };

public:
	INT() = default;

	INT(int n) : num{ n } {}

	INT operator+(const INT& rhs) const {
		return INT( num + rhs.num );
	}

	void show() const {
		cout << num << endl;
	}

	INT& operator++() {		// pre-increment operator
		++num;
		return *this;
	}

	const INT operator++( int	) {		// post-increment operator
		// 이전의 나를 저장한다
		INT temp{ *this };
		// 이후에 나의 값을 1증가 시킨다
		++(*this);
		// 저장한 예전의 나를 리턴한다
		return temp;
	}

	friend ostream& operator<<(ostream&, const INT&);
	friend istream& operator>>(istream&, INT&);
};



ostream& operator<<(ostream& os, const INT& x)
{
	os << x.num;
	return os;
}

istream& operator>>(istream& is, INT& x)
{
	is >> x.num;
	return is;
}

// [연습] INT 객체를 100만개 만들자. 임의의 값으로.
// 100만개의 INT 파일에 기록해라.
// 파일에서 읽어와서 화면 출력해라.

int main()
{
	//211613 -- 869303

	ifstream in("시험");

	INT x;
	in >> x;
	cout << x << endl;
	in >> x;
	cout << x << endl;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-04 오후 1:18:13 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.4 수     (9주 2일)
//
// 연산자 오버로딩
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <random>
#include <fstream>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<> uid{ 1, 1'000'000 };
class INT {
	int num{ uid(dre) };

public:
	INT() = default;

	INT(int n) : num{ n } {}

	INT operator+(const INT& rhs) const {
		return INT( num + rhs.num );
	}

	void show() const {
		cout << num << endl;
	}

	INT& operator++() {		// pre-increment operator
		++num;
		return *this;
	}

	const INT operator++( int	) {		// post-increment operator
		// 이전의 나를 저장한다
		INT temp{ *this };
		// 이후에 나의 값을 1증가 시킨다
		++(*this);
		// 저장한 예전의 나를 리턴한다
		return temp;
	}

	friend ostream& operator<<(ostream&, const INT&);
	friend istream& operator>>(istream&, INT&);
};



ostream& operator<<(ostream& os, const INT& x)
{
	os << x.num;
	return os;
}

istream& operator>>(istream& is, INT& x)
{
	is >> x.num;
	return is;
}

// [연습] INT 객체를 100만개 만들자. 임의의 값으로.
// 100만개의 INT 파일에 기록해라.
// 파일에서 읽어와서 화면 출력해라.

int main()
{
	//211613 -- 869303

	ifstream in("시험");

	INT x;
	int cnt;
	while (in >> x)
		++cnt;

	cout << "모두 " << cnt << "개의 INT를 읽었습니다" << endl;
	

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-04 오후 1:18:38 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.4 수     (9주 2일)
//
// 연산자 오버로딩
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <random>
#include <fstream>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<> uid{ 1, 1'000'000 };
class INT {
	int num{ uid(dre) };

public:
	INT() = default;

	INT(int n) : num{ n } {}

	INT operator+(const INT& rhs) const {
		return INT( num + rhs.num );
	}

	void show() const {
		cout << num << endl;
	}

	INT& operator++() {		// pre-increment operator
		++num;
		return *this;
	}

	const INT operator++( int	) {		// post-increment operator
		// 이전의 나를 저장한다
		INT temp{ *this };
		// 이후에 나의 값을 1증가 시킨다
		++(*this);
		// 저장한 예전의 나를 리턴한다
		return temp;
	}

	friend ostream& operator<<(ostream&, const INT&);
	friend istream& operator>>(istream&, INT&);
};



ostream& operator<<(ostream& os, const INT& x)
{
	os << x.num;
	return os;
}

istream& operator>>(istream& is, INT& x)
{
	is >> x.num;
	return is;
}

// [연습] INT 객체를 100만개 만들자. 임의의 값으로.
// 100만개의 INT 파일에 기록해라.
// 파일에서 읽어와서 화면 출력해라.

int main()
{
	//211613 -- 869303

	ifstream in("시험");

	INT x;
	int cnt{};
	while (in >> x)
		++cnt;

	cout << "모두 " << cnt << "개의 INT를 읽었습니다" << endl;
	

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-07 오후 2:26:20 - (토요일)
-------------------------------------------

#include <iostream>
#include <string>
#include "save.h"

#include <Windows.h>
#include <mmsystem.h>
#pragma comment(lib, "winmm.lib")

using namespace std;

class Dog {
	string name;
	int age;

public:
	Dog() {
		PlaySound(L"개짖는소리.wav", 0, SND_FILENAME | SND_SYNC);
	}

	Dog(string s, int n) {
		PlaySound(L"개짖는소리.wav", 0, SND_FILENAME | SND_SYNC);
	}
};

int main()
{
	Dog a{ "댕댕이", 3 };


	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-07 오후 2:26:48 - (토요일)
-------------------------------------------

#include <iostream>
#include <string>
#include "save.h"

#include <Windows.h>
#include <mmsystem.h>
#pragma comment(lib, "winmm.lib")

using namespace std;

class Dog {
	string name;
	int age;

public:
	Dog() {
		PlaySound(L"개짖는소리.wav", 0, SND_FILENAME | SND_SYNC);
	}

	Dog(string s, int n) {
		PlaySound(L"개짖는소리.wav", 0, SND_FILENAME | SND_SYNC);
	}
};

int main()
{
	Dog a[3];


	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-07 오후 2:27:02 - (토요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.4 수     (9주 2일)
//
// 연산자 오버로딩
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <random>
#include <fstream>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<> uid{ 1, 1'000'000 };
class INT {
	int num{ uid(dre) };

public:
	INT() = default;

	INT(int n) : num{ n } {}

	INT operator+(const INT& rhs) const {
		return INT( num + rhs.num );
	}

	void show() const {
		cout << num << endl;
	}

	INT& operator++() {		// pre-increment operator
		++num;
		return *this;
	}

	const INT operator++( int	) {		// post-increment operator
		// 이전의 나를 저장한다
		INT temp{ *this };
		// 이후에 나의 값을 1증가 시킨다
		++(*this);
		// 저장한 예전의 나를 리턴한다
		return temp;
	}

	friend ostream& operator<<(ostream&, const INT&);
	friend istream& operator>>(istream&, INT&);
};



ostream& operator<<(ostream& os, const INT& x)
{
	os << x.num;
	return os;
}

istream& operator>>(istream& is, INT& x)
{
	is >> x.num;
	return is;
}

// [연습] INT 객체를 100만개 만들자. 임의의 값으로.
// 100만개의 INT 파일에 기록해라.
// 파일에서 읽어와서 화면 출력해라.

int main()
{
	//211613 -- 869303

	ifstream in("시험");

	INT x;
	int cnt{};
	while (in >> x)
		++cnt;

	cout << "모두 " << cnt << "개의 INT를 읽었습니다" << endl;
	

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-11 오전 11:52:58 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.11 수    (10주 2일)
//
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

class MemoryMonster {
	size_t num{ 100 };
	int* p{ nullptr };
public:
	MemoryMonster() : num{ 100 }, p{ new int[100] } {
		for (int i = 0; i < num; ++i)
			p[i] = 100;
	}

	~MemoryMonster() {
		delete[] p;
	}

	void show() const {
		cout << "MemoryMonster - int의 개수 : " << num << ", int의 값 : " << p[0] << endl;
	}
};

int main()
{
	{
		MemoryMonster mm;

		mm.show();
	}

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-11 오후 12:02:08 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.11 수    (10주 2일)
//
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

class MemoryMonster {
	size_t num{ 100 };
	int* p{ nullptr };
public:
	MemoryMonster() : num{ 100 }, p{ new int[100] } {
		for (int i = 0; i < num; ++i)
			p[i] = 100;
	}

	~MemoryMonster() {
		delete[] p;
	}

	MemoryMonster(const MemoryMonster& other) : num{ other.num }, p{ new int[num] } {
		for (int i = 0; i < num; ++i)
			p[i] = other.p[i] + 1;
	}

	void show() const {
		cout << "MemoryMonster - int의 개수 : " << num << ", int의 값 : " << p[0] << endl;
	}
};

int main()
{
	{ // 문제 1
		MemoryMonster mm;
		mm.show();
	}
	{ // 문제 2
		MemoryMonster mm1;
		MemoryMonster mm2{ mm1 };	// 복사생성

		mm1.show();
		mm2.show();
	}



	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-11 오후 12:04:40 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.11 수    (10주 2일)
//
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

class MemoryMonster {
	size_t num{ 100 };
	int* p{ nullptr };
public:
	MemoryMonster() : num{ 100 }, p{ new int[100] } {
		for (int i = 0; i < num; ++i)
			p[i] = 100;
	}

	~MemoryMonster() {
		delete[] p;
	}

	MemoryMonster(const MemoryMonster& other) : num{ other.num }, p{ new int[num] } {
		for (int i = 0; i < num; ++i)
			p[i] = other.p[i] + 1;
	}

	void show() const {
		cout << "MemoryMonster - int의 개수 : " << num << ", int의 값 : " << p[0] << endl;
	}
};

int main()
{
	{ // 문제 1
		MemoryMonster mm;
		mm.show();
	}
	{ // 문제 2
		MemoryMonster mm1;
		MemoryMonster mm2{ mm1 };	// 복사생성

		mm1.show();
		mm2.show();
	}



	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-11 오후 12:11:59 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.11 수    (10주 2일)
//
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

class MemoryMonster {
	size_t num{ 100 };
	int* p{ nullptr };
public:
	MemoryMonster() : num{ 100 }, p{ new int[100] } {
		for (int i = 0; i < num; ++i)
			p[i] = 100;
	}

	~MemoryMonster() {
		delete[] p;
	}

	MemoryMonster(const MemoryMonster& other) : num{ other.num }, p{ new int[num] } {
		for (int i = 0; i < num; ++i)
			p[i] = other.p[i] + 1;
	}

	void show() const {
		cout << "MemoryMonster - int의 개수 : " << num << ", int의 값 : " << p[0] << endl;
	}

	void special() {	// [100][번지 p]
		delete[] p;
		num *= 2;
		p = new int[num];
		for (int i = 0; i < num; ++i)
			p[i] = num;
	}
};

int main()
{
	{ // 문제 1
		MemoryMonster mm;
		mm.show();
	}
	{ // 문제 2
		MemoryMonster mm1;
		MemoryMonster mm2{ mm1 };	// 복사생성

		mm1.show();
		mm2.show();
	}
	{
		MemoryMonster mm;	// [100][번지]

		for (int i = 0; i < 10; ++i)
			mm.special();

		mm.show();
	}



	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-11 오후 12:18:07 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.11 수    (10주 2일)
//
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <random>
#include <algorithm>
#include "save.h"
using namespace std;

class MemoryMonster {
	size_t num{ 100 };
	int* p{ nullptr };
public:
	MemoryMonster() : num{ 100 }, p{ new int[100] } {
		for (int i = 0; i < num; ++i)
			p[i] = 100;
	}

	~MemoryMonster() {
		delete[] p;
	}

	MemoryMonster(const MemoryMonster& other) : num{ other.num }, p{ new int[num] } {
		for (int i = 0; i < num; ++i)
			p[i] = other.p[i] + 1;
	}

	void show() const {
		cout << "MemoryMonster - int의 개수 : " << num << ", int의 값 : " << p[0] << endl;
	}

	void special() {
		delete[] p;
		num *= 2;
		p = new int[num];
		for (int i = 0; i < num; ++i)
			p[i] = num;
	}
};

int main()
{
	{ // 문제 1
		MemoryMonster mm;
		mm.show();
	}
	{ // 문제 2
		MemoryMonster mm1;
		MemoryMonster mm2{ mm1 };	// 복사생성

		mm1.show();
		mm2.show();
	}
	{ // 문제 3
		MemoryMonster mm;	// [100][번지]

		for (int i = 0; i < 10; ++i)
			mm.special();

		mm.show();
	}
	{ // 문제 4
		MemoryMonster monsters[10];

		default_random_engine dre;
		uniform_int_distribution<> uid{ 1, 10 };
		
		for (MemoryMonster& mm : monsters) {
			int num = uid(dre);
			for (int i = 0; i < num; ++i)
				mm.special();
		}

		//sort(begin(monsters), end(monsters));

		for (MemoryMonster& mm : monsters)
			mm.show();
	}
	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-11 오후 12:28:20 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.11 수    (10주 2일)
//
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <random>
#include <algorithm>
#include "save.h"
using namespace std;

class MemoryMonster {
	size_t num{ 100 };
	int* p{ nullptr };
public:
	MemoryMonster() : num{ 100 }, p{ new int[100] } {
		for (int i = 0; i < num; ++i)
			p[i] = 100;
	}

	~MemoryMonster() {
		delete[] p;
	}

	MemoryMonster(const MemoryMonster& other) : num{ other.num }, p{ new int[num] } {
		for (int i = 0; i < num; ++i)
			p[i] = other.p[i] + 1;
	}
	MemoryMonster& operator=(const MemoryMonster& other) {
		if (this == &other)
			return *this;
		delete[] p;
		num = other.num;
		p = new int[num];
		for (int i = 0; i < num; ++i)
			p[i] = num;
	}


	void show() const {
		cout << "MemoryMonster - int의 개수 : " << num << ", int의 값 : " << p[0] << endl;
	}

	void special() {
		delete[] p;
		num *= 2;
		p = new int[num];
		for (int i = 0; i < num; ++i)
			p[i] = num;
	}

	size_t getNum() const {
		return num;
	}

};

int main()
{
	{ // 문제 1
		MemoryMonster mm;
		mm.show();
	}
	{ // 문제 2
		MemoryMonster mm1;
		MemoryMonster mm2{ mm1 };	// 복사생성

		mm1.show();
		mm2.show();
	}
	{ // 문제 3
		MemoryMonster mm;	// [100][번지]

		for (int i = 0; i < 10; ++i)
			mm.special();

		mm.show();
	}
	{ // 문제 4
		MemoryMonster monsters[10];

		default_random_engine dre;
		uniform_int_distribution<> uid{ 1, 10 };
		
		for (MemoryMonster& mm : monsters) {
			int num = uid(dre);
			for (int i = 0; i < num; ++i)
				mm.special();
		}

		sort(begin(monsters), end(monsters), [](const MemoryMonster& a, const MemoryMonster& b) {
				return a.getNum() < b.getNum();
			});

		for (MemoryMonster& mm : monsters)
			mm.show();
	}
	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-11 오후 12:28:59 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.11 수    (10주 2일)
//
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <random>
#include <algorithm>
#include "save.h"
using namespace std;

class MemoryMonster {
	size_t num{ 100 };
	int* p{ nullptr };
public:
	MemoryMonster() : num{ 100 }, p{ new int[100] } {
		for (int i = 0; i < num; ++i)
			p[i] = 100;
	}

	~MemoryMonster() {
		delete[] p;
	}

	MemoryMonster(const MemoryMonster& other) : num{ other.num }, p{ new int[num] } {
		for (int i = 0; i < num; ++i)
			p[i] = other.p[i] + 1;
	}
	MemoryMonster& operator=(const MemoryMonster& other) {
		if (this == &other)
			return *this;
		delete[] p;
		num = other.num;
		p = new int[num];
		for (int i = 0; i < num; ++i)
			p[i] = num;
		return *this;
	}


	void show() const {
		cout << "MemoryMonster - int의 개수 : " << num << ", int의 값 : " << p[0] << endl;
	}

	void special() {
		delete[] p;
		num *= 2;
		p = new int[num];
		for (int i = 0; i < num; ++i)
			p[i] = num;
	}

	size_t getNum() const {
		return num;
	}

};

int main()
{
	{ // 문제 1
		MemoryMonster mm;
		mm.show();
	}
	{ // 문제 2
		MemoryMonster mm1;
		MemoryMonster mm2{ mm1 };	// 복사생성

		mm1.show();
		mm2.show();
	}
	{ // 문제 3
		MemoryMonster mm;	// [100][번지]

		for (int i = 0; i < 10; ++i)
			mm.special();

		mm.show();
	}
	{ // 문제 4
		MemoryMonster monsters[10];

		default_random_engine dre;
		uniform_int_distribution<> uid{ 1, 10 };
		
		for (MemoryMonster& mm : monsters) {
			int num = uid(dre);
			for (int i = 0; i < num; ++i)
				mm.special();
		}

		sort(begin(monsters), end(monsters), [](const MemoryMonster& a, const MemoryMonster& b) {
				return a.getNum() < b.getNum();
			});

		for (MemoryMonster& mm : monsters)
			mm.show();
	}
	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-11 오후 12:29:34 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.11 수    (10주 2일)
//
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <random>
#include <algorithm>
#include "save.h"
using namespace std;

class MemoryMonster {
	size_t num{ 100 };
	int* p{ nullptr };
public:
	MemoryMonster() : num{ 100 }, p{ new int[100] } {
		for (int i = 0; i < num; ++i)
			p[i] = 100;
	}

	~MemoryMonster() {
		delete[] p;
	}

	MemoryMonster(const MemoryMonster& other) : num{ other.num }, p{ new int[num] } {
		for (int i = 0; i < num; ++i)
			p[i] = other.p[i] + 1;
	}
	MemoryMonster& operator=(const MemoryMonster& other) {
		//if (this == &other)
		//	return *this;
		delete[] p;
		num = other.num;
		p = new int[num];
		for (int i = 0; i < num; ++i)
			p[i] = num;
		return *this;
	}


	void show() const {
		cout << "MemoryMonster - int의 개수 : " << num << ", int의 값 : " << p[0] << endl;
	}

	void special() {
		delete[] p;
		num *= 2;
		p = new int[num];
		for (int i = 0; i < num; ++i)
			p[i] = num;
	}

	size_t getNum() const {
		return num;
	}

};

int main()
{
	{ // 문제 1
		MemoryMonster mm;
		mm.show();
	}
	{ // 문제 2
		MemoryMonster mm1;
		MemoryMonster mm2{ mm1 };	// 복사생성

		mm1.show();
		mm2.show();
	}
	{ // 문제 3
		MemoryMonster mm;	// [100][번지]

		for (int i = 0; i < 10; ++i)
			mm.special();

		mm.show();
	}
	{ // 문제 4
		MemoryMonster monsters[10];

		default_random_engine dre;
		uniform_int_distribution<> uid{ 1, 10 };
		
		for (MemoryMonster& mm : monsters) {
			int num = uid(dre);
			for (int i = 0; i < num; ++i)
				mm.special();
		}

		sort(begin(monsters), end(monsters), [](const MemoryMonster& a, const MemoryMonster& b) {
				return a.getNum() < b.getNum();
			});

		for (MemoryMonster& mm : monsters)
			mm.show();
	}
	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-11 오후 12:29:48 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.11 수    (10주 2일)
//
// 
// 시험 2. 11월 9일 (월) 10주 1일
//-----------------------------------------------------------------------------
#include <iostream>
#include <random>
#include <algorithm>
#include "save.h"
using namespace std;

class MemoryMonster {
	size_t num{ 100 };
	int* p{ nullptr };
public:
	MemoryMonster() : num{ 100 }, p{ new int[100] } {
		for (int i = 0; i < num; ++i)
			p[i] = 100;
	}

	~MemoryMonster() {
		delete[] p;
	}

	MemoryMonster(const MemoryMonster& other) : num{ other.num }, p{ new int[num] } {
		for (int i = 0; i < num; ++i)
			p[i] = other.p[i] + 1;
	}
	MemoryMonster& operator=(const MemoryMonster& other) {
		if (this == &other)
			return *this;
		delete[] p;
		num = other.num;
		p = new int[num];
		for (int i = 0; i < num; ++i)
			p[i] = other.p[i];
		return *this;
	}


	void show() const {
		cout << "MemoryMonster - int의 개수 : " << num << ", int의 값 : " << p[0] << endl;
	}

	void special() {
		delete[] p;
		num *= 2;
		p = new int[num];
		for (int i = 0; i < num; ++i)
			p[i] = num;
	}

	size_t getNum() const {
		return num;
	}

};

int main()
{
	{ // 문제 1
		MemoryMonster mm;
		mm.show();
	}
	{ // 문제 2
		MemoryMonster mm1;
		MemoryMonster mm2{ mm1 };	// 복사생성

		mm1.show();
		mm2.show();
	}
	{ // 문제 3
		MemoryMonster mm;	// [100][번지]

		for (int i = 0; i < 10; ++i)
			mm.special();

		mm.show();
	}
	{ // 문제 4
		MemoryMonster monsters[10];

		default_random_engine dre;
		uniform_int_distribution<> uid{ 1, 10 };
		
		for (MemoryMonster& mm : monsters) {
			int num = uid(dre);
			for (int i = 0; i < num; ++i)
				mm.special();
		}

		sort(begin(monsters), end(monsters), [](const MemoryMonster& a, const MemoryMonster& b) {
				return a.getNum() < b.getNum();
			});

		for (MemoryMonster& mm : monsters)
			mm.show();
	}
	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-11 오후 12:47:53 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.11 수    (10주 2일)
//
// 
// 연산자 오버로딩
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

int main()
{
	int a[10];

	cout << a[-1] << endl;
	cout << a[10] << endl;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-11 오후 12:48:34 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.11 수    (10주 2일)
//
// 
// 연산자 오버로딩
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

int main()
{
	int a[10];

	cout << *(a + -1) << endl;
	cout << *(a + 10) << endl;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-11 오후 1:01:40 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.11 수    (10주 2일)
//
// 
// 연산자 오버로딩
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

class SafeIntArray {
	size_t num;
	int* p;
public:
	SafeIntArray(size_t n) : num{ n } {
		p = new int[num] {};
	}

	int operator[](int n) {
		if ((n < 0) or (num <= n))
			cout << "범위를 벗어남" << endl;
		return p[n];
	}

};

int main()
{
	SafeIntArray a{ 10 };	// 10개의 정수를 저장할 공간 확보
							// 모든 값은 0으로

	cout << a[-1] << endl;	// 범위를 벗어남
	cout << a[10] << endl;	// 범위를 벗어남

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-11 오후 1:02:48 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.11 수    (10주 2일)
//
// 
// 연산자 오버로딩
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

class SafeIntArray {
	size_t num;
	int* p;
public:
	SafeIntArray(size_t n) : num{ n } {
		p = new int[num] {};
	}

	int operator[](int n) {
		if ((n < 0) or (num <= n))
			cout << "범위를 벗어남" << endl;
		return p[n];
	}

};

int main()
{
	SafeIntArray a{ 10 };	// 10개의 정수를 저장할 공간 확보
							// 모든 값은 0으로

	// optional
	cout << a[-1] << endl;	// 범위를 벗어남
	cout << a[10] << endl;	// 범위를 벗어남

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-11 오후 1:03:49 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.11 수    (10주 2일)
//
// 
// 연산자 오버로딩
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

class SafeIntArray {
	size_t num;
	int* p;
public:
	SafeIntArray(size_t n) : num{ n } {
		p = new int[num] {};
	}

	int operator[](int n) {
		if ((n < 0) or (num <= n))
			cout << "범위를 벗어남" << endl;
		return p[n];
	}

	size_t size() const {
		return num;
	}

};

int main()
{
	SafeIntArray a{ 10 };	// 10개의 정수를 저장할 공간 확보
							// 모든 값은 0으로

	for (int i = 0; i < a.size(); ++i)
		cout << a[i] << endl;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-11 오후 1:11:11 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.11 수    (10주 2일)
//
// 
// 연산자 오버로딩
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

class SafeIntArray {
	size_t num;
	int* p;
public:
	SafeIntArray(size_t n) : num{ n } {
		p = new int[num] {};
	}

	int& operator[](int n) {
		if ((n < 0) or (num <= n))
			cout << "범위를 벗어남" << endl;
		return p[n];
	}

	size_t size() const {
		return num;
	}

};

int main()
{
	SafeIntArray a{ 10 };	// 10개의 정수를 저장할 공간 확보
							// 모든 값은 0으로
	for (int i = 0; i < a.size(); ++i)
		a[i] = i;


	for (int i = 0; i < a.size(); ++i)
		cout << a[i] << endl;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-11 오후 1:11:53 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.11 수    (10주 2일)
//
// 
// 연산자 오버로딩
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

class SafeIntArray {
	size_t num;
	int* p;
public:
	SafeIntArray(size_t n) : num{ n } {
		p = new int[num] {};
	}

	int& operator[](int n) {
		if ((n < 0) or (num <= n))
			cout << "범위를 벗어남" << endl;
		return p[n];
	}

	size_t size() const {
		return num;
	}

};

int main()
{
	SafeIntArray a{ 10 };	// 10개의 정수를 저장할 공간 확보
							// 모든 값은 0으로
	for (int i = 0; i < a.size(); ++i)
		//a[i] = i;
		a.operator[](i) = i;


	for (int i = 0; i < a.size(); ++i)
		cout << a[i] << endl;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-11 오후 1:14:01 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.11 수    (10주 2일)
//
// 
// 연산자 오버로딩
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

class SafeIntArray {
	size_t num;
	int* p;
public:
	SafeIntArray(size_t n) : num{ n } {
		p = new int[num] {};
	}

	int& operator[](int n) {		// 쓰기
		if ((n < 0) or (num <= n))
			cout << "범위를 벗어남" << endl;
		return p[n];
	}

	int operator[](int n) const {		// 읽기
		if ((n < 0) or (num <= n))
			cout << "범위를 벗어남" << endl;
		return p[n];
	}

	size_t size() const {
		return num;
	}

};

int main()
{
	SafeIntArray a{ 10 };	// 10개의 정수를 저장할 공간 확보
							// 모든 값은 0으로
	for (int i = 0; i < a.size(); ++i)
		a[i] = i;

	for (int i = 0; i < a.size(); ++i)
		cout << a[i] << endl;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-11 오후 1:18:32 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.11 수    (10주 2일)
//
// 
// 연산자 오버로딩
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

class SafeIntArray {
	size_t num;
	int* p;
public:
	SafeIntArray(size_t n) : num{ n } {
		p = new int[num] {};
	}

	int& operator[](int n) {		// 쓰기
		if ((n < 0) or (num <= n))
			cout << "범위를 벗어남" << endl;
		return p[n];
	}

	int operator[](int n) const {		// 읽기
		if ((n < 0) or (num <= n))
			cout << "범위를 벗어남" << endl;
		return p[n];
	}

	size_t size() const {
		return num;
	}

	friend ostream& operator<<(ostream& os, const SafeIntArray&);

};

ostream& operator<<(ostream& os, const SafeIntArray& sia)
{
	for (int i = 0; i < sia.num; ++i)
		os << sia.p[i] << ' ';

	return os;
}


int main()
{
	SafeIntArray a{ 100 };
							
	for (int i = 0; i < a.size(); ++i)
		a[i] = i * i;

	cout << a << endl;		// a의 모든 값을 화면에 출력

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-11 오후 1:20:07 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.11 수    (10주 2일)
//
// 
// 연산자 오버로딩
//-----------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include "save.h"
using namespace std;

class SafeIntArray {
	size_t num;
	int* p;
public:
	SafeIntArray(size_t n) : num{ n } {
		p = new int[num] {};
	}

	int& operator[](int n) {		// 쓰기
		if ((n < 0) or (num <= n))
			cout << "범위를 벗어남" << endl;
		return p[n];
	}

	int operator[](int n) const {		// 읽기
		if ((n < 0) or (num <= n))
			cout << "범위를 벗어남" << endl;
		return p[n];
	}

	size_t size() const {
		return num;
	}

	friend ostream& operator<<(ostream& os, const SafeIntArray&);

};

ostream& operator<<(ostream& os, const SafeIntArray& sia)
{
	for (int i = 0; i < sia.num; ++i)
		os << sia.p[i] << ' ';

	return os;
}


int main()
{
	SafeIntArray a{ 100 };
							
	for (int i = 0; i < a.size(); ++i)
		a[i] = i * i;
	
	ofstream out("안전배열100개");
	out << a << endl;		// a의 모든 값을 파일에 출력

	// in >> a;		다음시간


	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-16 오후 1:36:37 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.16 월    (11주 1일)
//
// 
// 연산자 오버로딩
//-----------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include "save.h"
using namespace std;

class SafeIntArray {
	size_t num;
	int* p;
public:
	SafeIntArray(size_t n) : num{ n } {
		p = new int[num] {};
	}

	int& operator[](int n) {		// 쓰기
		if ((n < 0) or (num <= n))
			cout << "범위를 벗어남" << endl;
		return p[n];
	}

	int operator[](int n) const {		// 읽기
		if ((n < 0) or (num <= n))
			cout << "범위를 벗어남" << endl;
		return p[n];
	}

	size_t size() const {
		return num;
	}

	friend ostream& operator<<(ostream& os, const SafeIntArray&);

};

ostream& operator<<(ostream& os, const SafeIntArray& sia)
{
	for (int i = 0; i < sia.num; ++i)
		os << sia.p[i] << ' ';

	return os;
}

// [문제] 파일 "안전배열100개"에 SafeIntArray 객체 100개가 저장되어 있다
// 객체를 읽어 객체의 배열에 저장하시오.

int main()
{
	// 파일을 연다
	ifstream in("안전배열100개");

	if (!in) {
		cout << "파일을 열지 못함" << endl;
		return 1234;
	}

	// 한 번에 하나씩 읽어온다

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-16 오후 1:51:31 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.16 월    (11주 1일)
//
// 
// 연산자 오버로딩
//-----------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include "save.h"
using namespace std;

class SafeIntArray {
	size_t num;
	int* p;
public:
	SafeIntArray() {
		num = 0;
		p = nullptr;
	}

	SafeIntArray(size_t n) : num{ n } {
		p = new int[num] {};
	}

	~SafeIntArray() { delete[] p; }

	int& operator[](int n) {		// 쓰기
		if ((n < 0) or (num <= n))
			cout << "범위를 벗어남" << endl;
		return p[n];
	}

	int operator[](int n) const {		// 읽기
		if ((n < 0) or (num <= n))
			cout << "범위를 벗어남" << endl;
		return p[n];
	}

	size_t size() const {
		return num;
	}

	void setNum(int n) {
		delete[] p;
		num = n;
		p = new int[num];
	}

	friend ostream& operator<<(ostream& os, const SafeIntArray&);
	friend istream& operator>>(istream& is, SafeIntArray&);

};

ostream& operator<<(ostream& os, const SafeIntArray& sia)
{
	for (int i = 0; i < sia.num; ++i)
		os << sia.p[i] << ' ';

	return os;
}

istream& operator>>(istream& is, SafeIntArray& sia)
{
	for (int i = 0; i < sia.num; ++i) {
		int num;
		is >> num;
		cout << num << " -- ";
		sia.p[i] = num;
	}

	return is;
}

// [문제] 파일 "안전배열100개"에 SafeIntArray 객체 한 개가 저장되어 있다
// (저장된 것은 정수 100개로 된 안전배열이다.)
// 객체를 읽어 객체의 배열에 저장하시오.

int main()
{
	// 파일을 연다
	ifstream in("안전배열100개");

	if (!in) {
		cout << "파일을 열지 못함" << endl;
		return 1234;
	}

	// 한 번에 하나씩 읽어온다
	SafeIntArray sia;		// [100][ p ] --> [0][1][4][9][16]
	
	sia.setNum(100);

	in >> sia;

	cout << sia;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-16 오후 2:04:12 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.16 월    (11주 1일)
//
// 
// 연산자 오버로딩
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

class String {
	size_t num;
	char* p;
public:
	String() {
		num = 0;
		p = { nullptr };
	}
	
	String(const char* str) {
		num = strlen(str);
		p = new char[num];
		memcpy(p, str, num);
	}

	~String() { delete[] p; }

	String(const String& other) {
		num = other.num;
		p = new char[num];
		memcpy(p, other.p, num);
	}

	String operator+(const String& other) {
		String temp = *this;
		num += other.num;
		delete[] p;
		p = new char[num];
		memcpy(p, temp.p, temp.num);
		memcpy(p + temp.num, other.p, other.num);
		return *this;
	}

	friend ostream& operator<<(ostream& os, const String&);

};

ostream& operator<<(ostream& os, const String& str)
{
	for (int i = 0; i < str.num; ++i)
		os << str.p[i];
	return os;
}

int main()
{
	String a{ "12345" };
	String b{ "67890abcde" };

	String c = a + b;

	cout << c << endl;	// 1234567890abcde

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-16 오후 2:04:22 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.16 월    (11주 1일)
//
// 
// 연산자 오버로딩
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

class String {
	size_t num;
	char* p;
public:
	String() {
		num = 0;
		p = { nullptr };
	}
	
	String(const char* str) {
		num = strlen(str);
		p = new char[num];
		memcpy(p, str, num);
	}

	~String() { delete[] p; }

	String(const String& other) {
		num = other.num;
		p = new char[num];
		memcpy(p, other.p, num);
	}

	String operator+(const String& other) {
		String temp = *this;
		num += other.num;
		delete[] p;
		p = new char[num];
		memcpy(p, temp.p, temp.num);
		memcpy(p + temp.num, other.p, other.num);
		return *this;
	}

	friend ostream& operator<<(ostream& os, const String&);

};

ostream& operator<<(ostream& os, const String& str)
{
	for (int i = 0; i < str.num; ++i)
		os << str.p[i];
	return os;
}

int main()
{
	String a{ "12345dfdag" };
	String b{ "67890abcde" };

	String c = a + b;

	cout << c << endl;	// 1234567890abcde

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-16 오후 2:04:47 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.16 월    (11주 1일)
//
// 
// 연산자 오버로딩
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

class String {
	size_t num;
	char* p;
public:
	String(const char* str) {
		num = strlen(str);
		p = new char[num];
		memcpy(p, str, num);
	}

	~String() { delete[] p; }

	String(const String& other) {
		num = other.num;
		p = new char[num];
		memcpy(p, other.p, num);
	}

	String operator+(const String& other) {
		String temp = *this;
		num += other.num;
		delete[] p;
		p = new char[num];
		memcpy(p, temp.p, temp.num);
		memcpy(p + temp.num, other.p, other.num);
		return *this;
	}

	friend ostream& operator<<(ostream& os, const String&);

};

ostream& operator<<(ostream& os, const String& str)
{
	for (int i = 0; i < str.num; ++i)
		os << str.p[i];
	return os;
}

int main()
{
	String a{ "12345" };
	String b{ "67890abcde" };

	String c = a + b;

	cout << c << endl;	// 1234567890abcde

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-16 오후 2:05:18 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.16 월    (11주 1일)
//
// 
// 연산자 오버로딩
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

class String {
	size_t num;
	char* p;
public:
	String(const char* str) {
		num = strlen(str);
		p = new char[num];
		memcpy(p, str, num);
	}

	~String() { delete[] p; cout << "bye"; }

	String(const String& other) {
		num = other.num;
		p = new char[num];
		memcpy(p, other.p, num);
	}

	String operator+(const String& other) {
		String temp = *this;
		num += other.num;
		delete[] p;
		p = new char[num];
		memcpy(p, temp.p, temp.num);
		memcpy(p + temp.num, other.p, other.num);
		return *this;
	}

	friend ostream& operator<<(ostream& os, const String&);

};

ostream& operator<<(ostream& os, const String& str)
{
	for (int i = 0; i < str.num; ++i)
		os << str.p[i];
	return os;
}

int main()
{
	String a{ "12345" };
	String b{ "67890abcde" };

	String c = a + b;

	cout << c << endl;	// 1234567890abcde

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-16 오후 2:07:52 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.16 월    (11주 1일)
//
// 
// 연산자 오버로딩
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

class String {
	size_t num;
	char* p;
public:
	String(const char* str) {
		num = strlen(str);
		p = new char[num];
		memcpy(p, str, num);
	}

	~String() { delete[] p; }

	String(const String& other) {
		num = other.num;
		p = new char[num];
		memcpy(p, other.p, num);
	}

	String operator+(const String& other) {
		String temp = *this;
		num += other.num;
		delete[] p;
		p = new char[num];
		memcpy(p, temp.p, temp.num);
		memcpy(p + temp.num, other.p, other.num);
		return *this;
	}

	friend ostream& operator<<(ostream& os, const String&);

};

ostream& operator<<(ostream& os, const String& str)
{
	for (int i = 0; i < str.num; ++i)
		os << str.p[i];
	return os;
}

int main()
{
	String a{ "12345" };
	String b{ "67890abcde" };

	//String c = a + b;
	String c = a.operator+(b);

	cout << c << endl;	// 1234567890abcde

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-16 오후 2:08:03 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.16 월    (11주 1일)
//
// 
// 연산자 오버로딩
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

class String {
	size_t num;
	char* p;
public:
	String(const char* str) {
		num = strlen(str);
		p = new char[num];
		memcpy(p, str, num);
	}

	~String() { delete[] p; }

	String(const String& other) {
		num = other.num;
		p = new char[num];
		memcpy(p, other.p, num);
	}

	String operator+(const String& other) {
		String temp = *this;
		num += other.num;
		delete[] p;
		p = new char[num];
		memcpy(p, temp.p, temp.num);
		memcpy(p + temp.num, other.p, other.num);
		return *this;
	}

	friend ostream& operator<<(ostream& os, const String&);

};

ostream& operator<<(ostream& os, const String& str)
{
	for (int i = 0; i < str.num; ++i)
		os << str.p[i];
	return os;
}

int main()
{
	String a{ "12345" };
	String b{ "67890abcde" };

	//String c = a + b;
	String c{ a.operator+(b) };

	cout << c << endl;	// 1234567890abcde

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-16 오후 2:19:16 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.16 월    (11주 1일)
//
// 
// 연산자 오버로딩
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

class String {
	size_t num;
	char* p;
public:
	String(const char* str) {
		num = strlen(str);
		p = new char[num];
		memcpy(p, str, num);
	}

	~String() { delete[] p; }

	String(const String& other) {
		num = other.num;
		p = new char[num];
		memcpy(p, other.p, num);
	}

	String operator+(const String& other) {
		String temp = *this;
		num += other.num;
		delete[] p;
		p = new char[num];
		memcpy(p, temp.p, temp.num);
		memcpy(p + temp.num, other.p, other.num);
		return *this;
	}

	friend ostream& operator<<(ostream& os, const String&);

};

ostream& operator<<(ostream& os, const String& str)
{
	for (int i = 0; i < str.num; ++i)
		os << str.p[i];
	return os;
}

/*class String {
	size_t num;
	char* p;

public:
	String(const char* s) {
		num = strlen(s);
		p = new char[num];
		for (int i = 0; i < num; ++i)
			p[i] = s[i];
	}
	~String() { delete[] p; }

	String operator+(const String& rhs) const {
		String temp;

		return temp;
	}
};*/





int main()
{
	String a{ "12345" };
	String b{ "67890abcde" };

	String c = a + b;

	cout << c << endl;	// 1234567890abcde
	cout << a << endl;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-16 오후 2:27:51 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.16 월    (11주 1일)
//
// 
// 연산자 오버로딩
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

/*class String {
	size_t num;
	char* p;
public:
	String(const char* str) {
		num = strlen(str);
		p = new char[num];
		memcpy(p, str, num);
	}

	~String() { delete[] p; }

	String(const String& other) {
		num = other.num;
		p = new char[num];
		memcpy(p, other.p, num);
	}

	String operator+(const String& other) {
		String temp = *this;
		num += other.num;
		delete[] p;
		p = new char[num];
		memcpy(p, temp.p, temp.num);
		memcpy(p + temp.num, other.p, other.num);
		return *this;
	}

	friend ostream& operator<<(ostream& os, const String&);

};

ostream& operator<<(ostream& os, const String& str)
{
	for (int i = 0; i < str.num; ++i)
		os << str.p[i];
	return os;
}*/

class String {
	size_t num;
	char* p;

public:
	String() {
		num = 0;
		p = { nullptr };
	}
	String(const char* s) {
		num = strlen(s);
		p = new char[num];
		for (int i = 0; i < num; ++i)
			p[i] = s[i];
	}
	~String() { delete[] p; }

	String(const String& other) {
		num = other.num;
		p = new char[num];
		for (int i = 0; i < num; ++i)
			p[i] = other.p[i];
	}

	String operator+(const String& rhs) const {
		String temp;
		temp.num = num + rhs.num;
		temp.p = new char[temp.num];
		for (int i = 0; i < num; ++i)
			temp.p[i] = p[i];
		for (int i = 0; i < rhs.num; ++i)
			temp.p[num + i] = rhs.p[i];
		return temp;
	}

	friend ostream& operator<<(ostream& os, const String&);

};

ostream& operator<<(ostream& os, const String& s)
{
	for (int i = 0; i < s.num; ++i)
		os << s.p[i];
	return os;
}



int main()
{
	String a{ "12345" };
	String b{ "67890abcde" };

	String c = a + b;

	cout << c << endl;	// 1234567890abcde

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-16 오후 2:28:39 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.16 월    (11주 1일)
//
// 
// 연산자 오버로딩
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

/*class String {
	size_t num;
	char* p;
public:
	String(const char* str) {
		num = strlen(str);
		p = new char[num];
		memcpy(p, str, num);
	}

	~String() { delete[] p; }

	String(const String& other) {
		num = other.num;
		p = new char[num];
		memcpy(p, other.p, num);
	}

	String operator+(const String& other) {
		String temp = *this;
		num += other.num;
		delete[] p;
		p = new char[num];
		memcpy(p, temp.p, temp.num);
		memcpy(p + temp.num, other.p, other.num);
		return *this;
	}

	friend ostream& operator<<(ostream& os, const String&);

};

ostream& operator<<(ostream& os, const String& str)
{
	for (int i = 0; i < str.num; ++i)
		os << str.p[i];
	return os;
}*/

class String {
	size_t num;
	char* p;

public:
	String() {
		num = 0;
		p = { nullptr };
	}
	String(const char* s) {
		num = strlen(s);
		p = new char[num];
		for (int i = 0; i < num; ++i)
			p[i] = s[i];
	}
	~String() { delete[] p; }

	String(const String& other) {
		num = other.num;
		p = new char[num];
		for (int i = 0; i < num; ++i)
			p[i] = other.p[i];
	}

	String operator+(const String& rhs) const {
		String temp;
		temp.num = num + rhs.num;
		temp.p = new char[temp.num];
		for (int i = 0; i < num; ++i)
			temp.p[i] = p[i];
		for (int i = 0; i < rhs.num; ++i)
			temp.p[num + i] = rhs.p[i];
		return temp;
	}

	friend ostream& operator<<(ostream& os, const String&);

};

ostream& operator<<(ostream& os, const String& s)
{
	for (int i = 0; i < s.num; ++i)
		os << s.p[i];
	return os;
}



int main()
{
	String a{ "12345dy7sdhdfhjxcvx adga g cvcgdfhada" };
	String b{ "67890abcafhhfafgafdgg aga dasdgde" };

	String c = a + b;

	cout << c << endl;	// 1234567890abcde

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-16 오후 2:49:27 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.16 월    (11주 1일)
//
// 
// 연산자 오버로딩
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <random>
#include <fstream>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<> uid_len{ 5, 30 };
uniform_int_distribution<> uid_char{ 'a', 'z' };
uniform_int_distribution<> uid;

class Dog {
	string name;	// 이름: 길이[5, 30], 문자['a', 'z']
	int id;			// 그냥 랜덤 정수

public:
	Dog() {
		for ( int i = 0; i < uid_len( dre ); ++i )
			name += uid_char( dre );
		id = uid( dre );
	}

	void show() const {
		cout << id << " - " << name << endl;
	}
};

// [문제] Dog 객체 10'000개를 파일 "Dog만객체"에 저장하라.
// 디폴트 생성하면 멤버변수에 적은 것과 같이 생성

int main()
{
	Dog dog;

	dog.show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-16 오후 2:52:22 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.16 월    (11주 1일)
//
// 
// 연산자 오버로딩
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <random>
#include <fstream>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<> uid_len{ 5, 30 };
uniform_int_distribution<> uid_char{ 'a', 'z' };
uniform_int_distribution<> uid;

class Dog {
	string name;	// 이름: 길이[5, 30], 문자['a', 'z']
	int id;			// 그냥 랜덤 정수

public:
	Dog() {
		for ( int i = 0; i < uid_len( dre ); ++i )
			name += uid_char( dre );
		id = uid( dre );
	}

	void show() const {
		cout << id << " - " << name << endl;
	}

	friend ostream& operator<<(ostream&, const Dog&);

};

ostream& operator<<(ostream& os, const Dog& dog)
{
	os << dog.id << " - " << dog.name << endl;
	return os;
}


// [문제] Dog 객체 10'000개를 파일 "Dog만객체"에 저장하라.
// 디폴트 생성하면 멤버변수에 적은 것과 같이 생성

int main()
{
	Dog dog;

	// 파일에 기록할때는 
	// out << dog를 이용할 수 있어야 한다

	cout << dog;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-16 오후 2:52:29 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.16 월    (11주 1일)
//
// 
// 연산자 오버로딩
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <random>
#include <fstream>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<> uid_len{ 5, 30 };
uniform_int_distribution<> uid_char{ 'a', 'z' };
uniform_int_distribution<> uid;

class Dog {
	string name;	// 이름: 길이[5, 30], 문자['a', 'z']
	int id;			// 그냥 랜덤 정수

public:
	Dog() {
		for ( int i = 0; i < uid_len( dre ); ++i )
			name += uid_char( dre );
		id = uid( dre );
	}

	void show() const {
		cout << id << " - " << name << endl;
	}

	friend ostream& operator<<(ostream&, const Dog&);

};

ostream& operator<<(ostream& os, const Dog& dog)
{
	os << dog.id << " ---- " << dog.name << endl;
	return os;
}


// [문제] Dog 객체 10'000개를 파일 "Dog만객체"에 저장하라.
// 디폴트 생성하면 멤버변수에 적은 것과 같이 생성

int main()
{
	Dog dog;

	// 파일에 기록할때는 
	// out << dog를 이용할 수 있어야 한다

	cout << dog;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-16 오후 2:53:47 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.16 월    (11주 1일)
//
// 
// 연산자 오버로딩
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <random>
#include <fstream>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<> uid_len{ 5, 30 };
uniform_int_distribution<> uid_char{ 'a', 'z' };
uniform_int_distribution<> uid;

class Dog {
	string name;	// 이름: 길이[5, 30], 문자['a', 'z']
	int id;			// 그냥 랜덤 정수

public:
	Dog() {
		for ( int i = 0; i < uid_len( dre ); ++i )
			name += uid_char( dre );
		id = uid( dre );
	}

	void show() const {
		cout << id << " - " << name << endl;
	}

	friend ostream& operator<<(ostream&, const Dog&);

};

ostream& operator<<(ostream& os, const Dog& dog)
{
	os << dog.id << " - " << dog.name << endl;
	return os;
}


// [문제] Dog 객체 10'000개를 파일 "Dog만객체"에 저장하라.
// 디폴트 생성하면 멤버변수에 적은 것과 같이 생성

int main()
{
	Dog dog;

	ofstream out("Dog만객체");

	// 파일에 기록할때는 
	// out << dog를 이용할 수 있어야 한다

	out << dog;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-16 오후 2:54:55 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.16 월    (11주 1일)
//
// 
// 연산자 오버로딩
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <random>
#include <fstream>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<> uid_len{ 5, 30 };
uniform_int_distribution<> uid_char{ 'a', 'z' };
uniform_int_distribution<> uid;

class Dog {
	string name;	// 이름: 길이[5, 30], 문자['a', 'z']
	int id;			// 그냥 랜덤 정수

public:
	Dog() {
		for ( int i = 0; i < uid_len( dre ); ++i )
			name += uid_char( dre );
		id = uid( dre );
	}

	void show() const {
		cout << id << " - " << name << endl;
	}

	friend ostream& operator<<(ostream&, const Dog&);

};

ostream& operator<<(ostream& os, const Dog& dog)
{
	os << dog.id << " - " << dog.name << endl;
	return os;
}


// [문제] Dog 객체 10'000개를 파일 "Dog만객체"에 저장하라.
// 디폴트 생성하면 멤버변수에 적은 것과 같이 생성

int main()
{
	Dog dog[1000];



	// 파일에 기록할때는 
	// out << dog를 이용할 수 있어야 한다

	cout << dog;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-16 오후 2:58:05 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.16 월    (11주 1일)
//
// 
// 연산자 오버로딩
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <random>
#include <fstream>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<> uid_len{ 5, 30 };
uniform_int_distribution<> uid_char{ 'a', 'z' };
uniform_int_distribution<> uid;

class Dog {
	string name;	// 이름: 길이[5, 30], 문자['a', 'z']
	int id;			// 그냥 랜덤 정수

public:
	Dog() {
		for ( int i = 0; i < uid_len( dre ); ++i )
			name += uid_char( dre );
		id = uid( dre );
	}

	void show() const {
		cout << id << " - " << name << endl;
	}

	friend ostream& operator<<(ostream&, const Dog&);

};

ostream& operator<<(ostream& os, const Dog& dog)
{
	while (os)
		os << dog.id << " - " << dog.name << endl;
	return os;
}


// [문제] Dog 객체 10'000개를 파일 "Dog만객체"에 저장하라.
// 디폴트 생성하면 멤버변수에 적은 것과 같이 생성

int main()
{
	Dog dog[1000];



	// 파일에 기록할때는 
	// out << dog를 이용할 수 있어야 한다

	cout << dog;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-16 오후 3:00:04 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.16 월    (11주 1일)
//
// 
// 연산자 오버로딩
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <random>
#include <fstream>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<> uid_len{ 5, 30 };
uniform_int_distribution<> uid_char{ 'a', 'z' };
uniform_int_distribution<> uid;

class Dog {
	string name;	// 이름: 길이[5, 30], 문자['a', 'z']
	int id;			// 그냥 랜덤 정수

public:
	Dog() {
		for ( int i = 0; i < uid_len( dre ); ++i )
			name += uid_char( dre );
		id = uid( dre );
	}

	void show() const {
		cout << id << " - " << name << endl;
	}

	friend ostream& operator<<(ostream&, const Dog&);

};

ostream& operator<<(ostream& os, const Dog& dog)
{
	os << dog.id << " - " << dog.name << endl;
	return os;
}


// [문제] Dog 객체 10'000개를 파일 "Dog만객체"에 저장하라.
// 디폴트 생성하면 멤버변수에 적은 것과 같이 생성

int main()
{
	Dog dog[1000];



	// 파일에 기록할때는 
	// out << dog를 이용할 수 있어야 한다
	for ( const Dog& dog : dog)
		cout << dog;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-16 오후 3:02:53 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.16 월    (11주 1일)
//
// 
// 연산자 오버로딩
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <random>
#include <fstream>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<> uid_len{ 5, 30 };
uniform_int_distribution<> uid_char{ 'a', 'z' };
uniform_int_distribution<> uid;

class Dog {
	string name;	// 이름: 길이[5, 30], 문자['a', 'z']
	int id;			// 그냥 랜덤 정수

public:
	Dog() {
		for ( int i = 0; i < uid_len( dre ); ++i )
			name += uid_char( dre );
		id = uid( dre );
	}

	void show() const {
		cout << id << " - " << name << endl;
	}

	friend ostream& operator<<(ostream&, const Dog&);

};

ostream& operator<<(ostream& os, const Dog& dog)
{
	os << dog.name << dog.id;
	return os;
}


// [문제] Dog 객체 10'000개를 파일 "Dog만객체"에 저장하라.
// 디폴트 생성하면 멤버변수에 적은 것과 같이 생성

int main()
{
	Dog dog;
	dog.show();

	cout << dog;


	// 파일에 기록할때는 
	// out << dog를 이용할 수 있어야 한다
	//for ( const Dog& dog : dog)
	//	cout << dog;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-16 오후 3:03:48 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.16 월    (11주 1일)
//
// 
// 연산자 오버로딩
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <random>
#include <fstream>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<> uid_len{ 5, 30 };
uniform_int_distribution<> uid_char{ 'a', 'z' };
uniform_int_distribution<> uid;

class Dog {
	string name;	// 이름: 길이[5, 30], 문자['a', 'z']
	int id;			// 그냥 랜덤 정수

public:
	Dog() {
		for ( int i = 0; i < uid_len( dre ); ++i )
			name += uid_char( dre );
		id = uid( dre );
	}

	void show() const {
		cout << id << " - " << name << endl;
	}

	friend ostream& operator<<(ostream&, const Dog&);

};

ostream& operator<<(ostream& os, const Dog& dog)
{
	os << dog.name << ' ' << dog.id;
	return os;
}


// [문제] Dog 객체 10'000개를 파일 "Dog만객체"에 저장하라.
// 디폴트 생성하면 멤버변수에 적은 것과 같이 생성

int main()
{
	Dog dog;
	dog.show();

	cout << dog << endl;


	// 파일에 기록할때는 
	// out << dog를 이용할 수 있어야 한다
	//for ( const Dog& dog : dog)
	//	cout << dog;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-16 오후 3:04:55 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.16 월    (11주 1일)
//
// 
// 연산자 오버로딩
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <random>
#include <fstream>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<> uid_len{ 5, 30 };
uniform_int_distribution<> uid_char{ 'a', 'z' };
uniform_int_distribution<> uid;

class Dog {
	string name;	// 이름: 길이[5, 30], 문자['a', 'z']
	int id;			// 그냥 랜덤 정수

public:
	Dog() {
		for ( int i = 0; i < uid_len( dre ); ++i )
			name += uid_char( dre );
		id = uid( dre );
	}

	void show() const {
		cout << id << " - " << name << endl;
	}

	friend ostream& operator<<(ostream&, const Dog&);

};

ostream& operator<<(ostream& os, const Dog& dog)
{
	os << dog.name << ' ' << dog.id;
	return os;
}


// [문제] Dog 객체 10'000개를 파일 "Dog만객체"에 저장하라.
// 디폴트 생성하면 멤버변수에 적은 것과 같이 생성

int main()
{
	for (int i = 0; i < 10000; ++i) {
		Dog dog;

		cout << dog << endl;
	}


	// 파일에 기록할때는 
	// out << dog를 이용할 수 있어야 한다
	//for ( const Dog& dog : dog)
	//	cout << dog;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-16 오후 3:05:42 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.16 월    (11주 1일)
//
// 
// 연산자 오버로딩
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <random>
#include <fstream>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<> uid_len{ 5, 30 };
uniform_int_distribution<> uid_char{ 'a', 'z' };
uniform_int_distribution<> uid;

class Dog {
	string name;	// 이름: 길이[5, 30], 문자['a', 'z']
	int id;			// 그냥 랜덤 정수

public:
	Dog() {
		for ( int i = 0; i < uid_len( dre ); ++i )
			name += uid_char( dre );
		id = uid( dre );
	}

	void show() const {
		cout << id << " - " << name << endl;
	}

	friend ostream& operator<<(ostream&, const Dog&);

};

ostream& operator<<(ostream& os, const Dog& dog)
{
	os << dog.name << ' ' << dog.id;
	return os;
}


// [문제] Dog 객체 10'000개를 파일 "Dog만객체"에 저장하라.
// 디폴트 생성하면 멤버변수에 적은 것과 같이 생성

int main()
{
	ofstream out( "Dog만객체" );

	for (int i = 0; i < 10000; ++i) {
		Dog dog;

		out << dog << endl;
	}


	// 파일에 기록할때는 
	// out << dog를 이용할 수 있어야 한다
	//for ( const Dog& dog : dog)
	//	cout << dog;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-17 오후 1:09:13 - (화요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.16 월    (11주 1일)
//
// 
// 연산자 오버로딩
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <random>
#include <fstream>
#include <algorithm>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<> uid_len{ 5, 30 };
uniform_int_distribution<> uid_char{ 'a', 'z' };
uniform_int_distribution<> uid;

class Dog {
	string name;	// 이름: 길이[5, 30], 문자['a', 'z']
	int id;			// 그냥 랜덤 정수

public:
	Dog() {
		for ( int i = 0; i < uid_len( dre ); ++i )
			name += uid_char( dre );
		id = uid( dre );
	}

	Dog(const Dog& other) {
		this->~Dog();
		name = other.name;
		id = other.id;
	}

	void show() const {
		cout << id << " - " << name << endl;
	}

	int getId() const {
		return id;
	}

	friend ostream& operator<<(ostream&, const Dog&);
	friend istream& operator>>(istream&, Dog&);
};

ostream& operator<<(ostream& os, const Dog& dog)
{
	os << dog.name << ' ' << dog.id;
	return os;
}

istream& operator>>(istream& is, Dog& dog)
{
	string name;
	int id;
	is >> name >> id;
	dog.name = name;
	dog.id = id;
	return is;
}

// [문제] "Dog만객체" 파일에 있는 Dog 객체 10'000개를 읽어와라.
// id 오름차순 정렬한 후 전체를 show()로 출력하라.

// 위의 문제와는 별개로 해결해 보자 (파일에서 읽어서 해결 시작)
// (도전) 이름의 길이가 30인 Dog를 골라 "이름길이가30인Dog"에 저장하라.
// 6장!

int main()
{
	ifstream in("Dog만객체");

	Dog dog[10000];
	// Dog를 읽을때는
	// in >> dog;
	for (Dog& dog : dog)
		in >> dog;

	sort(begin(dog), end(dog), [](const Dog& dog1, const Dog& dog2) {
		return dog1.getId() < dog2.getId();
		});

	for (Dog& dog : dog)
		dog.show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-17 오후 1:12:31 - (화요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.16 월    (11주 1일)
//
// 
// 연산자 오버로딩
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <random>
#include <fstream>
#include <algorithm>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<> uid_len{ 5, 30 };
uniform_int_distribution<> uid_char{ 'a', 'z' };
uniform_int_distribution<> uid;

class Dog {
	string name{};	// 이름: 길이[5, 30], 문자['a', 'z']
	int id{};			// 그냥 랜덤 정수

public:
	Dog() {
		//for ( int i = 0; i < uid_len( dre ); ++i )
		//	name += uid_char( dre );
		//id = uid( dre );
	}

	Dog(const Dog& other) {
		this->~Dog();
		name = other.name;
		id = other.id;
	}

	void show() const {
		cout << id << " - " << name << endl;
	}

	int getId() const {
		return id;
	}

	friend ostream& operator<<(ostream&, const Dog&);
	friend istream& operator>>(istream&, Dog&);
};

ostream& operator<<(ostream& os, const Dog& dog)
{
	os << dog.name << ' ' << dog.id;
	return os;
}

istream& operator>>(istream& is, Dog& dog)
{
	string name;
	int id;
	is >> name >> id;
	dog.name = name;
	dog.id = id;
	return is;
}

// [문제] "Dog만객체" 파일에 있는 Dog 객체 10'000개를 읽어와라.
// id 오름차순 정렬한 후 전체를 show()로 출력하라.

// 위의 문제와는 별개로 해결해 보자 (파일에서 읽어서 해결 시작)
// (도전) 이름의 길이가 30인 Dog를 골라 "이름길이가30인Dog"에 저장하라.
// 6장!

int main()
{
	ifstream in("Dog만객체");

	Dog dog[10000];
	// Dog를 읽을때는
	// in >> dog;
	for (Dog& dog : dog)
		in >> dog;

	sort(begin(dog), end(dog), [](const Dog& dog1, const Dog& dog2) {
		return dog1.getId() < dog2.getId();
		});

	for (Dog& dog : dog)
		dog.show();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-17 오후 1:18:07 - (화요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.16 월    (11주 1일)
//
// 
// 연산자 오버로딩
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <random>
#include <fstream>
#include <algorithm>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<> uid_len{ 5, 30 };
uniform_int_distribution<> uid_char{ 'a', 'z' };
uniform_int_distribution<> uid;

class Dog {
	string name{};	// 이름: 길이[5, 30], 문자['a', 'z']
	int id{};			// 그냥 랜덤 정수

public:
	Dog() {
		for ( int i = 0; i < uid_len( dre ); ++i )
			name += uid_char( dre );
		id = uid( dre );
	}

	Dog(const Dog& other) {
		this->~Dog();
		name = other.name;
		id = other.id;
	}

	void show() const {
		cout << id << " - " << name << endl;
	}

	int getId() const {
		return id;
	}

	size_t getStringLenth() const {
		return name.length();
	}

	friend ostream& operator<<(ostream&, const Dog&);
	friend istream& operator>>(istream&, Dog&);
};

ostream& operator<<(ostream& os, const Dog& dog)
{
	os << dog.name << ' ' << dog.id;
	return os;
}

istream& operator>>(istream& is, Dog& dog)
{
	string name;
	int id;
	is >> name >> id;
	dog.name = name;
	dog.id = id;
	return is;
}

// [문제] "Dog만객체" 파일에 있는 Dog 객체 10'000개를 읽어와라.
// id 오름차순 정렬한 후 전체를 show()로 출력하라.

// 위의 문제와는 별개로 해결해 보자 (파일에서 읽어서 해결 시작)
// (도전) 이름의 길이가 30인 Dog를 골라 "이름길이가30인Dog"에 저장하라.
// 6장!

Dog dog[10000];

int main()
{
	ifstream in("Dog만객체");
	ofstream out("이름길이가30인Dog");

	// Dog를 읽을때는
	// in >> dog;
	for (Dog& dog : dog)
		in >> dog;

	sort(begin(dog), end(dog), [](const Dog& dog1, const Dog& dog2) {
		return dog1.getId() < dog2.getId();
		});

	for (Dog& dog : dog) {
		dog.show();
		if (dog.getStringLenth() == 30)
			out << dog << endl;
	}

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-17 오후 1:19:25 - (화요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.16 월    (11주 1일)
//
// 
// 연산자 오버로딩
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <random>
#include <fstream>
#include <algorithm>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<> uid_len{ 5, 30 };
uniform_int_distribution<> uid_char{ 'a', 'z' };
uniform_int_distribution<> uid;

class Dog {
	string name{};	// 이름: 길이[5, 30], 문자['a', 'z']
	int id{};			// 그냥 랜덤 정수

public:
	Dog() {
		for ( int i = 0; i < uid_len( dre ); ++i )
			name += uid_char( dre );
		id = uid( dre );
	}

	Dog(const Dog& other) {
		this->~Dog();
		name = other.name;
		id = other.id;
	}

	void show() const {
		cout << id << " - " << name << endl;
	}

	int getId() const {
		return id;
	}

	size_t getStringLenth() const {
		return name.length();
	}

	friend ostream& operator<<(ostream&, const Dog&);
	friend istream& operator>>(istream&, Dog&);
};

ostream& operator<<(ostream& os, const Dog& dog)
{
	os << dog.name << ' ' << dog.id;
	return os;
}

istream& operator>>(istream& is, Dog& dog)
{
	string name;
	int id;
	is >> name >> id;
	dog.name = name;
	dog.id = id;
	return is;
}

// [문제] "Dog만객체" 파일에 있는 Dog 객체 10'000개를 읽어와라.
// id 오름차순 정렬한 후 전체를 show()로 출력하라.

// 위의 문제와는 별개로 해결해 보자 (파일에서 읽어서 해결 시작)
// (도전) 이름의 길이가 30인 Dog를 골라 "이름길이가30인Dog"에 저장하라.
// 6장!

Dog dog[10000];

int main()
{
	ifstream in("Dog만객체");
	ofstream out("이름길이가30인Dog");

	// Dog를 읽을때는
	// in >> dog;
	for (Dog& dog : dog)
		in >> dog;

	sort(begin(dog), end(dog), [](const Dog& dog1, const Dog& dog2) {
		return dog1.getId() < dog2.getId();
		});

	for (const Dog& dog : dog) {
		dog.show();
		if (dog.getStringLenth() == 30)
			out << dog << endl;
	}

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-17 오후 1:22:15 - (화요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.16 월    (11주 1일)
//
// 
// 연산자 오버로딩
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <random>
#include <fstream>
#include <algorithm>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<> uid_len{ 5, 30 };
uniform_int_distribution<> uid_char{ 'a', 'z' };
uniform_int_distribution<> uid;

class Dog {
	string name{};	// 이름: 길이[5, 30], 문자['a', 'z']
	int id{};			// 그냥 랜덤 정수

public:
	Dog() {
		for ( int i = 0; i < uid_len( dre ); ++i )
			name += uid_char( dre );
		id = uid( dre );
	}

	Dog(const Dog& other) {
		this->~Dog();
		name = other.name;
		id = other.id;
	}

	void show() const {
		cout << id << " - " << name << endl;
	}

	int getId() const {
		return id;
	}

	int getStringLenth() const {
		return name.length();
	}

	friend ostream& operator<<(ostream&, const Dog&);
	friend istream& operator>>(istream&, Dog&);
};

ostream& operator<<(ostream& os, const Dog& dog)
{
	os << dog.name << ' ' << dog.id;
	return os;
}

istream& operator>>(istream& is, Dog& dog)
{
	string name;
	int id;
	is >> name >> id;
	dog.name = name;
	dog.id = id;
	return is;
}

// [문제] "Dog만객체" 파일에 있는 Dog 객체 10'000개를 읽어와라.
// id 오름차순 정렬한 후 전체를 show()로 출력하라.

// 위의 문제와는 별개로 해결해 보자 (파일에서 읽어서 해결 시작)
// (도전) 이름의 길이가 30인 Dog를 골라 "이름길이가30인Dog"에 저장하라.
// 6장!

Dog dog[10000];

int main()
{
	ifstream in("Dog만객체");
	ofstream out("이름길이가30인Dog");

	// Dog를 읽을때는
	// in >> dog;
	for (Dog& dog : dog)
		in >> dog;

	sort(begin(dog), end(dog), [](const Dog& dog1, const Dog& dog2) {
		return dog1.getId() < dog2.getId();
		});

	for (const Dog& dog : dog) {
		if (dog.getStringLenth() == 30)
			out << dog << endl;
	}

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-17 오후 1:22:51 - (화요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.16 월    (11주 1일)
//
// 
// 연산자 오버로딩
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <random>
#include <fstream>
#include <algorithm>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<> uid_len{ 5, 30 };
uniform_int_distribution<> uid_char{ 'a', 'z' };
uniform_int_distribution<> uid;

class Dog {
	string name{};	// 이름: 길이[5, 30], 문자['a', 'z']
	int id{};			// 그냥 랜덤 정수

public:
	Dog() {
		for ( int i = 0; i < uid_len( dre ); ++i )
			name += uid_char( dre );
		id = uid( dre );
	}

	Dog(const Dog& other) {
		this->~Dog();
		name = other.name;
		id = other.id;
	}

	void show() const {
		cout << id << " - " << name << endl;
	}

	int getId() const {
		return id;
	}

	int getStringLenth() const {
		return name.length();
	}

	friend ostream& operator<<(ostream&, const Dog&);
	friend istream& operator>>(istream&, Dog&);
};

ostream& operator<<(ostream& os, const Dog& dog)
{
	os << dog.name << ' ' << dog.id;
	return os;
}

istream& operator>>(istream& is, Dog& dog)
{
	string name;
	int id;
	is >> name >> id;
	dog.name = name;
	dog.id = id;
	return is;
}

// [문제] "Dog만객체" 파일에 있는 Dog 객체 10'000개를 읽어와라.
// id 오름차순 정렬한 후 전체를 show()로 출력하라.

// 위의 문제와는 별개로 해결해 보자 (파일에서 읽어서 해결 시작)
// (도전) 이름의 길이가 30인 Dog를 골라 "이름길이가30인Dog"에 저장하라.
// 6장!

Dog dog[10000];

int main()
{
	ifstream in("Dog만객체");
	ofstream out("이름길이가30인Dog");

	// Dog를 읽을때는
	// in >> dog;
	for (Dog& dog : dog)
		in >> dog;

	sort(begin(dog), end(dog), [](const Dog& dog1, const Dog& dog2) {
		return dog1.getId() < dog2.getId();
		});

	for (const Dog& dog : dog) {
		cout << dog.getStringLenth() << endl;
			
	}

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-17 오후 11:16:18 - (화요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.16 월    (11주 1일)
//
// 
// 연산자 오버로딩
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <random>
#include <fstream>
#include <algorithm>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<> uid_len{ 5, 30 };
uniform_int_distribution<> uid_char{ 'a', 'z' };
uniform_int_distribution<> uid;

class Dog {
	string name{};	// 이름: 길이[5, 30], 문자['a', 'z']
	int id{};			// 그냥 랜덤 정수

public:
	Dog() {
		int len = uid_len(dre);
		for ( int i = 0; i < len; ++i )
			name += uid_char( dre );
		id = uid( dre );
	}

	Dog(const Dog& other) {
		this->~Dog();
		name = other.name;
		id = other.id;
	}

	void show() const {
		cout << id << " - " << name << endl;
	}

	int getId() const {
		return id;
	}

	int getStringLenth() const {
		return name.length();
	}

	friend ostream& operator<<(ostream&, const Dog&);
	friend istream& operator>>(istream&, Dog&);
};

ostream& operator<<(ostream& os, const Dog& dog)
{
	os << dog.name << ' ' << dog.id;
	return os;
}

istream& operator>>(istream& is, Dog& dog)
{
	string name;
	int id;
	is >> name >> id;
	dog.name = name;
	dog.id = id;
	return is;
}

// [문제] "Dog만객체" 파일에 있는 Dog 객체 10'000개를 읽어와라.
// id 오름차순 정렬한 후 전체를 show()로 출력하라.

// 위의 문제와는 별개로 해결해 보자 (파일에서 읽어서 해결 시작)
// (도전) 이름의 길이가 30인 Dog를 골라 "이름길이가30인Dog"에 저장하라.
// 6장!

Dog dog[10000];

int main()
{

	ofstream out("Dog만객체");

	for (int i = 0; i < 10000; ++i) {
		Dog dog;
		out << dog << endl;
	}
	//ofstream out("이름길이가30인Dog");

	// Dog를 읽을때는
	// in >> dog;
	//for (Dog& dog : dog)
	//	in >> dog;

	//sort(begin(dog), end(dog), [](const Dog& dog1, const Dog& dog2) {
	//	return dog1.getId() < dog2.getId();
	//	});

	//for (const Dog& dog : dog) {
	//	cout << dog.getStringLenth() << endl;
	//		
	//}

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-17 오후 11:17:47 - (화요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.16 월    (11주 1일)
//
// 
// 연산자 오버로딩
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <random>
#include <fstream>
#include <algorithm>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<> uid_len{ 5, 30 };
uniform_int_distribution<> uid_char{ 'a', 'z' };
uniform_int_distribution<> uid;

class Dog {
	string name{};	// 이름: 길이[5, 30], 문자['a', 'z']
	int id{};			// 그냥 랜덤 정수

public:
	Dog() {
		int len = uid_len(dre);
		for ( int i = 0; i < len; ++i )
			name += uid_char( dre );
		id = uid( dre );
	}

	Dog(const Dog& other) {
		this->~Dog();
		name = other.name;
		id = other.id;
	}

	void show() const {
		cout << id << " - " << name << endl;
	}

	int getId() const {
		return id;
	}

	int getStringLenth() const {
		return name.length();
	}

	friend ostream& operator<<(ostream&, const Dog&);
	friend istream& operator>>(istream&, Dog&);
};

ostream& operator<<(ostream& os, const Dog& dog)
{
	os << dog.name << ' ' << dog.id;
	return os;
}

istream& operator>>(istream& is, Dog& dog)
{
	string name;
	int id;
	is >> name >> id;
	dog.name = name;
	dog.id = id;
	return is;
}

// [문제] "Dog만객체" 파일에 있는 Dog 객체 10'000개를 읽어와라.
// id 오름차순 정렬한 후 전체를 show()로 출력하라.

// 위의 문제와는 별개로 해결해 보자 (파일에서 읽어서 해결 시작)
// (도전) 이름의 길이가 30인 Dog를 골라 "이름길이가30인Dog"에 저장하라.
// 6장!

Dog dog[10000];

int main()
{

	ifstream in("Dog만객체");

	//ofstream out("이름길이가30인Dog");

	// Dog를 읽을때는
	// in >> dog;
	for (Dog& dog : dog)
		in >> dog;

	sort(begin(dog), end(dog), [](const Dog& dog1, const Dog& dog2) {
		return dog1.getId() < dog2.getId();
		});

	for (const Dog& dog : dog)
		dog.show();
	//	cout << dog.getStringLenth() << endl;
	//		
	//}

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-17 오후 11:19:45 - (화요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.16 월    (11주 1일)
//
// 
// 연산자 오버로딩
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <random>
#include <fstream>
#include <algorithm>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<> uid_len{ 5, 30 };
uniform_int_distribution<> uid_char{ 'a', 'z' };
uniform_int_distribution<> uid;

class Dog {
	string name{};	// 이름: 길이[5, 30], 문자['a', 'z']
	int id{};			// 그냥 랜덤 정수

public:
	Dog() {
		int len = uid_len(dre);
		for ( int i = 0; i < len; ++i )
			name += uid_char( dre );
		id = uid( dre );
	}

	Dog(const Dog& other) {
		this->~Dog();
		name = other.name;
		id = other.id;
	}

	void show() const {
		cout << id << " - " << name << endl;
	}

	int getId() const {
		return id;
	}

	int getStringLenth() const {
		return name.length();
	}

	friend ostream& operator<<(ostream&, const Dog&);
	friend istream& operator>>(istream&, Dog&);
};

ostream& operator<<(ostream& os, const Dog& dog)
{
	os << dog.name << ' ' << dog.id;
	return os;
}

istream& operator>>(istream& is, Dog& dog)
{
	string name;
	int id;
	is >> name >> id;
	dog.name = name;
	dog.id = id;
	return is;
}

// [문제] "Dog만객체" 파일에 있는 Dog 객체 10'000개를 읽어와라.
// id 오름차순 정렬한 후 전체를 show()로 출력하라.

// 위의 문제와는 별개로 해결해 보자 (파일에서 읽어서 해결 시작)
// (도전) 이름의 길이가 30인 Dog를 골라 "이름길이가30인Dog"에 저장하라.
// 6장!

Dog dog[10000];

int main()
{

	ifstream in("Dog만객체");

	ofstream out("이름길이가30인Dog");

	// Dog를 읽을때는
	// in >> dog;
	for (Dog& dog : dog)
		in >> dog;

	sort(begin(dog), end(dog), [](const Dog& dog1, const Dog& dog2) {
		return dog1.getId() < dog2.getId();
		});
	int cnt{};
	for (const Dog& dog : dog) {
		dog.show();
		if (dog.getStringLenth() == 30) {
			out << dog << endl;
			++cnt;
		}
	}

	cout << "이름길이가 30인 dog의 마릿수 : " << cnt << endl;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-17 오후 11:20:15 - (화요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.16 월    (11주 1일)
//
// 
// 연산자 오버로딩
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <random>
#include <fstream>
#include <algorithm>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<> uid_len{ 5, 30 };
uniform_int_distribution<> uid_char{ 'a', 'z' };
uniform_int_distribution<> uid;

class Dog {
	string name{};	// 이름: 길이[5, 30], 문자['a', 'z']
	int id{};			// 그냥 랜덤 정수

public:
	Dog() {
		int len = uid_len(dre);
		for ( int i = 0; i < len; ++i )
			name += uid_char( dre );
		id = uid( dre );
	}

	Dog(const Dog& other) {
		this->~Dog();
		name = other.name;
		id = other.id;
	}

	void show() const {
		cout << id << " - " << name << endl;
	}

	int getId() const {
		return id;
	}

	int getStringLenth() const {
		return name.length();
	}

	friend ostream& operator<<(ostream&, const Dog&);
	friend istream& operator>>(istream&, Dog&);
};

ostream& operator<<(ostream& os, const Dog& dog)
{
	os << dog.name << ' ' << dog.id;
	return os;
}

istream& operator>>(istream& is, Dog& dog)
{
	string name;
	int id;
	is >> name >> id;
	dog.name = name;
	dog.id = id;
	return is;
}

// [문제] "Dog만객체" 파일에 있는 Dog 객체 10'000개를 읽어와라.
// id 오름차순 정렬한 후 전체를 show()로 출력하라.

// 위의 문제와는 별개로 해결해 보자 (파일에서 읽어서 해결 시작)
// (도전) 이름의 길이가 30인 Dog를 골라 "이름길이가30인Dog"에 저장하라.
// 6장!

Dog dog[10000];

int main()
{

	ifstream in("Dog만객체");

	ofstream out("이름길이가30인Dog");

	// Dog를 읽을때는
	// in >> dog;
	for (Dog& dog : dog)
		in >> dog;

	sort(begin(dog), end(dog), [](const Dog& dog1, const Dog& dog2) {
		return dog1.getId() < dog2.getId();
		});
	int cnt{};
	for (const Dog& dog : dog) {
		dog.show();
		if (dog.getStringLenth() == 30) {
			out << dog << endl;
			++cnt;
		}
	}

	cout << "이름길이가 30인 dog의 마릿수 : " << cnt << endl;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-17 오후 11:20:40 - (화요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.16 월    (11주 1일)
//
// 
// 연산자 오버로딩
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <random>
#include <fstream>
#include <algorithm>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<> uid_len{ 5, 30 };
uniform_int_distribution<> uid_char{ 'a', 'z' };
uniform_int_distribution<> uid;

class Dog {
	string name{};	// 이름: 길이[5, 30], 문자['a', 'z']
	int id{};			// 그냥 랜덤 정수

public:
	Dog() {
		int len = uid_len(dre);
		for ( int i = 0; i < len; ++i )
			name += uid_char( dre );
		id = uid( dre );
	}

	Dog(const Dog& other) {
		this->~Dog();
		name = other.name;
		id = other.id;
	}

	void show() const {
		cout << id << " - " << name << endl;
	}

	int getId() const {
		return id;
	}

	int getStringLenth() const {
		return name.length();
	}

	friend ostream& operator<<(ostream&, const Dog&);
	friend istream& operator>>(istream&, Dog&);
};

ostream& operator<<(ostream& os, const Dog& dog)
{
	os << dog.name << ' ' << dog.id;
	return os;
}

istream& operator>>(istream& is, Dog& dog)
{
	string name;
	int id;
	is >> name >> id;
	dog.name = name;
	dog.id = id;
	return is;
}

// [문제] "Dog만객체" 파일에 있는 Dog 객체 10'000개를 읽어와라.
// id 오름차순 정렬한 후 전체를 show()로 출력하라.

// 위의 문제와는 별개로 해결해 보자 (파일에서 읽어서 해결 시작)
// (도전) 이름의 길이가 30인 Dog를 골라 "이름길이가30인Dog"에 저장하라.
// 6장!

Dog dog[10000];

int main()
{

	ifstream in("Dog만객체");

	ofstream out("이름길이가30인Dog");

	// Dog를 읽을때는
	// in >> dog;
	for (Dog& dog : dog)
		in >> dog;

	sort(begin(dog), end(dog), [](const Dog& dog1, const Dog& dog2) {
		return dog1.getId() < dog2.getId();
		});
	int cnt{};
	for (const Dog& dog : dog) {
		dog.show();
		if (dog.getStringLenth() == 29) {
			out << dog << endl;
			++cnt;
		}
	}

	cout << "이름길이가 30인 dog의 마릿수 : " << cnt << endl;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-17 오후 11:21:20 - (화요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.16 월    (11주 1일)
//
// 
// 연산자 오버로딩
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <random>
#include <fstream>
#include <algorithm>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<> uid_len{ 5, 30 };
uniform_int_distribution<> uid_char{ 'a', 'z' };
uniform_int_distribution<> uid;

class Dog {
	string name{};	// 이름: 길이[5, 30], 문자['a', 'z']
	int id{};			// 그냥 랜덤 정수

public:
	Dog() {
		int len = uid_len(dre);
		for ( int i = 0; i < len; ++i )
			name += uid_char( dre );
		id = uid( dre );
	}

	Dog(const Dog& other) {
		this->~Dog();
		name = other.name;
		id = other.id;
	}

	void show() const {
		cout << id << " - " << name << endl;
	}

	int getId() const {
		return id;
	}

	int getStringLenth() const {
		return name.length();
	}

	friend ostream& operator<<(ostream&, const Dog&);
	friend istream& operator>>(istream&, Dog&);
};

ostream& operator<<(ostream& os, const Dog& dog)
{
	os << dog.name << ' ' << dog.id;
	return os;
}

istream& operator>>(istream& is, Dog& dog)
{
	string name;
	int id;
	is >> name >> id;
	dog.name = name;
	dog.id = id;
	return is;
}

// [문제] "Dog만객체" 파일에 있는 Dog 객체 10'000개를 읽어와라.
// id 오름차순 정렬한 후 전체를 show()로 출력하라.

// 위의 문제와는 별개로 해결해 보자 (파일에서 읽어서 해결 시작)
// (도전) 이름의 길이가 30인 Dog를 골라 "이름길이가30인Dog"에 저장하라.
// 6장!

Dog dog[10000];

int main()
{

	ifstream in("Dog만객체");

	ofstream out("이름길이가5인Dog");

	// Dog를 읽을때는
	// in >> dog;
	for (Dog& dog : dog)
		in >> dog;

	sort(begin(dog), end(dog), [](const Dog& dog1, const Dog& dog2) {
		return dog1.getId() < dog2.getId();
		});
	int cnt{};
	for (const Dog& dog : dog) {
		dog.show();
		if (dog.getStringLenth() == 5) {
			out << dog << endl;
			++cnt;
		}
	}

	cout << "이름길이가 5인 dog의 마릿수 : " << cnt << endl;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-18 오전 11:45:23 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.16 월    (11주 1일)
//
// 
// 연산자 오버로딩
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <random>
#include <fstream>
#include <algorithm>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<> uid_len{ 5, 30 };
uniform_int_distribution<> uid_char{ 'a', 'z' };
uniform_int_distribution<> uid;

class Dog {
	string name{};	// 이름: 길이[5, 30], 문자['a', 'z']
	int id{};			// 그냥 랜덤 정수

public:
	Dog() {
		int num = uid_len(dre);
		for ( int i = 0; i < num; ++i )
			name += uid_char( dre );
		id = uid( dre );
	}

	Dog(const Dog& other) {
		this->~Dog();
		name = other.name;
		id = other.id;
	}

	void show() const {
		cout << id << " - " << name << endl;
	}

	int getId() const {
		return id;
	}

	int getStringLenth() const {
		return name.length();
	}

	friend ostream& operator<<(ostream&, const Dog&);
	friend istream& operator>>(istream&, Dog&);
};

ostream& operator<<(ostream& os, const Dog& dog)
{
	os << dog.name << ' ' << dog.id;
	return os;
}

istream& operator>>(istream& is, Dog& dog)
{
	is >> dog.name >> dog.id;
	return is;
}

// [문제] "Dog만객체" 파일에 있는 Dog 객체 10'000개를 읽어와라.
// id 오름차순 정렬한 후 전체를 show()로 출력하라.

// 위의 문제와는 별개로 해결해 보자 (파일에서 읽어서 해결 시작)
// (도전) 이름의 길이가 30인 Dog를 골라 "이름길이가30인Dog"에 저장하라.
// 6장!


int main()
{

	ifstream in("Dog만객체");
	if (!in) {
		cout << "파일열기 실패" << endl;
		exit(12345);
	}

	Dog dog;

	ofstream out("이름길이가5인Dog");

	// Dog를 읽을때는
	// in >> dog;
	while (in >> dog) {
		cout << dog << endl;
	}

	//sort(begin(dog), end(dog), [](const Dog& dog1, const Dog& dog2) {
	//	return dog1.getId() < dog2.getId();
	//	});
	//int cnt{};
	//for (const Dog& dog : dog) {
	//	dog.show();
	//	if (dog.getStringLenth() == 5) {
	//		out << dog << endl;
	//		++cnt;
	//	}
	//}

	//cout << "이름길이가 5인 dog의 마릿수 : " << cnt << endl;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-18 오전 11:47:58 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.16 월    (11주 1일)
//
// 
// 연산자 오버로딩
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <random>
#include <fstream>
#include <algorithm>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<> uid_len{ 5, 30 };
uniform_int_distribution<> uid_char{ 'a', 'z' };
uniform_int_distribution<> uid;

class Dog {
	string name{};	// 이름: 길이[5, 30], 문자['a', 'z']
	int id{};			// 그냥 랜덤 정수

public:
	Dog() {
		int num = uid_len(dre);
		for ( int i = 0; i < num; ++i )
			name += uid_char( dre );
		id = uid( dre );
	}

	Dog(const Dog& other) {
		this->~Dog();
		name = other.name;
		id = other.id;
	}

	void show() const {
		cout << id << " - " << name << endl;
	}

	int getId() const {
		return id;
	}

	int getStringLenth() const {
		return name.length();
	}

	friend ostream& operator<<(ostream&, const Dog&);
	friend istream& operator>>(istream&, Dog&);
};

ostream& operator<<(ostream& os, const Dog& dog)
{
	os << dog.name << ' ' << dog.id;
	return os;
}

istream& operator>>(istream& is, Dog& dog)
{
	is >> dog.name >> dog.id;
	return is;
}

// [문제] "Dog만객체" 파일에 있는 Dog 객체 10'000개를 읽어와라.
// id 오름차순 정렬한 후 전체를 show()로 출력하라.

// 위의 문제와는 별개로 해결해 보자 (파일에서 읽어서 해결 시작)
// (도전) 이름의 길이가 30인 Dog를 골라 "이름길이가30인Dog"에 저장하라.
// 6장!


int main()
{

	ifstream in("Dog만객체");
	if (!in) {
		cout << "파일열기 실패" << endl;
		exit(12345);
	}

	Dog dog;

	ofstream out("이름길이가5인Dog");

	// Dog를 읽을때는
	// in >> dog;
	for (int i = 0; i < 10; ++i) {
		in >> dog;
		cout << dog << endl;
	}

	for (int i = 0; i < 10000 - 20; ++i)
		in >> dog;

	for (int i = 0; i < 10; ++i) {
		in >> dog;
		cout << dog << endl;
	}

	//sort(begin(dog), end(dog), [](const Dog& dog1, const Dog& dog2) {
	//	return dog1.getId() < dog2.getId();
	//	});
	//int cnt{};
	//for (const Dog& dog : dog) {
	//	dog.show();
	//	if (dog.getStringLenth() == 5) {
	//		out << dog << endl;
	//		++cnt;
	//	}
	//}

	//cout << "이름길이가 5인 dog의 마릿수 : " << cnt << endl;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-18 오전 11:51:08 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.16 월    (11주 1일)
//
// 
// 연산자 오버로딩
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <random>
#include <fstream>
#include <algorithm>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<> uid_len{ 5, 30 };
uniform_int_distribution<> uid_char{ 'a', 'z' };
uniform_int_distribution<> uid;

class Dog {
	string name{};	// 이름: 길이[5, 30], 문자['a', 'z']
	int id{};			// 그냥 랜덤 정수

public:
	Dog() {
		int num = uid_len(dre);
		for ( int i = 0; i < num; ++i )
			name += uid_char( dre );
		id = uid( dre );
	}

	Dog(const Dog& other) {
		this->~Dog();
		name = other.name;
		id = other.id;
	}

	void show() const {
		cout << id << " - " << name << endl;
	}

	int getId() const {
		return id;
	}

	int getStringLenth() const {
		return name.length();
	}

	friend ostream& operator<<(ostream&, const Dog&);
	friend istream& operator>>(istream&, Dog&);
};

ostream& operator<<(ostream& os, const Dog& dog)
{
	os << dog.name << ' ' << dog.id;
	return os;
}

istream& operator>>(istream& is, Dog& dog)
{
	is >> dog.name >> dog.id;
	return is;
}

// [문제] "Dog만객체" 파일에 있는 Dog 객체 10'000개를 읽어와라.
// id 오름차순 정렬한 후 전체를 show()로 출력하라.

// 위의 문제와는 별개로 해결해 보자 (파일에서 읽어서 해결 시작)
// (도전) 이름의 길이가 30인 Dog를 골라 "이름길이가30인Dog"에 저장하라.
// 6장!


int main()
{

	ifstream in("Dog만객체");
	if (!in) {
		cout << "파일열기 실패" << endl;
		exit(12345);
	}

	Dog* dogs = new Dog[10'000];

	int i = 0;
	while (in >> dogs[i])
		++i;

	cout << dogs[0] << endl;
	cout << dogs[9999] << endl;

	ofstream out("이름길이가5인Dog");



	//sort(begin(dog), end(dog), [](const Dog& dog1, const Dog& dog2) {
	//	return dog1.getId() < dog2.getId();
	//	});
	//int cnt{};
	//for (const Dog& dog : dog) {
	//	dog.show();
	//	if (dog.getStringLenth() == 5) {
	//		out << dog << endl;
	//		++cnt;
	//	}
	//}

	//cout << "이름길이가 5인 dog의 마릿수 : " << cnt << endl;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-18 오후 12:02:34 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.16 월    (11주 1일)
//
// 
// 연산자 오버로딩
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <random>
#include <fstream>
#include <algorithm>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<> uid_len{ 5, 30 };
uniform_int_distribution<> uid_char{ 'a', 'z' };
uniform_int_distribution<> uid;

class Dog {
	string name{};	// 이름: 길이[5, 30], 문자['a', 'z']
	int id{};			// 그냥 랜덤 정수

public:
	Dog() {
		int num = uid_len(dre);
		for ( int i = 0; i < num; ++i )
			name += uid_char( dre );
		id = uid( dre );
	}

	void show() const {
		cout << id << " - " << name << endl;
	}

	int getId() const {
		return id;
	}

	int getStringLenth() const {
		return name.length();
	}

	friend ostream& operator<<(ostream&, const Dog&);
	friend istream& operator>>(istream&, Dog&);
};

ostream& operator<<(ostream& os, const Dog& dog)
{
	os << dog.name << ' ' << dog.id;
	return os;
}

istream& operator>>(istream& is, Dog& dog)
{
	is >> dog.name >> dog.id;
	return is;
}

// [문제] "Dog만객체" 파일에 있는 Dog 객체 10'000개를 읽어와라.
// id 오름차순 정렬한 후 전체를 show()로 출력하라.

// 위의 문제와는 별개로 해결해 보자 (파일에서 읽어서 해결 시작)
// (도전) 이름의 길이가 30인 Dog를 골라 "이름길이가30인Dog"에 저장하라.
// 6장!


int main()
{

	ifstream in("Dog만객체");
	if (!in) {
		cout << "파일열기 실패" << endl;
		exit(12345);
	}

	Dog* dogs = new Dog[10'000];

	cout << "읽는 중" << endl;
	int i = 0;
	while (in >> dogs[i])
		++i;

	cout << "정렬 중" << endl;
	sort(&dogs[0], &dogs[10000], [](const Dog& dog1, const Dog& dog2) {
		return dog1.getId() < dog2.getId();
		});

	cout << "정렬이 끝났습니다. 키를 누르세요: ";
	char ch;
	cin >> ch;

	for (int i = 0; i < 10'000; ++i)
		cout << dogs[i] << endl;

	//int cnt{};
	//for (const Dog& dog : dog) {
	//	dog.show();
	//	if (dog.getStringLenth() == 5) {
	//		out << dog << endl;
	//		++cnt;
	//	}
	//}

	//cout << "이름길이가 5인 dog의 마릿수 : " << cnt << endl;

	delete[] dogs;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-18 오후 12:07:13 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.16 월    (11주 1일)
//
// 
// 연산자 오버로딩
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <random>
#include <fstream>
#include <algorithm>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<> uid_len{ 5, 30 };
uniform_int_distribution<> uid_char{ 'a', 'z' };
uniform_int_distribution<> uid;

class Dog {
	string name{};	// 이름: 길이[5, 30], 문자['a', 'z']
	int id{};			// 그냥 랜덤 정수

public:
	Dog() {
		int num = uid_len(dre);
		for ( int i = 0; i < num; ++i )
			name += uid_char( dre );
		id = uid( dre );
	}

	void show() const {
		cout << id << " - " << name << endl;
	}

	int getId() const {
		return id;
	}

	string_view getName() const {
		return name;
	}

	friend ostream& operator<<(ostream&, const Dog&);
	friend istream& operator>>(istream&, Dog&);
};

ostream& operator<<(ostream& os, const Dog& dog)
{
	os << dog.name << ' ' << dog.id;
	return os;
}

istream& operator>>(istream& is, Dog& dog)
{
	is >> dog.name >> dog.id;
	return is;
}

// [문제] "Dog만객체" 파일에 있는 Dog 객체 10'000개를 읽어와라.
// 이름 길이 오름차순 정렬한 후 전체를 show()로 출력하라.

// 위의 문제와는 별개로 해결해 보자 (파일에서 읽어서 해결 시작)
// (도전) 이름의 길이가 30인 Dog를 골라 "이름길이가30인Dog"에 저장하라.
// 6장!


int main()
{

	ifstream in("Dog만객체");
	if (!in) {
		cout << "파일열기 실패" << endl;
		exit(12345);
	}

	Dog* dogs = new Dog[10'000];

	cout << "읽는 중" << endl;
	int i = 0;
	while (in >> dogs[i])
		++i;

	cout << "정렬 중" << endl;
	sort(&dogs[0], &dogs[10000], [](const Dog& dog1, const Dog& dog2) {
		return dog1.getName().size() < dog2.getName().size();
		});

	cout << "정렬이 끝났습니다. 키를 누르세요: ";
	char ch;
	cin >> ch;

	for (int i = 0; i < 10'000; ++i)
		cout << dogs[i] << endl;

	//int cnt{};
	//for (const Dog& dog : dog) {
	//	dog.show();
	//	if (dog.getStringLenth() == 5) {
	//		out << dog << endl;
	//		++cnt;
	//	}
	//}

	//cout << "이름길이가 5인 dog의 마릿수 : " << cnt << endl;

	delete[] dogs;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-18 오후 12:11:18 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.16 월    (11주 1일)
//
// 
// 연산자 오버로딩
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <random>
#include <fstream>
#include <algorithm>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<> uid_len{ 5, 30 };
uniform_int_distribution<> uid_char{ 'a', 'z' };
uniform_int_distribution<> uid;

class Dog {
	string name{};	// 이름: 길이[5, 30], 문자['a', 'z']
	int id{};			// 그냥 랜덤 정수

public:
	Dog() {
		int num = uid_len(dre);
		for ( int i = 0; i < num; ++i )
			name += uid_char( dre );
		id = uid( dre );
	}

	void show() const {
		cout << id << " - " << name << endl;
	}

	int getId() const {
		return id;
	}

	string_view getName() const {
		return name;
	}

	friend ostream& operator<<(ostream&, const Dog&);
	friend istream& operator>>(istream&, Dog&);
};

ostream& operator<<(ostream& os, const Dog& dog)
{
	os << dog.name << ' ' << dog.id;
	return os;
}

istream& operator>>(istream& is, Dog& dog)
{
	string name;
	is >> name;
	sort(begin(name), end(name));
	dog.name = name;
	is >> dog.id;
	return is;
}

// [문제] "Dog만객체" 파일에 있는 Dog 객체 10'000개를 읽어와라.
// 이름 길이 오름차순 정렬한 후 전체를 show()로 출력하라.

// 위의 문제와는 별개로 해결해 보자 (파일에서 읽어서 해결 시작)
// (도전) 이름의 길이가 30인 Dog를 골라 "이름길이가30인Dog"에 저장하라.
// 6장!


int main()
{

	ifstream in("Dog만객체");
	if (!in) {
		cout << "파일열기 실패" << endl;
		exit(12345);
	}

	Dog* dogs = new Dog[10'000];

	cout << "읽는 중" << endl;
	int i = 0;
	while (in >> dogs[i])
		++i;

	cout << "정렬 중" << endl;
	sort(&dogs[0], &dogs[10000], [](const Dog& dog1, const Dog& dog2) {
		return dog1.getName().size() < dog2.getName().size();
		});

	cout << "정렬이 끝났습니다. 키를 누르세요: ";
	char ch;
	cin >> ch;

	for (int i = 0; i < 10'000; ++i)
		cout << dogs[i] << endl;

	//int cnt{};
	//for (const Dog& dog : dog) {
	//	dog.show();
	//	if (dog.getStringLenth() == 5) {
	//		out << dog << endl;
	//		++cnt;
	//	}
	//}

	//cout << "이름길이가 5인 dog의 마릿수 : " << cnt << endl;

	delete[] dogs;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-18 오후 12:13:12 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.16 월    (11주 1일)
//
// 
// 연산자 오버로딩
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <random>
#include <fstream>
#include <algorithm>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<> uid_len{ 5, 30 };
uniform_int_distribution<> uid_char{ 'a', 'z' };
uniform_int_distribution<> uid;

class Dog {
	string name{};	// 이름: 길이[5, 30], 문자['a', 'z']
	int id{};			// 그냥 랜덤 정수

public:
	Dog() {
		int num = uid_len(dre);
		for ( int i = 0; i < num; ++i )
			name += uid_char( dre );
		id = uid( dre );
	}

	void show() const {
		cout << id << " - " << name << endl;
	}

	int getId() const {
		return id;
	}

	string_view getName() const {
		return name;
	}

	friend ostream& operator<<(ostream&, const Dog&);
	friend istream& operator>>(istream&, Dog&);
};

ostream& operator<<(ostream& os, const Dog& dog)
{
	os << dog.name << ' ' << dog.id;
	return os;
}

istream& operator>>(istream& is, Dog& dog)
{
	string name;
	is >> name;
	sort(begin(name), end(name));
	dog.name = name;
	is >> dog.id;
	return is;
}

// 위의 문제와는 별개로 해결해 보자 (파일에서 읽어서 해결 시작)
// (도전) 이름의 길이가 30인 Dog를 골라 "이름길이가30인Dog"에 저장하라.
// 6장!


int main()
{
	ifstream in("Dog만객체");
	if (!in) {
		cout << "파일열기 실패" << endl;
		exit(12345);
	}

	Dog dog;
	while (in >> dog) {
		if (dog.getName().size() == 30)
			cout << dog;
	}

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-18 오후 12:15:39 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.16 월    (11주 1일)
//
// 
// 연산자 오버로딩
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <random>
#include <fstream>
#include <algorithm>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<> uid_len{ 5, 30 };
uniform_int_distribution<> uid_char{ 'a', 'z' };
uniform_int_distribution<> uid;

class Dog {
	string name{};	// 이름: 길이[5, 30], 문자['a', 'z']
	int id{};			// 그냥 랜덤 정수

public:
	Dog() {
		int num = uid_len(dre);
		for ( int i = 0; i < num; ++i )
			name += uid_char( dre );
		id = uid( dre );
	}

	void show() const {
		cout << id << " - " << name << endl;
	}

	int getId() const {
		return id;
	}

	string_view getName() const {
		return name;
	}

	friend ostream& operator<<(ostream&, const Dog&);
	friend istream& operator>>(istream&, Dog&);
};

ostream& operator<<(ostream& os, const Dog& dog)
{
	os << dog.name << ' ' << dog.id;
	return os;
}

istream& operator>>(istream& is, Dog& dog)
{
	string name;
	is >> name;
	sort(begin(name), end(name));
	dog.name = name;
	is >> dog.id;
	return is;
}

// 위의 문제와는 별개로 해결해 보자 (파일에서 읽어서 해결 시작)
// (도전) 이름의 길이가 15인 Dog를 골라 "이름길이가15인Dog"에 저장하라.
// 6장!


int main()
{
	ifstream in("Dog만객체");
	if (!in) {
		cout << "파일열기 실패" << endl;
		exit(12345);
	}

	ofstream out("이름길이가15인Dog");

	Dog dog;
	while (in >> dog) {
		if (dog.getName().size() == 15)
			out << dog << endl;
	}

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-18 오후 12:58:09 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.16 월    (11주 1일)
//
// 
// 클래스 간의 관계 - 상속(286쪽)
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] 소문자를 입력하면 자동으로 대문자로 바꿔 저장하는 스트링 클래스가 필요하다.

class String : public string {
public:
	String(const char* s) : string{ s } {
		*(this->begin()) = toupper(*(this->begin()));
	}
	
};

int main()
{
	String a { "abcde" };
	String b{ "fghijklmnopqrstuvwxyz" };
	//String c = a + b;

	cout << a << b << endl;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-18 오후 12:59:22 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.16 월    (11주 1일)
//
// 
// 클래스 간의 관계 - 상속(286쪽)
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] 소문자를 입력하면 자동으로 대문자로 바꿔 저장하는 스트링 클래스가 필요하다.

class String : public string {
public:
	String(const char* s) : string{ s } {
		for (auto i = this->begin(); i != this->end(); ++i)
			*i = toupper(*i);
	}
	
};

int main()
{
	String a { "abcde" };
	String b{ "fghijklmnopqrstuvwxyz" };
	//String c = a + b;

	cout << a << b << endl;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-18 오후 1:01:04 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.16 월    (11주 1일)
//
// 
// 클래스 간의 관계 - 상속(286쪽)
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] 소문자를 입력하면 자동으로 대문자로 바꿔 저장하는 스트링 클래스가 필요하다.

class String : public string {
public:
	String(const char* s) : string{ s } {
		for (auto i = this->begin(); i != this->end(); ++i)
			*i = toupper(*i);
	}
	
	String operator+(const String& rhs) const {
		return this->operator+(rhs);
	}
};

int main()
{
	String a { "abcde" };
	String b{ "fghijklmnopqrstuvwxyz" };
	String c = a + b;

	cout << c << endl;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-18 오후 1:01:52 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.16 월    (11주 1일)
//
// 
// 클래스 간의 관계 - 상속(286쪽)
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] 소문자를 입력하면 자동으로 대문자로 바꿔 저장하는 스트링 클래스가 필요하다.

class String : public string {
public:
	String(const char* s) : string{ s } {
		for (auto i = this->begin(); i != this->end(); ++i)
			*i = toupper(*i);
	}
	
	String operator+(const String& rhs) const {
		return (*this).operator+(rhs);
	}
};

int main()
{
	String a { "abcde" };
	String b{ "fghijklmnopqrstuvwxyz" };
	String c = a + b;

	cout << c << endl;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-18 오후 1:02:25 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.16 월    (11주 1일)
//
// 
// 클래스 간의 관계 - 상속(286쪽)
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] 소문자를 입력하면 자동으로 대문자로 바꿔 저장하는 스트링 클래스가 필요하다.

class String : public string {
public:
	String(const char* s) : string{ s } {
		for (auto i = this->begin(); i != this->end(); ++i)
			*i = toupper(*i);
	}
};

int main()
{
	String a { "abcde" };
	String b{ "fghijklmnopqrstuvwxyz" };

	cout << a << endl;
	cout << b << endl;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-18 오후 1:02:57 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.16 월    (11주 1일)
//
// 
// 클래스 간의 관계 - 상속(286쪽)
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] 소문자를 입력하면 자동으로 대문자로 바꿔 저장하는 스트링 클래스가 필요하다.

class String : public string {
public:
	String(const char* s) : string{ s } {
		for (auto i = this->begin(); i != this->end(); ++i)
			*i = toupper(*i);
	}
};

int main()
{
	String a { "abcde" };
	String b{ "fghijklmqicbncgnrjfadhfquetkfagbqejhadfigjnopqrstuvwxyz" };

	cout << a << endl;
	cout << b << endl;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-23 오후 1:29:28 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.23 월   (12주 1일)
//
// 
// 클래스 간의 관계 - 상속(286쪽)
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

class String : public string {
public:
	String(const char* s) : string{ s } {
		for (auto i = begin(); i != end(); ++i)
			*i = toupper(*i);
	}
};

int main()
{
	String a{ "abcde" };
	String b{ "12345" };

	cout << a << endl;
	cout << b << endl;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-23 오후 1:53:48 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.23 월   (12주 1일)
//
// 클래스 간의 관계 - 상속(286쪽)
// 1. 코드를 재사용
// 2. 다형성(polymorphism)을 구현하려고
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] 모든 문자를 대문자로 관리하는 string class를 만들고 싶다.
// 상속을 이용하면 내가 다 안 만들어도 된다는데...
// 문제없이 main이 실행되게 해 보자. 최소한의 노력을 해서

class STRING : public string {
public:
	STRING(string s) : string{ s } {
		for (auto i = begin(); i != end(); ++i)
			*i = toupper(*i);
	}
};

int main()
{
	STRING a{ "abc" };
	STRING b{ "-12345" };
	STRING c = a + b;

	cout << c << endl;		// ABC-12345

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-23 오후 1:56:05 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.23 월   (12주 1일)
//
// 클래스 간의 관계 - 상속(286쪽)
// 1. 코드를 재사용
// 2. 다형성(polymorphism)을 구현하려고
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] 모든 문자를 대문자로 관리하는 string class를 만들고 싶다.
// 상속을 이용하면 내가 다 안 만들어도 된다는데...
// 문제없이 main이 실행되게 해 보자. 최소한의 노력을 해서

class STRING : public string {
public:
	STRING(const char* s) : string{ s } {
		for (auto i = begin(); i != end(); ++i)
			*i = toupper(*i);
	}

	STRING(string s) : string{ s } {}

};

int main()
{
	STRING a{ "abc" };
	STRING b{ "-12345" };
	STRING c = a + b;

	cout << c << endl;		// ABC-12345

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-23 오후 1:59:30 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.23 월   (12주 1일)
//
// 클래스 간의 관계 - 상속(286쪽)
// 2. 다형성(polymorphism)을 구현하려고
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

class Parent {
	int p{ };
};

class Child : public Parent {
	int c{ };
};

// [문제] 객체의 메모리 크기는 ?
int main()
{
	Child c;

	cout << sizeof(c) << endl;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-23 오후 2:00:03 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.23 월   (12주 1일)
//
// 클래스 간의 관계 - 상속(286쪽)
// 2. 다형성(polymorphism)을 구현하려고
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

class Parent {
	int p{ };
};

class Child : public Parent {
	int c{ };
};

// [문제] 객체의 메모리 크기는 ?
int main()
{
	Child c;

	cout << sizeof(Child) << endl;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-23 오후 2:00:11 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.23 월   (12주 1일)
//
// 클래스 간의 관계 - 상속(286쪽)
// 2. 다형성(polymorphism)을 구현하려고
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

class Parent {
	int p{ };
};

class Child : public Parent {
	int c{ };
};

// [문제] 객체의 메모리 크기는 ?
int main()
{
	Child c;

	cout << sizeof(Parent) << endl;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-23 오후 2:02:01 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.23 월   (12주 1일)
//
// 클래스 간의 관계 - 상속(286쪽)
// 2. 다형성(polymorphism)을 구현하려고
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

class Parent {
	int p{ };
};

class Child : public Parent {
	int c{ };
};

// [문제] 객체의 메모리 크기는 ?
int main()
{
	Child c;		// [p][c]
	cout << "자식객체의 메모리 = 자식메모리 + 부모메모리 = " << sizeof(Child) << endl;
	
	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-23 오후 2:04:30 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.23 월   (12주 1일)
//
// 클래스 간의 관계 - 상속(286쪽)
// 2. 다형성(polymorphism)을 구현하려고
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

class Parent {
	int p{ };
public:
	Parent() { cout << "부모 생성" << endl; }

	~Parent() { cout << "부모 소멸" << endl; }
};

class Child : public Parent {
	int c{ };
public:
	Child() { cout << "자식 생성" << endl; }

	~Child() { cout << "자식 소멸" << endl; }
};

// [문제] 만들어진 메모리를 초기화한다.
// 1. 초기화되는 순서와 소멸되는 순서를 관찰한다.

int main()
{
	Child c;		// [p][c]
	cout << "자식객체의 메모리 = 자식 + 부모 = " << sizeof(Child) << endl;
	
	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-23 오후 2:09:25 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.23 월   (12주 1일)
//
// 클래스 간의 관계 - 상속(286쪽)
// 2. 다형성(polymorphism)을 구현하려고
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

class Parent {
	int p{ };
public:
	Parent() { cout << "부모 생성" << endl; }

	~Parent() { cout << "부모 소멸" << endl; }
};

class Child : public Parent {
	int c{ };
public:
	Child() { cout << "자식 생성" << endl; }

	~Child() { cout << "자식 소멸" << endl; }
};

// [문제] 만들어진 메모리를 초기화한다.
// 1. 초기화되는 순서와 소멸되는 순서를 관찰한다.

int main()
{
	{	
		Child c;		// [p][c]
	}
	cout << "자식객체의 메모리 = 자식 + 부모 = " << sizeof(Child) << endl;
	
	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-23 오후 2:10:32 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.23 월   (12주 1일)
//
// 클래스 간의 관계 - 상속(286쪽)
// 2. 다형성(polymorphism)을 구현하려고
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

class Parent {
	int p{ };
public:
	Parent() { cout << "부모 생성" << endl; }

	~Parent() { cout << "부모 소멸" << endl; }
};

class Child : public Parent {
	int c{ };
public:
	Child() { cout << "자식 생성" << endl; }

	~Child() { cout << "자식 소멸" << endl; }
};

// [문제] 만들어진 메모리를 초기화한다.
// 1. 초기화되는 순서와 소멸되는 순서를 관찰한다.

int main()
{
	{
		Child* p = new Child;		// [p][c]

		delete p;
	}
	cout << "자식객체의 메모리 = 자식 + 부모 = " << sizeof(Child) << endl;
	
	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-23 오후 2:17:32 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.23 월   (12주 1일)
//
// 클래스 간의 관계 - 상속(286쪽)
// 2. 다형성(polymorphism)을 구현하려고
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

class Parent {
	int p{ };
public:
	Parent(int n) : p{ n } {}
};

class Child : public Parent {
	int c{ };
public:
	Child(int p, int c) : Parent(p), c{ c } {}

	friend ostream& operator<<(ostream&, const Child&);
};

ostream& operator<<(ostream& os, const Child& c)
{
	os << "[" << c.c << "]" << endl;
	return os;
}


// [문제] 만들어진 메모리를 초기화한다.
// 1. 초기화되는 순서와 소멸되는 순서를 관찰한다.
// 2. main이 변경되지 않고 실행되도록 class를 더 프로그래밍하자

int main()
{
	Child c{ 1, 333 };
	
	cout << c << endl;		// [1][333] 이렇게 출력되도록 하자.

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-23 오후 2:19:03 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.23 월   (12주 1일)
//
// 클래스 간의 관계 - 상속(286쪽)
// 2. 다형성(polymorphism)을 구현하려고
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

class Parent {
	int p{ };
public:
	Parent(int n) : p{ n } {}

	friend ostream& operator<<(ostream& os, const Parent& rhs);
};

class Child : public Parent {
	int c{ };
public:
	Child(int p, int c) : Parent(p), c{ c } {}

	friend ostream& operator<<(ostream&, const Child&);
};

ostream& operator<<(ostream& os, const Parent& rhs)
{
	os << "[" << rhs.p << "]" << endl;
	return os;
}

ostream& operator<<(ostream& os, const Child& rhs)
{
	os << "[" << rhs.c << "]" << endl;
	return os;
}


// [문제] 만들어진 메모리를 초기화한다.
// 1. 초기화되는 순서와 소멸되는 순서를 관찰한다.
// 2. main이 변경되지 않고 실행되도록 class를 더 프로그래밍하자

int main()
{
	Child c{ 1, 333 };
	
	cout << c << endl;		// [1][333] 이렇게 출력되도록 하자.

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-23 오후 2:26:32 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.23 월   (12주 1일)
//
// 클래스 간의 관계 - 상속(286쪽)
// 2. 다형성(polymorphism)을 구현하려고
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

class Parent {
	int p{ };
public:
	Parent(int n) : p{ n } {}

	int getP() const {
		return p;
	}
};

class Child : public Parent {
	int c{ };
public:
	Child(int p, int c) : Parent(p), c{ c } {}

	friend ostream& operator<<(ostream&, const Child&);
};

ostream& operator<<(ostream& os, const Child& rhs)
{
	os << "[" << rhs.getP() << "][" << rhs.c << "]" << endl;
	return os;
}

// [문제] 만들어진 메모리를 초기화한다.
// 1. 초기화되는 순서와 소멸되는 순서를 관찰한다.
// 2. main이 변경되지 않고 실행되도록 class를 더 프로그래밍하자

int main()
{
	Child c{ 1, 333 };
	
	cout << c << endl;		// [1][333] 이렇게 출력되도록 하자.

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-23 오후 2:38:30 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.23 월   (12주 1일)
//
// 클래스 간의 관계 - 상속(286쪽)
// 2. 다형성(polymorphism)을 구현하려고
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

class Parent {
	int p{ };
public:
	Parent(int n) : p{ n } {}

	int getP() const {
		return p;
	}
};

class Child : public Parent {
	int c{ };
public:
	Child(int a, int b) : Parent{ a }, c{ b } {}

	friend ostream& operator<<(ostream&, const Child&);
};

ostream& operator<<(ostream& os, const Child& child)
{
	os << "[" << child.getP() << "][" << child.c << "]";
	return os;
}

// [문제] 만들어진 메모리를 초기화한다.
// 1. 초기화되는 순서와 소멸되는 순서를 관찰한다.
// 2. main이 변경되지 않고 실행되도록 class를 더 프로그래밍하자

int main()
{
	Child c{ 1, 333 };
	
	cout << c << endl;		// [1][333] 이렇게 출력되도록 하자.

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-23 오후 2:38:44 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.23 월   (12주 1일)
//
// 클래스 간의 관계 - 상속(286쪽)
// 2. 다형성(polymorphism)을 구현하려고
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

class Parent {
	int p{ };
public:
	Parent(int n) : p{ n } {}

	int getP() const {
		return p;
	}
};

class Child : public Parent {
	int c{ };
public:
	Child(int a, int b) : Parent{ a }, c{ b } {}

	friend ostream& operator<<(ostream&, const Child&);
};

ostream& operator<<(ostream& os, const Child& child)
{
	os << "[" << child.getP() << "][" << child.c << "]";
	return os;
}

// [문제] 만들어진 메모리를 초기화한다.
// 1. 초기화되는 순서와 소멸되는 순서를 관찰한다.
// 2. main이 변경되지 않고 실행되도록 class를 더 프로그래밍하자

int main()
{
	Child c{ 111111, 3333333 };
	
	cout << c << endl;		// [1][333] 이렇게 출력되도록 하자.

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-23 오후 2:39:57 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.23 월   (12주 1일)
//
// 클래스 간의 관계 - 상속(286쪽)
// 2. 다형성(polymorphism)을 구현하려고
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

class Parent {
protected:			// 자식의 private 멤버가 됨
	int p{ };
public:
	Parent(int n) : p{ n } {}
};

class Child : public Parent {
	int c{ };
public:
	Child(int a, int b) : Parent{ a }, c{ b } {}

	friend ostream& operator<<(ostream&, const Child&);
};

ostream& operator<<(ostream& os, const Child& child)
{
	os << "[" << child.p << "][" << child.c << "]";
	return os;
}

// [문제] 만들어진 메모리를 초기화한다.
// 1. 초기화되는 순서와 소멸되는 순서를 관찰한다.
// 2. main이 변경되지 않고 실행되도록 class를 더 프로그래밍하자

int main()
{
	Child c{ 111111, 3333333 };
	
	cout << c << endl;		// [1][333] 이렇게 출력되도록 하자.

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-23 오후 2:42:13 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.23 월   (12주 1일)
//
// 클래스 간의 관계 - 상속(286쪽)
// 2. 다형성(polymorphism)을 구현하려고
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

class Parent {
protected:			// 자식의 private 멤버가 됨
	int p{ };
public:
	Parent() = default;
	Parent(int n) : p{ n } {}
};

class Child : public Parent {
	int c{ };
public:
	Child(int a, int b) : c{ b } {
		p = a;
	}

	friend ostream& operator<<(ostream&, const Child&);
};

ostream& operator<<(ostream& os, const Child& child)
{
	os << "[" << child.p << "][" << child.c << "]";
	return os;
}

// [문제] 만들어진 메모리를 초기화한다.
// 1. 초기화되는 순서와 소멸되는 순서를 관찰한다.
// 2. main이 변경되지 않고 실행되도록 class를 더 프로그래밍하자

int main()
{
	Child c{ 111111, 3333333 };
	
	cout << c << endl;		// [1][333] 이렇게 출력되도록 하자.

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-23 오후 2:59:35 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.23 월   (12주 1일)
//
// 클래스 간의 관계 - 상속(286쪽)
// 2. 다형성(polymorphism)을 구현하려고
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

class Animal {
protected:
	string name;

public:
	void move() const {
		cout << name << "이 움직인다" << endl;
	}
};

class Dog : public Animal {
public:
	Dog(string s) {
		name = s;
	}
};

class Bird : public Animal {
public:
	Bird(string s) {
		name = s;
	}
};

int main()
{
	Dog dog{ "멍" };
	Bird bird{ "짹" };

	dog.move();			// "멍이 움직인다"
	bird.move();		// "짹이 움직인다"

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-23 오후 3:00:41 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.23 월   (12주 1일)
//
// 클래스 간의 관계 - 상속(286쪽)
// 2. 다형성(polymorphism)을 구현하려고
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

class Animal {
protected:
	string name;
};

class Dog : public Animal {
public:
	Dog(string s) {
		name = s;
	}
	void move() const {
		cout << name << "이 뛴다" << endl;
	}
};

class Bird : public Animal {
public:
	Bird(string s) {
		name = s;
	}
	void move() const {
		cout << name << "이 난다" << endl;
	}
};

int main()
{
	Dog dog{ "멍" };
	Bird bird{ "짹" };

	dog.move();			// "멍이 뛴다"
	bird.move();		// "짹이 난다"

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-23 오후 3:06:57 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.23 월   (12주 1일)
//
// 클래스 간의 관계 - 상속(286쪽)
// 2. 다형성(polymorphism)을 구현하려고
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

class Animal {
protected:
	string name;
	
public:
	void move() const {
		cout << name << "이 움직인다" << endl;
	}
};

class Dog : public Animal {
public:
	Dog(string s) {
		name = s;
	}
	void move() const {		// 멤버함수 override
		Animal::move();
		cout << name << "이 뛴다" << endl;
	}
};

class Bird : public Animal {
public:
	Bird(string s) {
		name = s;
	}
	void move() const {		// 멤버함수 override
		cout << name << "이 난다" << endl;
	}
};

int main()
{
	Dog dog{ "멍" };
	Bird bird{ "짹" };

	dog.move();			// "멍이 뛴다"
	bird.move();		// "짹이 난다"

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-23 오후 3:11:22 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.23 월   (12주 1일)
//
// 클래스 간의 관계 - 상속(286쪽)
// 2. 다형성(polymorphism)을 구현하려고
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

class Animal {
protected:
	string name;
	
public:
	virtual void move() const {}; // 순수(=0)가상함수(pure virtual function
								   // pure - 함수의 몸체가 없다.
								   // virtual
};

class Dog : public Animal {
public:
	Dog(string s) {
		name = s;
	}
	void move() const {		// 멤버함수 override
		cout << name << "이 뛴다" << endl;
	}
};

class Bird : public Animal {
public:
	Bird(string s) {
		name = s;
	}
	void move() const {		// 멤버함수 override
		cout << name << "이 난다" << endl;
	}
};

int main()
{
	Dog dog{ "멍" };
	Bird bird{ "짹" };

	dog.move();			// "멍이 뛴다"
	bird.move();		// "짹이 난다"

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-23 오후 3:18:36 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.23 월   (12주 1일)
//
// 클래스 간의 관계 - 상속(286쪽)
// 2. 다형성(polymorphism)을 구현하려고
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

class Animal {		// 추상클래스(abstract) - 객체를 만들 수 없는 클래스이다
					// (Concrete class - 객체를 만들 수 있는 클래스)
					// 인터페이스(move)를 강요하는 클래스이다
protected:
	string name;
	
public:
	virtual void move() const = 0; // 순수(=0)가상함수(pure virtual function)
								   // pure - 함수의 몸체가 없다. - 강제한다
								   // virtual - 자식클래스가 만들길 기대하는 함수
};

class Dog : public Animal {
public:
	Dog(string s) {
		name = s;
	}
	void move() const override {		// 멤버함수 override
		cout << name << "이 뛴다" << endl;
	}
};

class Bird : public Animal {
public:
	Bird(string s) {
		name = s;
	}
	void move() const override final {		// 멤버함수 override
		cout << name << "이 난다" << endl;
	}
};

class Bat : public Animal {

};

int main()
{
	Dog dog{ "멍" };
	Bird bird{ "짹" };

	dog.move();			// "멍이 뛴다"
	bird.move();		// "짹이 난다"

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-25 오전 11:43:29 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.25 수   (12주 2일)
//
// 클래스 간의 관계 - 상속(286쪽)
// 2. 다형성(polymorphism)을 구현하려고
//		- 개념 : one interface multiple behavior ( 단일명령 다중행동 )
//		- C++에서는 어떻게 구현하지?
//		- 댓가는 뭐지?
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

// (Animal 메모리 <= Dog 메모리)

class Animal {
public:
	void move() const {
		cout << "동물이 움직인다" << endl;
	}
};

class Dog : public Animal {
public:
	void move() const {
		cout << "개가 뛴다" << endl;
	}
};

int main()
{
	Animal a;
	Dog d;

	a.move();
	d.move();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-25 오전 11:55:00 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.25 수   (12주 2일)
//
// 클래스 간의 관계 - 상속(286쪽)
// 2. 다형성(polymorphism)을 구현하려고
//		- 개념 : one interface multiple behavior ( 단일명령 다중행동 )
//		- C++에서는 어떻게 구현하지?
//		- 댓가는 뭐지?
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

// (Animal 메모리 <= Dog 메모리)

class Animal {
public:
	void move() const {
		cout << "동물이 움직인다" << endl;
	}
};

class Dog : public Animal {
public:
	void move() const {
		cout << "개가 뛴다" << endl;
	}
};

// 다형성을 구현하기 위해서는
// 1. 어떤 종류인지 모르는 다양한 (자식클래스) 동물들에게 move() 지시를 할 수 있어야!
// 2. 여러 동물들을 한 곳에 모아두어야 가능하다


int main()
{
	Animal a;
	Dog d;

	// Dog의 메모리는 언제나 Animal의 메모리가 포함된다.

	Dog* pDog = &d;
	pDog->move();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-25 오전 11:56:28 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.25 수   (12주 2일)
//
// 클래스 간의 관계 - 상속(286쪽)
// 2. 다형성(polymorphism)을 구현하려고
//		- 개념 : one interface multiple behavior ( 단일명령 다중행동 )
//		- C++에서는 어떻게 구현하지?
//		- 댓가는 뭐지?
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

// (Animal 메모리 <= Dog 메모리)

class Animal {
public:
	void move() const {
		cout << "동물이 움직인다" << endl;
	}
};

class Dog : public Animal {
public:
	void move() const {
		cout << "개가 뛴다" << endl;
	}
};

// 다형성을 구현하기 위해서는
// 1. 어떤 종류인지 모르는 다양한 (자식클래스) 동물들에게 move() 지시를 할 수 있어야!
// 2. 여러 동물들을 한 곳에 모아두어야 가능하다


int main()
{
	Animal a;
	Dog d;		// [a][d]

	// Dog의 메모리는 언제나 Animal의 메모리가 포함된다.

	Dog* pDog = &d;
	(*pDog).move();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-25 오전 11:57:01 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.25 수   (12주 2일)
//
// 클래스 간의 관계 - 상속(286쪽)
// 2. 다형성(polymorphism)을 구현하려고
//		- 개념 : one interface multiple behavior ( 단일명령 다중행동 )
//		- C++에서는 어떻게 구현하지?
//		- 댓가는 뭐지?
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

// (Animal 메모리 <= Dog 메모리)

class Animal {
public:
	void move() const {
		cout << "동물이 움직인다" << endl;
	}
};

class Dog : public Animal {
public:
	void move() const {
		cout << "개가 뛴다" << endl;
	}
};

// 다형성을 구현하기 위해서는
// 1. 어떤 종류인지 모르는 다양한 (자식클래스) 동물들에게 move() 지시를 할 수 있어야!
// 2. 여러 동물들을 한 곳에 모아두어야 가능하다


int main()
{
	Animal a;
	Dog d;		// [a][d]

	// Dog의 메모리는 언제나 Animal의 메모리가 포함된다.

	Animal* pAnimal = &d;
	pAnimal->move();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-25 오전 11:57:18 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.25 수   (12주 2일)
//
// 클래스 간의 관계 - 상속(286쪽)
// 2. 다형성(polymorphism)을 구현하려고
//		- 개념 : one interface multiple behavior ( 단일명령 다중행동 )
//		- C++에서는 어떻게 구현하지?
//		- 댓가는 뭐지?
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

// (Animal 메모리 <= Dog 메모리)

class Animal {
public:
	void move() const {
		cout << "동물이 움직인다" << endl;
	}
};

class Dog : public Animal {
public:
	void move() const {
		cout << "개가 뛴다" << endl;
	}
};

// 다형성을 구현하기 위해서는
// 1. 어떤 종류인지 모르는 다양한 (자식클래스) 동물들에게 move() 지시를 할 수 있어야!
// 2. 여러 동물들을 한 곳에 모아두어야 가능하다


int main()
{
	Animal a;
	Dog d;		// [a][d]

	// Dog의 메모리는 언제나 Animal의 메모리가 포함된다.

	Animal* pAnimal = &d;
	(*pAnimal).move();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-25 오후 12:00:43 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.25 수   (12주 2일)
//
// 클래스 간의 관계 - 상속(286쪽)
// 2. 다형성(polymorphism)을 구현하려고
//		- 개념 : one interface multiple behavior ( 단일명령 다중행동 )
//		- C++에서는 어떻게 구현하지?
//		- 댓가는 뭐지?
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

// (Animal 메모리 <= Dog 메모리)

class Animal {
public:
	virtual void move() const {
		cout << "동물이 움직인다" << endl;
	}
};

class Dog : public Animal {
public:
	void move() const {
		cout << "개가 뛴다" << endl;
	}
};

// 다형성을 구현하기 위해서는
// 1. 어떤 종류인지 모르는 다양한 (자식클래스) 동물들에게 move() 지시를 할 수 있어야!
// 2. 여러 동물들을 한 곳에 모아두어야 가능하다


int main()
{
	Animal a;
	Dog d;		// [a][d]

	// Dog의 메모리는 언제나 Animal의 메모리가 포함된다.

	Animal* pAnimal = &d;
	(*pAnimal).move();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-25 오후 12:03:36 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.25 수   (12주 2일)
//
// 클래스 간의 관계 - 상속(286쪽)
// 2. 다형성(polymorphism)을 구현하려고
//		- 개념 : one interface multiple behavior ( 단일명령 다중행동 )
//		- C++에서는 어떻게 구현하지?
//		- 댓가는 뭐지?
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

// (Animal 메모리 <= Dog 메모리)

class Animal {
public:
	virtual void move() const {
		cout << "동물이 움직인다" << endl;
	}
};

class Dog : public Animal {
public:
	void move() const {
		cout << "개가 뛴다" << endl;
	}
};

// 다형성을 구현하기 위해서는
// 1. 어떤 종류인지 모르는 다양한 (자식클래스) 동물들에게 move() 지시를 할 수 있어야!
// 2. 여러 동물들을 한 곳에 모아두어야 가능하다


int main()
{
	Animal a;
	Dog d;		// [a][d]


	// [문제] a와 d의 메모리 크기를 출력하시오.
	cout << "동물 " << sizeof(Animal) << " - 개 " << sizeof(Dog) << endl;
	// Dog의 메모리는 언제나 Animal의 메모리가 포함된다.

	/*Animal* pAnimal = &d;
	(*pAnimal).move();*/

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-25 오후 12:04:06 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.25 수   (12주 2일)
//
// 클래스 간의 관계 - 상속(286쪽)
// 2. 다형성(polymorphism)을 구현하려고
//		- 개념 : one interface multiple behavior ( 단일명령 다중행동 )
//		- C++에서는 어떻게 구현하지?
//		- 댓가는 뭐지?
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

// (Animal 메모리 <= Dog 메모리)

class Animal {
public:
	void move() const {
		cout << "동물이 움직인다" << endl;
	}
};

class Dog : public Animal {
public:
	void move() const {
		cout << "개가 뛴다" << endl;
	}
};

// 다형성을 구현하기 위해서는
// 1. 어떤 종류인지 모르는 다양한 (자식클래스) 동물들에게 move() 지시를 할 수 있어야!
// 2. 여러 동물들을 한 곳에 모아두어야 가능하다


int main()
{
	Animal a;
	Dog d;		// [a][d]


	// [문제] a와 d의 메모리 크기를 출력하시오.
	cout << "동물 " << sizeof(Animal) << " - 개 " << sizeof(Dog) << endl;
	// Dog의 메모리는 언제나 Animal의 메모리가 포함된다.

	/*Animal* pAnimal = &d;
	(*pAnimal).move();*/

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-25 오후 12:05:13 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.25 수   (12주 2일)
//
// 클래스 간의 관계 - 상속(286쪽)
// 2. 다형성(polymorphism)을 구현하려고
//		- 개념 : one interface multiple behavior ( 단일명령 다중행동 )
//		- C++에서는 어떻게 구현하지?
//		- 댓가는 뭐지?
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// (Animal 메모리 <= Dog 메모리)

class Animal {
	string name;
public:
	void move() const {
		cout << "동물이 움직인다" << endl;
	}
};

class Dog : public Animal {
public:
	void move() const {
		cout << "개가 뛴다" << endl;
	}
};

// 다형성을 구현하기 위해서는
// 1. 어떤 종류인지 모르는 다양한 (자식클래스) 동물들에게 move() 지시를 할 수 있어야!
// 2. 여러 동물들을 한 곳에 모아두어야 가능하다


int main()
{
	Animal a;	// [name]
	Dog d;		// [name]


	// [문제] a와 d의 메모리 크기를 출력하시오.
	cout << "동물 " << sizeof(Animal) << " - 개 " << sizeof(Dog) << endl;
	// Dog의 메모리는 언제나 Animal의 메모리가 포함된다.

	/*Animal* pAnimal = &d;
	(*pAnimal).move();*/

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-25 오후 12:05:29 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.25 수   (12주 2일)
//
// 클래스 간의 관계 - 상속(286쪽)
// 2. 다형성(polymorphism)을 구현하려고
//		- 개념 : one interface multiple behavior ( 단일명령 다중행동 )
//		- C++에서는 어떻게 구현하지?
//		- 댓가는 뭐지?
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// (Animal 메모리 <= Dog 메모리)

class Animal {
	string name;
public:
	void move() const {
		cout << "동물이 움직인다" << endl;
	}
};

class Dog : public Animal {
public:
	virtual void move() const {
		cout << "개가 뛴다" << endl;
	}
};

// 다형성을 구현하기 위해서는
// 1. 어떤 종류인지 모르는 다양한 (자식클래스) 동물들에게 move() 지시를 할 수 있어야!
// 2. 여러 동물들을 한 곳에 모아두어야 가능하다


int main()
{
	Animal a;	// [name]
	Dog d;		// [name]


	// [문제] a와 d의 메모리 크기를 출력하시오.
	cout << "동물 " << sizeof(Animal) << " - 개 " << sizeof(Dog) << endl;
	// Dog의 메모리는 언제나 Animal의 메모리가 포함된다.

	/*Animal* pAnimal = &d;
	(*pAnimal).move();*/

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-25 오후 12:05:53 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.25 수   (12주 2일)
//
// 클래스 간의 관계 - 상속(286쪽)
// 2. 다형성(polymorphism)을 구현하려고
//		- 개념 : one interface multiple behavior ( 단일명령 다중행동 )
//		- C++에서는 어떻게 구현하지?
//		- 댓가는 뭐지?
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// (Animal 메모리 <= Dog 메모리)

class Animal {
	string name;
public:
	virtual void move() const {
		cout << "동물이 움직인다" << endl;
	}
};

class Dog : public Animal {
public:
	void move() const {
		cout << "개가 뛴다" << endl;
	}
};

// 다형성을 구현하기 위해서는
// 1. 어떤 종류인지 모르는 다양한 (자식클래스) 동물들에게 move() 지시를 할 수 있어야!
// 2. 여러 동물들을 한 곳에 모아두어야 가능하다


int main()
{
	Animal a;	// [name]
	Dog d;		// [name]


	// [문제] a와 d의 메모리 크기를 출력하시오.
	cout << "동물 " << sizeof(Animal) << " - 개 " << sizeof(Dog) << endl;
	// Dog의 메모리는 언제나 Animal의 메모리가 포함된다.

	/*Animal* pAnimal = &d;
	(*pAnimal).move();*/

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-25 오후 12:06:10 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.25 수   (12주 2일)
//
// 클래스 간의 관계 - 상속(286쪽)
// 2. 다형성(polymorphism)을 구현하려고
//		- 개념 : one interface multiple behavior ( 단일명령 다중행동 )
//		- C++에서는 어떻게 구현하지?
//		- 댓가는 뭐지?
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// (Animal 메모리 <= Dog 메모리)

class Animal {
	string name;
public:
	void move() const {
		cout << "동물이 움직인다" << endl;
	}
};

class Dog : public Animal {
public:
	virtual void move() const {
		cout << "개가 뛴다" << endl;
	}
};

// 다형성을 구현하기 위해서는
// 1. 어떤 종류인지 모르는 다양한 (자식클래스) 동물들에게 move() 지시를 할 수 있어야!
// 2. 여러 동물들을 한 곳에 모아두어야 가능하다


int main()
{
	Animal a;	// [name]
	Dog d;		// [name]


	// [문제] a와 d의 메모리 크기를 출력하시오.
	cout << "동물 " << sizeof(Animal) << " - 개 " << sizeof(Dog) << endl;
	// Dog의 메모리는 언제나 Animal의 메모리가 포함된다.

	Animal* pAnimal = &d;
	(*pAnimal).move();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-25 오후 12:15:44 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.25 수   (12주 2일)
//
// 클래스 간의 관계 - 상속(286쪽)
// 2. 다형성(polymorphism)을 구현하려고
//		- 개념 : one interface multiple behavior ( 단일명령 다중행동 )
//		- C++에서는 어떻게 구현하지?
//		- 댓가는 뭐지?
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// (Animal 메모리 <= Dog 메모리)

class Animal {
	string name;
public:
	virtual void move() const {
		cout << "동물이 움직인다" << endl;
	}
};

class Dog : public Animal {
public:
	void move() const {
		cout << "개가 뛴다" << endl;
	}
};

// 다형성을 구현하기 위해서는
// 1. 어떤 종류인지 모르는 다양한 (자식클래스) 동물들에게 move() 지시를 할 수 있어야!
// 2. 여러 동물들을 한 곳에 모아두어야 가능하다


int main()
{
	Animal a;
	Dog d;

	Animal* pAnimal = &d;	// 자식 객체를 언제나 부모의 포인터로 가리킬 수 있다
	pAnimal->move();		// 자식이 Dog인지 모르지만 move 하라고 할 수 있다.

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-25 오후 12:20:13 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.25 수   (12주 2일)
//
// 클래스 간의 관계 - 상속(286쪽)
// 2. 다형성(polymorphism)을 구현하려고
//		- 개념 : one interface multiple behavior ( 단일명령 다중행동 )
//		- C++에서는 어떻게 구현하지?
//		- 댓가는 뭐지?
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// (Animal 메모리 <= Dog 메모리)

class Animal {
	string name;
public:
	virtual void move() const {
		cout << "동물이 움직인다" << endl;
	}
};

class Dog : public Animal {
public:
	void move() const {
		cout << "개가 뛴다" << endl;
	}
};

class Bird : public Animal {
public:
	void move() const {
		cout << "새가 난다" << endl;
	}
};

// 다형성을 구현하기 위해서는
// 1. 어떤 종류인지 모르는 다양한 (자식클래스) 동물들에게 move() 지시를 할 수 있어야!
// 2. 여러 동물들을 한 곳에 모아두어야 가능하다


int main()
{
	Dog d;
	Bird b;

	Animal* animals[2];

	animals[0] = &d;
	animals[1] = &b;

	// 동물들아 move() 해!
	for (Animal* p : animals)
		p->move();

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-25 오후 1:06:42 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.25 수   (12주 2일)
//
// 클래스 간의 관계 - 상속(286쪽)
// 2. 다형성(polymorphism)을 구현하려고
//		- 개념 : one interface multiple behavior ( 단일명령 다중행동 )
//		- C++에서는 어떻게 구현하지?
//		- 댓가는 뭐지?
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include <random>
#include "save.h"
using namespace std;

// (Animal 메모리 <= Dog 메모리)

// Animal 모든 동물 클래스의 부모이며 실재하는 것은 아니다.
// Animal a; 실제 객체를 만들 이유는 없다.
// 아예 객체를 만들지 못하도록 할 수 있는데 하나 이상의 멤버함수가 순수가상함수이면
// 그렇게 할 수 있다.
// 이런 클래스를 abstract class(추상클래스)라고 한다. (반대 - concrete class)
class Animal {
public:
	virtual void move() const = 0;	// 순수가상함수
};

class Dog : public Animal {
public:
	void move() const {
		cout << "Dog가 뛴다" << endl;
	}
};

class Bird : public Animal {
public:
	void move() const {
		cout << "Bird가 난다" << endl;
	}
};

// 다형성을 구현하기 위해서는
// 1. 어떤 종류인지 모르는 다양한 (자식클래스) 동물들에게 move() 지시를 할 수 있어야!
// 2. 여러 동물들을 한 곳에 모아두어야 가능하다

// [문제] 사용자의 입력을 받아 동물들을 관리하는 프로그램
// 1. 몇 마리를 만들지 입력받는다
// 2. 랜덤값을 사용하여 홀수면 Dog를 생성, 짝수면 Bird를 생성한다
// 3. 모든 동물에게 move() 명령을 내린다.
// 4. 1 ~ 3 을 반복 실행할 수 있도록 코드를 작성한다.

default_random_engine dre;

int main()
{
	//while ( true )
	{
		int num;
		cout << "몇 마리를 만들까요? ";
		cin >> num;

		Animal** animals = new Animal * [num];

		uniform_int_distribution<> uid{ 0, 1 };

		for (int i = 0; i < num; ++i) {
			if (uid(dre) == 1)
				animals[i] = new Dog;
			else
				animals[i] = new Bird;
		}

		for (int i = 0; i < num; ++i)
			animals[i]->move();

		for (int i = 0; i < num; ++i)
			delete animals[i];

		delete[] animals;

		cout << endl << "------------------------------------" << endl << endl;
	}
	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-25 오후 1:08:17 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.25 수   (12주 2일)
//
// 클래스 간의 관계 - 상속(286쪽)
// 2. 다형성(polymorphism)을 구현하려고
//		- 개념 : one interface multiple behavior ( 단일명령 다중행동 )
//		- C++에서는 어떻게 구현하지?
//		- 댓가는 뭐지?
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include <random>
#include "save.h"
using namespace std;

// (Animal 메모리 <= Dog 메모리)

// Animal 모든 동물 클래스의 부모이며 실재하는 것은 아니다.
// Animal a; 실제 객체를 만들 이유는 없다.
// 아예 객체를 만들지 못하도록 할 수 있는데 하나 이상의 멤버함수가 순수가상함수이면
// 그렇게 할 수 있다.
// 이런 클래스를 abstract class(추상클래스)라고 한다. (반대 - concrete class)
class Animal {
public:
	virtual void move() const = 0;	// 순수가상함수
};

class Dog : public Animal {
public:
	void move() const override {
		cout << "Dog가 뛴다" << endl;
	}
};

class Bird : public Animal {
public:
	void move() const override {
		cout << "Bird가 난다" << endl;
	}
};

// 다형성을 구현하기 위해서는
// 1. 어떤 종류인지 모르는 다양한 (자식클래스) 동물들에게 move() 지시를 할 수 있어야!
// 2. 여러 동물들을 한 곳에 모아두어야 가능하다

// [문제] 사용자의 입력을 받아 동물들을 관리하는 프로그램
// 1. 몇 마리를 만들지 입력받는다
// 2. 랜덤값을 사용하여 홀수면 Dog를 생성, 짝수면 Bird를 생성한다
// 3. 모든 동물에게 move() 명령을 내린다.
// 4. 1 ~ 3 을 반복 실행할 수 있도록 코드를 작성한다.

default_random_engine dre;

int main()
{
	//while ( true )
	{
		int num;
		cout << "몇 마리를 만들까요? ";
		cin >> num;

		Animal** animals = new Animal * [num];

		uniform_int_distribution<> uid{ 0, 1 };

		for (int i = 0; i < num; ++i) {
			if (uid(dre) == 1)
				animals[i] = new Dog;
			else
				animals[i] = new Bird;
		}

		for (int i = 0; i < num; ++i)
			animals[i]->move();

		for (int i = 0; i < num; ++i)
			delete animals[i];

		delete[] animals;

		cout << endl << "------------------------------------" << endl << endl;
	}
	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-30 오후 1:57:56 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.30 월   (13주 1일)
//
// 클래스 간의 관계 - 상속(286쪽)
// 2. 다형성(polymorphism)을 구현하려고
//		- 개념 : one interface multiple behavior ( 단일명령 다중행동 )
//		- C++에서는 어떻게 구현하지?
//		- 댓가는 뭐지?
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include <random>
#include "save.h"
using namespace std;

// (Animal 메모리 <= Dog 메모리)

// Animal 모든 동물 클래스의 부모이며 실재하는 것은 아니다.
// Animal a; 실제 객체를 만들 이유는 없다.
// 아예 객체를 만들지 못하도록 할 수 있는데 하나 이상의 멤버함수가 순수가상함수이면
// 그렇게 할 수 있다.
// 이런 클래스를 abstract class(추상클래스)라고 한다. (반대 - concrete class)
class Animal {
public:
	virtual void move() const = 0;	// 순수가상함수
};

class Dog : public Animal {
public:
	void move() const override {
		cout << "Dog가 뛴다" << endl;
	}
};

class Bird : public Animal {
public:
	void move() const override {
		cout << "Bird가 난다" << endl;
	}
};

// 다형성을 구현하기 위해서는
// 1. 어떤 종류인지 모르는 다양한 (자식클래스) 동물들에게 move() 지시를 할 수 있어야!
// 2. 여러 동물들을 한 곳에 모아두어야 가능하다

// [문제] 사용자의 입력을 받아 동물들을 관리하는 프로그램
// 1. 몇 마리를 만들지 입력받는다
// 2. 랜덤값을 사용하여 홀수면 Dog를 생성, 짝수면 Bird를 생성한다
// 3. 모든 동물에게 move() 명령을 내린다.
//  3.1 동물중에 Dog에게만 move()를 호출하자.
// 4. 1 ~ 3 을 반복 실행할 수 있도록 코드를 작성한다.

default_random_engine dre;

int main()
{
	//while ( true )
	{
		int num;
		cout << "몇 마리를 만들까요? ";
		cin >> num;

		Animal** animals = new Animal * [num];

		uniform_int_distribution<> uid{ 0, 1 };

		for (int i = 0; i < num; ++i) {
			if (uid(dre) == 1)
				animals[i] = new Dog;
			else
				animals[i] = new Bird;
		}

		for (int i = 0; i < num; ++i) {
			//if (만일 animals[i]가 원래는 Dog 였다면)
			if ( dynamic_cast<Dog*>(animals[i]) != nullptr )
				animals[i]->move();
		}

		for (int i = 0; i < num; ++i)
			delete animals[i];

		delete[] animals;

		cout << endl << "------------------------------------" << endl << endl;
	}
	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-30 오후 2:04:11 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.30 월   (13주 1일)
//
// 클래스 간의 관계 - 상속(286쪽)
// 2. 다형성(polymorphism)을 구현하려고
//		- 개념 : one interface multiple behavior ( 단일명령 다중행동 )
//		- C++에서는 어떻게 구현하지?
//		- 댓가는 뭐지?
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include <random>
#include "save.h"
using namespace std;

// (Animal 메모리 <= Dog 메모리)

// Animal 모든 동물 클래스의 부모이며 실재하는 것은 아니다.
// Animal a; 실제 객체를 만들 이유는 없다.
// 아예 객체를 만들지 못하도록 할 수 있는데 하나 이상의 멤버함수가 순수가상함수이면
// 그렇게 할 수 있다.
// 이런 클래스를 abstract class(추상클래스)라고 한다. (반대 - concrete class)
class Animal {
public:
	virtual void move() const = 0;	// 순수가상함수

	// 어떤 클래스에 소멸자를 코딩해야 하는 경우는?
	// - 생성하면서 자원을 획득했다면 소멸자에서 반환해야 한다
	// virtual ~Animal() {}
};

class Dog : public Animal {
public:
	void move() const override {
		cout << "Dog가 뛴다" << endl;
	}
};

class Bird : public Animal {
public:
	void move() const override {
		cout << "Bird가 난다" << endl;
	}
};

// 다형성을 구현하기 위해서는
// 1. 어떤 종류인지 모르는 다양한 (자식클래스) 동물들에게 move() 지시를 할 수 있어야!
// 2. 여러 동물들을 한 곳에 모아두어야 가능하다

// [문제] 사용자의 입력을 받아 동물들을 관리하는 프로그램
// 1. 몇 마리를 만들지 입력받는다
// 2. 랜덤값을 사용하여 홀수면 Dog를 생성, 짝수면 Bird를 생성한다
// 3. 모든 동물에게 move() 명령을 내린다.
//  3.1 동물중에 Dog에게만 move()를 호출하자.
// 4. 1 ~ 3 을 반복 실행할 수 있도록 코드를 작성한다.

default_random_engine dre;

int main()
{
	//while ( true )
	{
		int num;
		cout << "몇 마리를 만들까요? ";
		cin >> num;

		Animal** animals = new Animal * [num];

		uniform_int_distribution<> uid{ 0, 1 };

		for (int i = 0; i < num; ++i) {
			if (uid(dre) == 1)
				animals[i] = new Dog;
			else
				animals[i] = new Bird;
		}

		for (int i = 0; i < num; ++i) {
			//if (만일 animals[i]가 원래는 Dog 였다면)
			if ( dynamic_cast<Dog*>(animals[i]) != nullptr )
				animals[i]->move();
		}

		for (int i = 0; i < num; ++i)
			delete animals[i];

		delete[] animals;

		cout << endl << "------------------------------------" << endl << endl;
	}
	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-30 오후 2:06:57 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.30 월   (13주 1일)
//
// 클래스 간의 관계 - 상속(286쪽)
// 2. 다형성(polymorphism)을 구현하려고
//		- 개념 : one interface multiple behavior ( 단일명령 다중행동 )
//		- C++에서는 어떻게 구현하지?
//		- 댓가는 뭐지?
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

int main()
{
	cout << "CODE Segment 코드가 기록되는 메모리 세그먼트" << endl;
	cout << "main 주소 - " << &main << endl;
	cout << "save 주소 - " << &save << endl;
	cout << "printf의 주소 - " << &printf << endl;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-30 오후 2:08:37 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.30 월   (13주 1일)
//
// 클래스 간의 관계 - 상속(286쪽)
// 2. 다형성(polymorphism)을 구현하려고
//		- 개념 : one interface multiple behavior ( 단일명령 다중행동 )
//		- C++에서는 어떻게 구현하지?
//		- 댓가는 뭐지?
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

int main()
{
	cout << "CODE Segment 코드가 기록되는 메모리 세그먼트" << endl;
	cout << "main 주소 - " << &main << endl;
	cout << "save 주소 - " << &save << endl;
	cout << "printf의 주소 - " << &printf << endl;
	cout << endl;

	int n;
	string s{"12341241515662343"};
	cout << "STACK의 주소" << endl;
	cout << "지역변수 n - " << &n << endl;
	cout << "지역변수 s - " << &s << endl;


	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-30 오후 2:12:06 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.30 월   (13주 1일)
//
// 클래스 간의 관계 - 상속(286쪽)
// 2. 다형성(polymorphism)을 구현하려고
//		- 개념 : one interface multiple behavior ( 단일명령 다중행동 )
//		- C++에서는 어떻게 구현하지?
//		- 댓가는 뭐지?
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

class Animal {
public:
	void move() {
		cout << "sardagasdgdas" << endl;
	}
};



int main()
{
	cout << "CODE Segment 코드가 기록되는 메모리 세그먼트" << endl;
	cout << "main 주소 - " << &main << endl;
	cout << "save 주소 - " << &save << endl;
	cout << "printf의 주소 - " << &printf << endl;

	auto pmf = &Animal::move;
	void* vp = &pmf;
	cout << "멤버함수의 주소 - " << *(int*)vp << endl;


	cout << endl;

	int n;
	string s{"12341241515662343"};
	cout << "STACK의 주소" << endl;
	cout << "지역변수 n - " << &n << endl;
	cout << "지역변수 s - " << &s << endl;


	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-11-30 오후 2:12:58 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             11.30 월   (13주 1일)
//
// 클래스 간의 관계 - 상속(286쪽)
// 2. 다형성(polymorphism)을 구현하려고
//		- 개념 : one interface multiple behavior ( 단일명령 다중행동 )
//		- C++에서는 어떻게 구현하지?
//		- 댓가는 뭐지?
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

class Animal {
public:
	void move() {
		cout << "sardagasdgdas" << endl;
	}
};



int main()
{
	cout << "CODE Segment 코드가 기록되는 메모리 세그먼트" << endl;
	cout << "main 주소 - " << &main << endl;
	cout << "save 주소 - " << &save << endl;
	cout << "printf의 주소 - " << &printf << endl;

	auto pmf = &Animal::move;
	void* vp = &pmf;
	cout << "멤버함수의 주소 - " << hex << *(int*)vp << endl;


	cout << endl;

	int n;
	string s{"12341241515662343"};
	cout << "STACK의 주소" << endl;
	cout << "지역변수 n - " << &n << endl;
	cout << "지역변수 s - " << &s << endl;


	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-12-07 오후 1:40:22 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             12. 7 월   (14주 1일)
//
// Template - 왜 만들어진건가?
//			  이걸로 뭘 할 수 있나?
// 함수, 클래스
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

// main 고치지 말고 의도대로 실행되게 해 보자

void change(int&, int&);

int main()
{
	int a{ 1 }, b{ 2 };

	change(a, b);

	cout << a << ", " << b << endl;		// 2, 1

	save("소스.cpp");
}

void change(int& a, int& b)
{
	int temp{ a };
	a = b;
	b = temp;
}



-------------------------------------------
소스.cpp - 2020-12-07 오후 1:45:14 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             12. 7 월   (14주 1일)
//
// Template - 왜 만들어진건가?
//			  이걸로 뭘 할 수 있나?
// 함수, 클래스
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

// main 고치지 말고 의도대로 실행되게 해 보자

void change(char&, char&);
void change(int&, int&);

int main()
{
	char a{ 1 }, b{ 2 };

	change(a, b);

	cout << a << ", " << b << endl;		// 2, 1

	save("소스.cpp");
}

void change(int& a, int& b)
{
	int temp{ a };
	a = b;
	b = temp;
}

void change(char& a, char& b)
{
	char temp{ a };
	a = b;
	b = temp;
}


-------------------------------------------
소스.cpp - 2020-12-07 오후 1:45:30 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             12. 7 월   (14주 1일)
//
// Template - 왜 만들어진건가?
//			  이걸로 뭘 할 수 있나?
// 함수, 클래스
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

// main 고치지 말고 의도대로 실행되게 해 보자

void change(char&, char&);
void change(int&, int&);

int main()
{
	char a{ '1' }, b{ '2' };

	change(a, b);

	cout << a << ", " << b << endl;		// 2, 1

	save("소스.cpp");
}

void change(int& a, int& b)
{
	int temp{ a };
	a = b;
	b = temp;
}

void change(char& a, char& b)
{
	char temp{ a };
	a = b;
	b = temp;
}


-------------------------------------------
소스.cpp - 2020-12-07 오후 1:49:50 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             12. 7 월   (14주 1일)
//
// Template - 왜 만들어진건가?
//			  이걸로 뭘 할 수 있나?
// 함수, 클래스
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

// main 고치지 말고 의도대로 실행되게 해 보자

class Dog {
	char ch;
public:
	Dog(char c) : ch(c) {};

	friend ostream& operator<<(ostream&, const Dog&);
};

ostream& operator<<(ostream& os, const Dog& dog)
{
	os << dog.ch;
	return os;
}

void change(char&, char&);
void change(int&, int&);
void change(Dog&, Dog&);

int main()
{
	Dog a{ '1' }, b{ '2' };

	change(a, b);

	cout << a << ", " << b << endl;		// 2, 1

	save("소스.cpp");
}

void change(int& a, int& b)
{
	int temp{ a };
	a = b;
	b = temp;
}

void change(char& a, char& b)
{
	char temp{ a };
	a = b;
	b = temp;
}

void change(Dog& a, Dog& b)
{
	Dog temp{ a };
	a = b;
	b = temp;
}


-------------------------------------------
소스.cpp - 2020-12-07 오후 2:00:25 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             12. 7 월   (14주 1일)
//
// Template - 왜 만들어진건가?
//			  이걸로 뭘 할 수 있나?
// 함수, 클래스
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

// main 고치지 말고 의도대로 실행되게 해 보자

class Dog {
	char c;
public:
	Dog(char c) : c{ c } {};

	operator char() {
		return c;
	}

	//friend ostream& operator<<(ostream&, const Dog&);
};

//ostream& operator<<(ostream& os, const Dog& dog)
//{
	//os << dog.c;
	//return os;
//}

void change(char&, char&);
void change(int&, int&);
void change(Dog&, Dog&);

int main()
{
	Dog a{ '1' }, b{ '2' };

	change(a, b);

	cout << a << ", " << b << endl;		// 2, 1

	save("소스.cpp");
}

void change(int& a, int& b)
{
	int temp{ a };
	a = b;
	b = temp;
}

void change(char& a, char& b)
{
	char temp{ a };
	a = b;
	b = temp;
}

void change(Dog& a, Dog& b)
{
	Dog temp{ a };
	a = b;
	b = temp;
}


-------------------------------------------
소스.cpp - 2020-12-07 오후 2:11:40 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             12. 7 월   (14주 1일)
//
// Template - 왜 만들어진건가?
//			  이걸로 뭘 할 수 있나?
// 함수, 클래스
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

// main 고치지 말고 의도대로 실행되게 해 보자

class Dog {
	char c;
public:
	Dog(char c) : c{ c } {};

	friend ostream& operator<<(ostream&, const Dog&);
};

ostream& operator<<(ostream& os, const Dog& dog)
{
	os << dog.c;
	return os;
}

template <typename T>
void change(T& a, T& b)
{
	T temp{ a };
	a = b;
	b = temp;
}

int main()
{
	Dog a{ '1' }, b{ '2' };

	change(a, b);

	cout << a << ", " << b << endl;		// 2, 1

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-12-07 오후 2:17:42 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             12. 7 월   (14주 1일)
//
// Template - 왜 만들어진건가?
//			  이걸로 뭘 할 수 있나?
// 함수, 클래스
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

// main 고치지 말고 의도대로 실행되게 해 보자

template <typename T>
void change(T& a, T& b)
{
	T temp{ a };
	a = b;
	b = temp;
}

template <>
void change(int& a, int& b)
{
	int temp{ a };
	a = b;
	b = temp;
	cout << " 익 ㅔ불림 " << endl;
}

int main()
{
	int a{ 10 }, b{ 20 };
	
	change(a, b);

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-12-07 오후 2:18:12 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             12. 7 월   (14주 1일)
//
// Template - 왜 만들어진건가?
//			  이걸로 뭘 할 수 있나?
// 함수, 클래스
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

// main 고치지 말고 의도대로 실행되게 해 보자

template <typename T>
void change(T& a, T& b)
{
	T temp{ a };
	a = b;
	b = temp;
}

template <>
void change(int& a, int& b)
{
	int temp{ a };
	a = b;
	b = temp;
	cout << " 익 ㅔ불림 " << endl;
}

void change(int a, int b)
{
	cout << "얘가 불림" << endl;
}

int main()
{
	int a{ 10 }, b{ 20 };
	
	change(a, b);

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-12-07 오후 2:54:51 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             12. 7 월   (14주 1일)
//
// Template - 왜 만들어진건가? - 자료형이 무한하다
//				오버로딩을 컴퓨터 시켜서 하자.
//
//			  이걸로 뭘 할 수 있나?
// 함수, 클래스
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

// [문제] 템플릿 함수를 만든다

template <typename T>
const T& myMax(const T& a, const T& b)
{
	if (a > b)
		return a;
	return b;
}

int main()
{
	cout << myMax(2, 1) << endl;								// 2
	cout << myMax(string{ "abc" }, string{ "def" }) << endl;	// def

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-12-07 오후 2:55:12 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             12. 7 월   (14주 1일)
//
// Template - 왜 만들어진건가? - 자료형이 무한하다
//				오버로딩을 컴퓨터 시켜서 하자.
//
//			  이걸로 뭘 할 수 있나?
// 함수, 클래스
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

// [문제] 템플릿 함수를 만든다

template <typename T>
const T& myMax(const T& a, const T& b)
{
	if (a > b)
		return a;
	return b;
}

int main()
{
	cout << myMax(2, 124) << endl;								// 2
	cout << myMax(string{ "xbc" }, string{ "xcf" }) << endl;	// def

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-12-07 오후 2:55:26 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             12. 7 월   (14주 1일)
//
// Template - 왜 만들어진건가? - 자료형이 무한하다
//				오버로딩을 컴퓨터 시켜서 하자.
//
//			  이걸로 뭘 할 수 있나?
// 함수, 클래스
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

// [문제] 템플릿 함수를 만든다

template <typename T>
const T& myMax(const T& a, const T& b)
{
	if (a > b)
		return a;
	return b;
}

int main()
{
	cout << myMax(2, 124) << endl;								// 2
	cout << myMax(string{ "xxc" }, string{ "xxb" }) << endl;	// def

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-12-07 오후 3:00:03 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             12. 7 월   (14주 1일)
//
// Template - 왜 만들어진건가? - 자료형이 무한하다
//				오버로딩을 컴퓨터 시켜서 하자.
//
//			  이걸로 뭘 할 수 있나?
// 함수, 클래스
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] 템플릿 함수를 만든다

template <typename T>
const T& myMax(const T& a, const T& b)
{
	if (a < b)
		return b;
	return a;
}

int main()
{
	cout << myMax(2, 124) << endl;								// 2
	cout << myMax(string{ "xxc" }, string{ "xxb" }) << endl;	// def

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-12-07 오후 3:01:45 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             12. 7 월   (14주 1일)
//
// Template - 왜 만들어진건가? - 자료형이 무한하다
//				오버로딩을 컴퓨터 시켜서 하자.
//
//			  이걸로 뭘 할 수 있나?
// 함수, 클래스
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] 템플릿 함수를 만든다

template <typename T>
T myMax(T a, T b)
{
	if (a < b)
		return b;
	return a;
}

int main()
{
	cout << myMax("1234", "56789") << endl;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-12-07 오후 3:02:37 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             12. 7 월   (14주 1일)
//
// Template - 왜 만들어진건가? - 자료형이 무한하다
//				오버로딩을 컴퓨터 시켜서 하자.
//
//			  이걸로 뭘 할 수 있나?
// 함수, 클래스
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] 템플릿 함수를 만든다

template <typename T>
T myMax(T a, T b)
{
	if (a < b)
		return b;
	return a;
}

int main()
{
	cout << myMax("a1234432", "56789") << endl;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-12-07 오후 3:06:56 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             12. 7 월   (14주 1일)
//
// Template - 왜 만들어진건가? - 자료형이 무한하다
//				오버로딩을 컴퓨터 시켜서 하자.
//
//			  이걸로 뭘 할 수 있나?
// 함수, 클래스
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] 템플릿 함수를 만든다

template <typename T>
T myMax(T a, T b)
{
	if (a < b)
		return b;
	return a;
}

template <>
char* myMax( char* a, char* b)
{
	if ( strlen(a) < strlen(b) )
		return b;
	return a;
}

int main()
{
	// 나는 글자수가 많은것이 크다고 생각해!
	cout << myMax("a1", "56789") << endl;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-12-07 오후 3:07:19 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             12. 7 월   (14주 1일)
//
// Template - 왜 만들어진건가? - 자료형이 무한하다
//				오버로딩을 컴퓨터 시켜서 하자.
//
//			  이걸로 뭘 할 수 있나?
// 함수, 클래스
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] 템플릿 함수를 만든다

template <typename T>
T myMax(T a, T b)
{
	if (a < b)
		return b;
	return a;
}

template <>
const char* myMax(const char* a, const char* b)
{
	if ( strlen(a) < strlen(b) )
		return b;
	return a;
}

int main()
{
	// 나는 글자수가 많은것이 크다고 생각해!
	cout << myMax("a1", "56789") << endl;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-12-07 오후 3:09:24 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             12. 7 월   (14주 1일)
//
// Template - 왜 만들어진건가? - 자료형이 무한하다
//				오버로딩을 컴퓨터 시켜서 하자.
//
//			  이걸로 뭘 할 수 있나?
// 함수, 클래스
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] 템플릿 함수를 만든다

template <typename T>
T myMax(T a, T b)
{
	if (a < b)
		return b;
	return a;
}

// template을 specialization
template <>
const char* myMax(const char* a, const char* b)
{
	if ( strlen(a) < strlen(b) )
		return b;
	return a;
}

int main()
{
	// 나는 글자수가 많은것이 크다고 생각해!
	cout << myMax("a1", "56789") << endl;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-12-07 오후 3:12:09 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             12. 7 월   (14주 1일)
//
// Template - 왜 만들어진건가? - 자료형이 무한하다
//				오버로딩을 컴퓨터 시켜서 하자.
//
//			  이걸로 뭘 할 수 있나?
// 함수, 클래스
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

class Dog {};

template <typename T>
void change(T& a, T& b)
{
	T temp{ a };
	a = b;
	b = temp;
}

int main()
{
	Dog a, b;
	change(a, b);
	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-12-07 오후 3:23:07 - (월요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             12. 7 월   (14주 1일)
//
// Template - 왜 만들어진건가? - 자료형이 무한하다
//				오버로딩을 컴퓨터 시켜서 하자.
//
//			  이걸로 뭘 할 수 있나?
// 자료형에 무관한 함수를 기술할 수 있다	 - 알고리즘
// 자료형에 무관한 자료구조를 기술할 수 있다 - 자료구조
// 함수, 클래스
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

class Dog {
	int a;
	string name;
};
// virtual
// template

// template은 generic programming을 구현하는 핵심 keyword
template <typename T>
void change(T& a, T& b)
{
	T temp{ a };
	a = b;
	b = temp;
}

int main()
{
	Dog a, b;
	change(a, b);
	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-12-09 오전 11:46:44 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             12. 9 수   (14주 2일)
//
// Template - 왜 만들어진건가? - 자료형이 무한하다
//				오버로딩을 컴퓨터 시켜서 하자.
//
//			  이걸로 뭘 할 수 있나?
//
// 자료형에 무관한 함수를 기술할 수 있다	 - 알고리즘
// 자료형에 무관한 자료구조를 기술할 수 있다 - 자료구조
// 함수, 클래스
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;


// [문제] 함수 하나를 만들어 해결하시오

template <typename T>
T add(const T& a, const T& b)
{
	T result;
	result = a + b;
	return result;
}

int main()
{
	cout << add(1, 3) << endl;
//	cout << add(3.14 + 2.71) << endl;
//	cout << add("Hello, ", "world!") << endl;
	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-12-09 오전 11:51:48 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             12. 9 수   (14주 2일)
//
// Template - 왜 만들어진건가? - 자료형이 무한하다
//				오버로딩을 컴퓨터 시켜서 하자.
//
//			  이걸로 뭘 할 수 있나?
//
// 자료형에 무관한 함수를 기술할 수 있다	 - 알고리즘
// 자료형에 무관한 자료구조를 기술할 수 있다 - 자료구조
// 함수, 클래스
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;


// [문제] 함수 하나를 만들어 해결하시오

template <typename T>
T add(const T& a, const T& b)
{
	T result = a + b;
	return result;
}

int main()
{
	cout << add(1, 3) << endl;
	cout << add(3.14, 2.71) << endl;
	cout << add<string>("Hello, ", "world!") << endl;
	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-12-09 오전 11:52:23 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             12. 9 수   (14주 2일)
//
// Template - 왜 만들어진건가? - 자료형이 무한하다
//				오버로딩을 컴퓨터 시켜서 하자.
//
//			  이걸로 뭘 할 수 있나?
//
// 자료형에 무관한 함수를 기술할 수 있다	 - 알고리즘
// 자료형에 무관한 자료구조를 기술할 수 있다 - 자료구조
// 함수, 클래스
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;


// [문제] 함수 하나를 만들어 해결하시오

template <typename T>
T add(const T& a, const T& b)
{
	T result = a + b;
	return result;
}

int main()
{
	cout << add(1, 3) << endl;
	cout << add(3.14, 2.71) << endl;
	cout << add(string{ "Hello, " }, string{ "world!" }) << endl;
	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-12-09 오후 12:02:31 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             12. 9 수   (14주 2일)
//
// Template - 왜 만들어진건가? - 자료형이 무한하다
//				오버로딩을 컴퓨터 시켜서 하자.
//
//			  이걸로 뭘 할 수 있나?
//
// 자료형에 무관한 함수를 기술할 수 있다	 - 알고리즘
// 자료형에 무관한 자료구조를 기술할 수 있다 - 자료구조
// 함수, 클래스
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

char* add(const char* a, const char* b)
{
	int num = strlen(a) + strlen(b);
	char * p = new char[num + 1];
	memcpy(p, a, strlen(a));
	memcpy(p + strlen(a), b, strlen(b));
	p[num] = 0;
	return p;
}

int main()
{
	cout << add("Hello,", " world!") << endl;
	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-12-09 오후 12:03:58 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             12. 9 수   (14주 2일)
//
// Template - 왜 만들어진건가? - 자료형이 무한하다
//				오버로딩을 컴퓨터 시켜서 하자.
//
//			  이걸로 뭘 할 수 있나?
//
// 자료형에 무관한 함수를 기술할 수 있다	 - 알고리즘
// 자료형에 무관한 자료구조를 기술할 수 있다 - 자료구조
// 함수, 클래스
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

char* add(const char* a, const char* b)
{
	int num = strlen(a) + strlen(b);
	char * p = new char[num + 1];
	strcat(p, a);
	strcat(p, b);
	return p;
}

int main()
{
	cout << add("Hello,", " world!") << endl;
	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-12-09 오후 12:04:21 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             12. 9 수   (14주 2일)
//
// Template - 왜 만들어진건가? - 자료형이 무한하다
//				오버로딩을 컴퓨터 시켜서 하자.
//
//			  이걸로 뭘 할 수 있나?
//
// 자료형에 무관한 함수를 기술할 수 있다	 - 알고리즘
// 자료형에 무관한 자료구조를 기술할 수 있다 - 자료구조
// 함수, 클래스
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

char* add(const char* a, const char* b)
{
	int num = strlen(a) + strlen(b);
	char * p = new char[num + 1];
	strcat(p, a);
	strcat(p + strlen(a), b);
	return p;
}

int main()
{
	cout << add("Hello,", " world!") << endl;
	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-12-09 오후 12:04:50 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             12. 9 수   (14주 2일)
//
// Template - 왜 만들어진건가? - 자료형이 무한하다
//				오버로딩을 컴퓨터 시켜서 하자.
//
//			  이걸로 뭘 할 수 있나?
//
// 자료형에 무관한 함수를 기술할 수 있다	 - 알고리즘
// 자료형에 무관한 자료구조를 기술할 수 있다 - 자료구조
// 함수, 클래스
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

char* add(const char* a, const char* b)
{
	int num = strlen(a) + strlen(b);
	char * p = new char[num + 1];
	p[0] = 0;
	strcat(p, a);
	strcat(p, b);
	return p;
}

int main()
{
	cout << add("Hello,", " world!") << endl;
	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-12-09 오후 12:17:43 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             12. 9 수   (14주 2일)
//
// Template - 왜 만들어진건가? - 자료형이 무한하다
//				오버로딩을 컴퓨터 시켜서 하자.
//
//			  이걸로 뭘 할 수 있나?
//
// 자료형에 무관한 함수를 기술할 수 있다	 - 알고리즘
// 자료형에 무관한 자료구조를 기술할 수 있다 - 자료구조
// 함수, 클래스
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

// 함수 템플릿
// 클래스 템플릿

class Test {
	int num;
	char* p;
public:
	Test(int n) : num{ n }, p{ new char[num] } {}
	~Test() { delete[] p; }
};

int main()
{
	unique_ptr<Test> p{ new Test {10000} };

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-12-09 오후 12:18:37 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             12. 9 수   (14주 2일)
//
// Template - 왜 만들어진건가? - 자료형이 무한하다
//				오버로딩을 컴퓨터 시켜서 하자.
//
//			  이걸로 뭘 할 수 있나?
//
// 자료형에 무관한 함수를 기술할 수 있다	 - 알고리즘
// 자료형에 무관한 자료구조를 기술할 수 있다 - 자료구조
// 함수, 클래스
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

// 함수 템플릿
// 클래스 템플릿

class Test {
	int num;
	char* p;
public:
	Test(int n) : num{ n }, p{ new char[num] } {
		cout << "생성자 - " << num << endl;
	}
	~Test() { 
		cout << "소멸자 - " << num << endl;
		delete[] p; 
	}
};

int main()
{
	unique_ptr<Test> p{ new Test {10000} };

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-12-09 오후 12:34:08 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             12. 9 수   (14주 2일)
//
// Template - 왜 만들어진건가? - 자료형이 무한하다
//				오버로딩을 컴퓨터 시켜서 하자.
//
//			  이걸로 뭘 할 수 있나?
//
// 자료형에 무관한 함수를 기술할 수 있다	 - 알고리즘
// 자료형에 무관한 자료구조를 기술할 수 있다 - 자료구조
// 함수, 클래스
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

// 함수 템플릿
// 클래스 템플릿

class Test {
	int num;
	char* p;
public:
	Test(int n) : num{ n }, p{ new char[num] } {
		cout << "생성자 - " << num << endl;
	}
	~Test() { 
		cout << "소멸자 - " << num << endl;
		delete[] p; 
	}
};

struct Dog {
	Dog() {
		cout << "Dog 생성" << endl;
	}
	~Dog() {
		cout << "Dog 소멸" << endl;
	}
};

template <typename T>
class Smart {
	T* sp;
public:
	Smart(T* p) : sp{ p } {}
	~Smart() {
		delete sp;
	}
};


int main()
{
	Smart s_dog{ new Dog };
	Smart s_test{ new Test {1234} };

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-12-09 오후 12:44:38 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             12. 9 수   (14주 2일)
//
// Template - 왜 만들어진건가? - 자료형이 무한하다
//				오버로딩을 컴퓨터 시켜서 하자.
//
//			  이걸로 뭘 할 수 있나?
//
// 자료형에 무관한 함수를 기술할 수 있다	 - 알고리즘
// 자료형에 무관한 자료구조를 기술할 수 있다 - 자료구조
// 함수, 클래스
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include <array>
#include "save.h"
using namespace std;

int main()
{
	array<int, 10> a{ 1, 2, 3, 4, 5 };

	for (int n : a)
		cout << n << ' ';
	cout << endl;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-12-09 오후 12:45:36 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             12. 9 수   (14주 2일)
//
// Template - 왜 만들어진건가? - 자료형이 무한하다
//				오버로딩을 컴퓨터 시켜서 하자.
//
//			  이걸로 뭘 할 수 있나?
//
// 자료형에 무관한 함수를 기술할 수 있다	 - 알고리즘
// 자료형에 무관한 자료구조를 기술할 수 있다 - 자료구조
// 함수, 클래스
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include <array>
#include "save.h"
using namespace std;

int main()
{
	array<int, 10> a{ 1, 2, 3, 4, 5 };

	for (int n : a)
		cout << n << ' ';
	cout << endl;

	for (int i = 0; i < a.size(); ++i)
		cout << a[i] << ' ';
	cout << endl;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-12-09 오후 12:46:15 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             12. 9 수   (14주 2일)
//
// Template - 왜 만들어진건가? - 자료형이 무한하다
//				오버로딩을 컴퓨터 시켜서 하자.
//
//			  이걸로 뭘 할 수 있나?
//
// 자료형에 무관한 함수를 기술할 수 있다	 - 알고리즘
// 자료형에 무관한 자료구조를 기술할 수 있다 - 자료구조
// 함수, 클래스
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include <array>
#include "save.h"
using namespace std;

int main()
{
	array<int, 10> a{ 1, 2, 3, 4, 5 };

	cout << a[-1] << endl;
	cout << a[10] << endl;

	for (int n : a)
		cout << n << ' ';
	cout << endl;

	for (int i = 0; i < a.size(); ++i)
		cout << a[i] << ' ';
	cout << endl;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-12-09 오후 12:53:15 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             12. 9 수   (14주 2일)
//
// Template - 왜 만들어진건가? - 자료형이 무한하다
//				오버로딩을 컴퓨터 시켜서 하자.
//
//			  이걸로 뭘 할 수 있나?
//
// 자료형에 무관한 함수를 기술할 수 있다	 - 알고리즘
// 자료형에 무관한 자료구조를 기술할 수 있다 - 자료구조
// 함수, 클래스
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include <array>
#include "save.h"
using namespace std;

int main()
{
	array<int, 10> a{ 1, 2, 3, 4, 5 };


	try {
		cout << a.at(-1) << endl;
		cout << a.at(10) << endl;
	}
	catch( exception& e ) {
		cout << e.what() << endl;
	}

	for (int n : a)
		cout << n << ' ';
	cout << endl;

	for (int i = 0; i < a.size(); ++i)
		cout << a[i] << ' ';
	cout << endl;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-12-09 오후 12:54:20 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             12. 9 수   (14주 2일)
//
// Template - 왜 만들어진건가? - 자료형이 무한하다
//				오버로딩을 컴퓨터 시켜서 하자.
//
//			  이걸로 뭘 할 수 있나?
//
// 자료형에 무관한 함수를 기술할 수 있다	 - 알고리즘
// 자료형에 무관한 자료구조를 기술할 수 있다 - 자료구조
// 함수, 클래스
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include <array>
#include "save.h"
using namespace std;

int main()
{
	array<int, 10> a{ 1, 2, 3, 4, 5 };


	try {
		cout << a.at(2) << endl;
		cout << a.at(10) << endl;
	}
	catch( exception& e ) {
		cout << e.what() << endl;
	}

	for (int n : a)
		cout << n << ' ';
	cout << endl;

	for (int i = 0; i < a.size(); ++i)
		cout << a[i] << ' ';
	cout << endl;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-12-09 오후 1:03:04 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             12. 9 수   (14주 2일)
//
// Template - 왜 만들어진건가? - 자료형이 무한하다
//				오버로딩을 컴퓨터 시켜서 하자.
//
//			  이걸로 뭘 할 수 있나?
//
// 자료형에 무관한 함수를 기술할 수 있다	 - 알고리즘
// 자료형에 무관한 자료구조를 기술할 수 있다 - 자료구조
// 함수, 클래스
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

// 범위를 벗어난 인덱싱을 처리하는 INT 배열을 만든다

class INT_Array {
	int num;
	int* p;

public:
	INT_Array(int n) : num{ n }, p{ new int[num] }  {
		for (int i = 0; i < num; ++i)
			p[i] = 0;
	}
	~INT_Array() {
		delete[] p;
	}

	int size() const {
		return num;
	}

	int operator[](int idx) const {
		return p[idx];
	}
};

int main()
{
	INT_Array a{ 10 };		// int 10개 들어갈 배열

	for (int i = 0; i < a.size(); ++i)
		cout << a[i] << ' ';
	cout << endl;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-12-09 오후 1:06:23 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             12. 9 수   (14주 2일)
//
// Template - 왜 만들어진건가? - 자료형이 무한하다
//				오버로딩을 컴퓨터 시켜서 하자.
//
//			  이걸로 뭘 할 수 있나?
//
// 자료형에 무관한 함수를 기술할 수 있다	 - 알고리즘
// 자료형에 무관한 자료구조를 기술할 수 있다 - 자료구조
// 함수, 클래스
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

// 범위를 벗어난 인덱싱을 처리하는 INT 배열을 만든다

class INT_Array {
	int num;
	int* p;

public:
	INT_Array(int n) : num{ n }, p{ new int[num] }  {
		for (int i = 0; i < num; ++i)
			p[i] = 0;
	}
	~INT_Array() {
		delete[] p;
	}

	int size() const {
		return num;
	}

	int operator[](int idx) const {			// 읽기
		cout << "dd";
		return p[idx];
	}

	int& operator[](int idx) {				// 읽거나 쓰거나
		return p[idx];
	}
};

int main()
{
	INT_Array a{ 10 };		// int 10개 들어갈 배열

	for (int i = 0; i < a.size(); ++i)
		a[i] = i + 1;


	for (int i = 0; i < a.size(); ++i)
		cout << a[i] << ' ';
	cout << endl;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-12-09 오후 1:09:26 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             12. 9 수   (14주 2일)
//
// Template - 왜 만들어진건가? - 자료형이 무한하다
//				오버로딩을 컴퓨터 시켜서 하자.
//
//			  이걸로 뭘 할 수 있나?
//
// 자료형에 무관한 함수를 기술할 수 있다	 - 알고리즘
// 자료형에 무관한 자료구조를 기술할 수 있다 - 자료구조
// 함수, 클래스
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

// 범위를 벗어난 인덱싱을 처리하는 INT 배열을 만든다

class INT_Array {
	int num;
	int* p;

public:
	INT_Array(int n) : num{ n }, p{ new int[num] }  {
		for (int i = 0; i < num; ++i)
			p[i] = 0;
	}
	~INT_Array() {
		delete[] p;
	}

	int size() const {
		return num;
	}

	int operator[](int idx) const {			// 읽기
		cout << "dd";
		return p[idx];
	}

	int& operator[](int idx) {				// 읽거나 쓰거나
		return p[idx];
	}

	int* begin() const {
		return p;
	}

	int* end() const {
		return p + num;		// 마지막 원소의 다음 위치
	}
};

int main()
{
	INT_Array a{ 10 };		// int 10개 들어갈 배열

	for (int i = 0; i < a.size(); ++i)
		a[i] = i + 1;


	for (int n : a)
		cout << n << ' ';

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-12-09 오후 1:10:05 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             12. 9 수   (14주 2일)
//
// Template - 왜 만들어진건가? - 자료형이 무한하다
//				오버로딩을 컴퓨터 시켜서 하자.
//
//			  이걸로 뭘 할 수 있나?
//
// 자료형에 무관한 함수를 기술할 수 있다	 - 알고리즘
// 자료형에 무관한 자료구조를 기술할 수 있다 - 자료구조
// 함수, 클래스
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

// 범위를 벗어난 인덱싱을 처리하는 INT 배열을 만든다

class INT_Array {
	int num;
	int* p;

public:
	INT_Array(int n) : num{ n }, p{ new int[num] }  {
		for (int i = 0; i < num; ++i)
			p[i] = 0;
	}
	~INT_Array() {
		delete[] p;
	}

	int size() const {
		return num;
	}

	int operator[](int idx) const {			// 읽기
		cout << "dd";
		return p[idx];
	}

	int& operator[](int idx) {				// 읽거나 쓰거나
		return p[idx];
	}

	int* begin() const {
		return p;
	}

	int* end() const {
		return p + num;		// 마지막 원소의 다음 위치
	}
};

int main()
{
	INT_Array a{ 10 };		// int 10개 들어갈 배열

	for (int i = 0; i < a.size(); ++i)
		a[i] = i + 1;


	for (const int n : a)
		cout << n << ' ';
	cout << endl;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-12-09 오후 1:12:13 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             12. 9 수   (14주 2일)
//
// Template - 왜 만들어진건가? - 자료형이 무한하다
//				오버로딩을 컴퓨터 시켜서 하자.
//
//			  이걸로 뭘 할 수 있나?
//
// 자료형에 무관한 함수를 기술할 수 있다	 - 알고리즘
// 자료형에 무관한 자료구조를 기술할 수 있다 - 자료구조
// 함수, 클래스
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

// 범위를 벗어난 인덱싱을 처리하는 INT 배열을 만든다

class INT_Array {
	int num;
	int* p;

public:
	INT_Array(int n) : num{ n }, p{ new int[num] }  {
		for (int i = 0; i < num; ++i)
			p[i] = 0;
	}
	~INT_Array() {
		delete[] p;
	}

	int size() const {
		return num;
	}

	int operator[](int idx) const {			// 읽기
		cout << "dd";
		return p[idx];
	}

	//int& operator[](int idx) {				// 읽거나 쓰거나
	//	return p[idx];
	//}

	int* begin() const {
		return p;
	}

	int* end() const {
		return p + num;		// 마지막 원소의 다음 위치
	}
};

int main()
{
	INT_Array a{ 10 };		// int 10개 들어갈 배열

//	for (int i = 0; i < a.size(); ++i)
//		a[i] = i + 1;


	for ( int i = 0; i < a.size(); ++i)
		cout << a[i] << ' ';
	cout << endl;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-12-09 오후 1:12:52 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             12. 9 수   (14주 2일)
//
// Template - 왜 만들어진건가? - 자료형이 무한하다
//				오버로딩을 컴퓨터 시켜서 하자.
//
//			  이걸로 뭘 할 수 있나?
//
// 자료형에 무관한 함수를 기술할 수 있다	 - 알고리즘
// 자료형에 무관한 자료구조를 기술할 수 있다 - 자료구조
// 함수, 클래스
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

// 범위를 벗어난 인덱싱을 처리하는 INT 배열을 만든다

class INT_Array {
	int num;
	int* p;

public:
	INT_Array(int n) : num{ n }, p{ new int[num] }  {
		for (int i = 0; i < num; ++i)
			p[i] = 0;
	}
	~INT_Array() {
		delete[] p;
	}

	int size() const {
		return num;
	}

	int operator[](int idx) const {			// 읽기
		cout << "dd";
		return p[idx];
	}

	int& operator[](int idx) {				// 읽거나 쓰거나
		cout << "cc";
		return p[idx];
	}

	int* begin() const {
		return p;
	}

	int* end() const {
		return p + num;		// 마지막 원소의 다음 위치
	}
};

int main()
{
	INT_Array a{ 10 };		// int 10개 들어갈 배열

	for (int i = 0; i < a.size(); ++i)
		a[i] = i + 1;


	for ( int i = 0; i < a.size(); ++i)
		cout << a[i] << ' ';
	cout << endl;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-12-09 오후 1:13:56 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             12. 9 수   (14주 2일)
//
// Template - 왜 만들어진건가? - 자료형이 무한하다
//				오버로딩을 컴퓨터 시켜서 하자.
//
//			  이걸로 뭘 할 수 있나?
//
// 자료형에 무관한 함수를 기술할 수 있다	 - 알고리즘
// 자료형에 무관한 자료구조를 기술할 수 있다 - 자료구조
// 함수, 클래스
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

// 범위를 벗어난 인덱싱을 처리하는 INT 배열을 만든다

class INT_Array {
	int num;
	int* p;

public:
	INT_Array(int n) : num{ n }, p{ new int[num] }  {
		for (int i = 0; i < num; ++i)
			p[i] = 0;
	}
	~INT_Array() {
		delete[] p;
	}

	int size() const {
		return num;
	}

	int& operator[](int idx) const {			// 읽기
		cout << "dd";
		return p[idx];
	}

	int& operator[](int idx) {				// 읽거나 쓰거나
		return p[idx];
	}

	int* begin() const {
		return p;
	}

	int* end() const {
		return p + num;		// 마지막 원소의 다음 위치
	}
};

int main()
{
	INT_Array a{ 10 };		// int 10개 들어갈 배열

	for (int i = 0; i < a.size(); ++i)
		a[i] = i + 1;


	for ( int i = 0; i < a.size(); ++i)
		cout << a[i] << ' ';
	cout << endl;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-12-09 오후 1:18:58 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             12. 9 수   (14주 2일)
//
// Template - 왜 만들어진건가? - 자료형이 무한하다
//				오버로딩을 컴퓨터 시켜서 하자.
//
//			  이걸로 뭘 할 수 있나?
//
// 자료형에 무관한 함수를 기술할 수 있다	 - 알고리즘
// 자료형에 무관한 자료구조를 기술할 수 있다 - 자료구조
// 함수, 클래스
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

// 범위를 벗어난 인덱싱을 처리하는 INT 배열을 만든다
// 템플릿으로 --> int를 T로 바꾸면 되겠다


template <typename T>
class Array {
	size_t num;
	T* p;

public:
	Array(size_t n) : num{ n }, p{ new T[num] }  {
		for (int i = 0; i < num; ++i)
			p[i] = T{ };
	}
	Array() {
		delete[] p;
	}

	size_t size() const {
		return num;
	}

	T operator[](int idx) const {			// 읽기
		cout << "dd";
		return p[idx];
	}

	T& operator[](int idx) {				// 읽거나 쓰거나
		return p[idx];
	}

	T* begin() const {
		return p;
	}

	T* end() const {
		return p + num;		// 마지막 원소의 다음 위치
	}
};

int main()
{
	Array<int> a{ 10 };		// int 10개 들어갈 배열

	for (int i = 0; i < a.size(); ++i)
		a[i] = i + 1;


	for ( int i = 0; i < a.size(); ++i)
		cout << a[i] << ' ';
	cout << endl;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-12-09 오후 1:19:27 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             12. 9 수   (14주 2일)
//
// Template - 왜 만들어진건가? - 자료형이 무한하다
//				오버로딩을 컴퓨터 시켜서 하자.
//
//			  이걸로 뭘 할 수 있나?
//
// 자료형에 무관한 함수를 기술할 수 있다	 - 알고리즘
// 자료형에 무관한 자료구조를 기술할 수 있다 - 자료구조
// 함수, 클래스
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

// 범위를 벗어난 인덱싱을 처리하는 INT 배열을 만든다
// 템플릿으로 --> int를 T로 바꾸면 되겠다


template <typename T>
class Array {
	size_t num;
	T* p;

public:
	Array(size_t n) : num{ n }, p{ new T[num] }  {
		for (int i = 0; i < num; ++i)
			p[i] = T{ };
	}
	Array() {
		delete[] p;
	}

	size_t size() const {
		return num;
	}

	T operator[](int idx) const {			// 읽기
		cout << "dd";
		return p[idx];
	}

	T& operator[](int idx) {				// 읽거나 쓰거나
		return p[idx];
	}

	T* begin() const {
		return p;
	}

	T* end() const {
		return p + num;		// 마지막 원소의 다음 위치
	}
};

int main()
{
	Array<string> a{ 10 };		// int 10개 들어갈 배열

	for (int i = 0; i < a.size(); ++i)
		a[i] = i + 1;


	for ( int i = 0; i < a.size(); ++i)
		cout << a[i] << ' ';
	cout << endl;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-12-09 오후 1:19:44 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             12. 9 수   (14주 2일)
//
// Template - 왜 만들어진건가? - 자료형이 무한하다
//				오버로딩을 컴퓨터 시켜서 하자.
//
//			  이걸로 뭘 할 수 있나?
//
// 자료형에 무관한 함수를 기술할 수 있다	 - 알고리즘
// 자료형에 무관한 자료구조를 기술할 수 있다 - 자료구조
// 함수, 클래스
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

// 범위를 벗어난 인덱싱을 처리하는 INT 배열을 만든다
// 템플릿으로 --> int를 T로 바꾸면 되겠다


template <typename T>
class Array {
	size_t num;
	T* p;

public:
	Array(size_t n) : num{ n }, p{ new T[num] }  {
		for (int i = 0; i < num; ++i)
			p[i] = T{ };
	}
	Array() {
		delete[] p;
	}

	size_t size() const {
		return num;
	}

	T operator[](int idx) const {			// 읽기
		cout << "dd";
		return p[idx];
	}

	T& operator[](int idx) {				// 읽거나 쓰거나
		return p[idx];
	}

	T* begin() const {
		return p;
	}

	T* end() const {
		return p + num;		// 마지막 원소의 다음 위치
	}
};

int main()
{
	Array<string> a{ 10 };		// int 10개 들어갈 배열

	for (int i = 0; i < a.size(); ++i)
		a[i] = i + 65;


	for ( int i = 0; i < a.size(); ++i)
		cout << a[i] << ' ';
	cout << endl;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-12-09 오후 1:21:15 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             12. 9 수   (14주 2일)
//
// Template - 왜 만들어진건가? - 자료형이 무한하다
//				오버로딩을 컴퓨터 시켜서 하자.
//
//			  이걸로 뭘 할 수 있나?
//
// 자료형에 무관한 함수를 기술할 수 있다	 - 알고리즘
// 자료형에 무관한 자료구조를 기술할 수 있다 - 자료구조
// 함수, 클래스
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// 범위를 벗어난 인덱싱을 처리하는 INT 배열을 만든다
// 템플릿으로 --> int를 T로 바꾸면 되겠다


template <typename T>
class Array {
	size_t num;
	T* p;

public:
	Array(size_t n) : num{ n }, p{ new T[num] }  {
		for (int i = 0; i < num; ++i)
			p[i] = T{ };
	}
	Array() {
		delete[] p;
	}

	size_t size() const {
		return num;
	}

	T operator[](int idx) const {			// 읽기
		cout << "dd";
		return p[idx];
	}

	T& operator[](int idx) {				// 읽거나 쓰거나
		return p[idx];
	}

	T* begin() const {
		return p;
	}

	T* end() const {
		return p + num;		// 마지막 원소의 다음 위치
	}
};

int main()
{
	Array<string> a{ 10 };		// int 10개 들어갈 배열

	for (int i = 0; i < a.size(); ++i)
		a[i] = 'a' + i;


	for ( int i = 0; i < a.size(); ++i)
		cout << a[i] << ' ';
	cout << endl;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-12-09 오후 1:23:33 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             12. 9 수   (14주 2일)
//
// Template - 왜 만들어진건가? - 자료형이 무한하다
//				오버로딩을 컴퓨터 시켜서 하자.
//
//			  이걸로 뭘 할 수 있나?
//
// 자료형에 무관한 함수를 기술할 수 있다	 - 알고리즘
// 자료형에 무관한 자료구조를 기술할 수 있다 - 자료구조
// 함수, 클래스
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// 범위를 벗어난 인덱싱을 처리하는 INT 배열을 만든다
// 템플릿으로 --> int를 T로 바꾸면 되겠다


template <typename T, int N>
class Array {
	T p[N];
public:
	Array() {}

	int size() const {
		return N;
	}

	T operator[](int idx) const {			// 읽기
		cout << "dd";
		return p[idx];
	}

	T& operator[](int idx) {				// 읽거나 쓰거나
		return p[idx];
	}

	T* begin() const {
		return p;
	}

	T* end() const {
		return p + N;		// 마지막 원소의 다음 위치
	}
};

int main()
{
	Array<string, 10> a;		// int 10개 들어갈 배열

	for (int i = 0; i < a.size(); ++i)
		a[i] = 'a' + i;


	for ( int i = 0; i < a.size(); ++i)
		cout << a[i] << ' ';
	cout << endl;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-12-09 오후 1:24:27 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             12. 9 수   (14주 2일)
//
// Template - 왜 만들어진건가? - 자료형이 무한하다
//				오버로딩을 컴퓨터 시켜서 하자.
//
//			  이걸로 뭘 할 수 있나?
//
// 자료형에 무관한 함수를 기술할 수 있다	 - 알고리즘
// 자료형에 무관한 자료구조를 기술할 수 있다 - 자료구조
// 함수, 클래스
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// 범위를 벗어난 인덱싱을 처리하는 INT 배열을 만든다
// 템플릿으로 --> int를 T로 바꾸면 되겠다


template <typename T, int N>
class Array {
	T p[N];
public:
	Array() {}

	int size() const {
		return N;
	}

	T operator[](int idx) const {			// 읽기
		cout << "dd";
		return p[idx];
	}

	T& operator[](int idx) {				// 읽거나 쓰거나
		return p[idx];
	}

	T* begin() const {
		return p;
	}

	T* end() const {
		return p + N;		// 마지막 원소의 다음 위치
	}
};

int main()
{
	Array<string, 10> a;		// int 10개 들어갈 배열

	for (int i = 0; i < a.size(); ++i)
		a[i] = 'a' + i;


	for ( int i = 0; i < a.size(); ++i)
		cout << a[i] << ' ';
	cout << endl;

	save("소스.cpp");
}


-------------------------------------------
소스.cpp - 2020-12-09 오후 1:24:44 - (수요일)
-------------------------------------------

//-----------------------------------------------------------------------------
// 2020년 2학기 C++ 월56 수34                             12. 9 수   (14주 2일)
//
// Template - 왜 만들어진건가? - 자료형이 무한하다
//				오버로딩을 컴퓨터 시켜서 하자.
//
//			  이걸로 뭘 할 수 있나?
//
// 자료형에 무관한 함수를 기술할 수 있다	 - 알고리즘
// 자료형에 무관한 자료구조를 기술할 수 있다 - 자료구조
// 함수, 클래스
//
// 시험3 12월 16일 수요일 (15주 2일)
//-----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// 범위를 벗어난 인덱싱을 처리하는 INT 배열을 만든다
// 템플릿으로 --> int를 T로 바꾸면 되겠다


template <typename T, int N>
class Array {
	T p[N];
public:
	Array() {}

	size_t size() const {
		return N;
	}

	T operator[](int idx) const {			// 읽기
		cout << "dd";
		return p[idx];
	}

	T& operator[](int idx) {				// 읽거나 쓰거나
		return p[idx];
	}

	T* begin() const {
		return p;
	}

	T* end() const {
		return p + N;		// 마지막 원소의 다음 위치
	}
};

int main()
{
	Array<string, 10> a;		// int 10개 들어갈 배열

	for (int i = 0; i < a.size(); ++i)
		a[i] = 'a' + i;


	for ( int i = 0; i < a.size(); ++i)
		cout << a[i] << ' ';
	cout << endl;

	save("소스.cpp");
}